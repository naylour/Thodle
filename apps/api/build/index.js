// @bun
var FD = Object.create;
var {
    getPrototypeOf: ID,
    defineProperty: TQ,
    getOwnPropertyNames: CD,
} = Object;
var RD = Object.prototype.hasOwnProperty;
var kQ = ($, X, W) => {
    W = $ != null ? FD(ID($)) : {};
    let Q =
        X || !$ || !$.__esModule
            ? TQ(W, 'default', { value: $, enumerable: !0 })
            : W;
    for (let Y of CD($))
        if (!RD.call(Q, Y)) TQ(Q, Y, { get: () => $[Y], enumerable: !0 });
    return Q;
};
var H0 = ($, X) => () => (X || $((X = { exports: {} }).exports, X), X.exports);
var k6 = ($, X) => {
    for (var W in X)
        TQ($, W, {
            get: X[W],
            enumerable: !0,
            configurable: !0,
            set: (Q) => (X[W] = () => Q),
        });
};
var h$ = ($, X) => () => ($ && (X = $(($ = 0))), X);
var n0 = import.meta.require;
var g$, V0;
var MW = h$(() => {
    g$ = class g$ extends Error {
        constructor() {
            super('End-Of-Stream');
            this.name = 'EndOfStreamError';
        }
    };
    V0 = class V0 extends Error {
        constructor($ = 'The operation was aborted') {
            super($);
            this.name = 'AbortError';
        }
    };
});
class _J {
    constructor() {
        (this.resolve = () => null),
            (this.reject = () => null),
            (this.promise = new Promise(($, X) => {
                (this.reject = X), (this.resolve = $);
            }));
    }
}
class E0 {
    constructor() {
        (this.endOfStream = !1), (this.interrupted = !1), (this.peekQueue = []);
    }
    async peek($, X = !1) {
        let W = await this.read($, X);
        return this.peekQueue.push($.subarray(0, W)), W;
    }
    async read($, X = !1) {
        if ($.length === 0) return 0;
        let W = this.readFromPeekBuffer($);
        if (!this.endOfStream)
            W += await this.readRemainderFromStream($.subarray(W), X);
        if (W === 0 && !X) throw new g$();
        return W;
    }
    readFromPeekBuffer($) {
        let X = $.length,
            W = 0;
        while (this.peekQueue.length > 0 && X > 0) {
            let Q = this.peekQueue.pop();
            if (!Q) throw new Error('peekData should be defined');
            let Y = Math.min(Q.length, X);
            if (($.set(Q.subarray(0, Y), W), (W += Y), (X -= Y), Y < Q.length))
                this.peekQueue.push(Q.subarray(Y));
        }
        return W;
    }
    async readRemainderFromStream($, X) {
        let W = 0;
        while (W < $.length && !this.endOfStream) {
            if (this.interrupted) throw new V0();
            let Q = await this.readFromStream($.subarray(W), X);
            if (Q === 0) break;
            W += Q;
        }
        if (!X && W < $.length) throw new g$();
        return W;
    }
}
var aY = h$(() => {
    MW();
});
var sY;
var nG = h$(() => {
    MW();
    aY();
    sY = class sY extends E0 {
        constructor($) {
            super();
            if (((this.s = $), (this.deferred = null), !$.read || !$.once))
                throw new Error('Expected an instance of stream.Readable');
            this.s.once('end', () => {
                if (((this.endOfStream = !0), this.deferred))
                    this.deferred.resolve(0);
            }),
                this.s.once('error', (X) => this.reject(X)),
                this.s.once('close', () => this.abort());
        }
        async readFromStream($, X) {
            if ($.length === 0) return 0;
            let W = this.s.read($.length);
            if (W) return $.set(W), W.length;
            let Q = { buffer: $, mayBeLess: X, deferred: new _J() };
            return (
                (this.deferred = Q.deferred),
                this.s.once('readable', () => {
                    this.readDeferred(Q);
                }),
                Q.deferred.promise
            );
        }
        readDeferred($) {
            let X = this.s.read($.buffer.length);
            if (X)
                $.buffer.set(X),
                    $.deferred.resolve(X.length),
                    (this.deferred = null);
            else
                this.s.once('readable', () => {
                    this.readDeferred($);
                });
        }
        reject($) {
            if (((this.interrupted = !0), this.deferred))
                this.deferred.reject($), (this.deferred = null);
        }
        async abort() {
            this.reject(new V0());
        }
        async close() {
            return this.abort();
        }
    };
});
var FJ;
var pG = h$(() => {
    aY();
    FJ = class FJ extends E0 {
        constructor($) {
            super();
            this.reader = $;
        }
        async abort() {
            return this.close();
        }
        async close() {
            this.reader.releaseLock();
        }
    };
});
var eY;
var IJ = h$(() => {
    pG();
    eY = class eY extends FJ {
        async readFromStream($, X) {
            if ($.length === 0) return 0;
            let W = await this.reader.read(new Uint8Array($.length), {
                min: X ? void 0 : $.length,
            });
            if (W.done) this.endOfStream = W.done;
            if (W.value) return $.set(W.value), W.value.length;
            return 0;
        }
    };
});
var GW;
var CJ = h$(() => {
    MW();
    aY();
    GW = class GW extends E0 {
        constructor($) {
            super();
            (this.reader = $), (this.buffer = null);
        }
        writeChunk($, X) {
            let W = Math.min(X.length, $.length);
            if (($.set(X.subarray(0, W)), W < X.length))
                this.buffer = X.subarray(W);
            else this.buffer = null;
            return W;
        }
        async readFromStream($, X) {
            if ($.length === 0) return 0;
            let W = 0;
            if (this.buffer) W += this.writeChunk($, this.buffer);
            while (W < $.length && !this.endOfStream) {
                let Q = await this.reader.read();
                if (Q.done) {
                    this.endOfStream = !0;
                    break;
                }
                if (Q.value) W += this.writeChunk($.subarray(W), Q.value);
            }
            if (!X && W === 0 && this.endOfStream) throw new g$();
            return W;
        }
        abort() {
            return (this.interrupted = !0), this.reader.cancel();
        }
        async close() {
            await this.abort(), this.reader.releaseLock();
        }
    };
});
function RJ($) {
    try {
        let X = $.getReader({ mode: 'byob' });
        if (X instanceof ReadableStreamDefaultReader) return new GW(X);
        return new eY(X);
    } catch (X) {
        if (X instanceof TypeError) return new GW($.getReader());
        throw X;
    }
}
var lG = h$(() => {
    IJ();
    CJ();
});
var Y0 = h$(() => {
    MW();
    nG();
    IJ();
    CJ();
    lG();
});
class E1 {
    constructor($) {
        if (
            ((this.numBuffer = new Uint8Array(8)),
            (this.position = 0),
            (this.onClose = $?.onClose),
            $?.abortSignal)
        )
            $.abortSignal.addEventListener('abort', () => {
                this.abort();
            });
    }
    async readToken($, X = this.position) {
        let W = new Uint8Array($.len);
        if ((await this.readBuffer(W, { position: X })) < $.len) throw new g$();
        return $.get(W, 0);
    }
    async peekToken($, X = this.position) {
        let W = new Uint8Array($.len);
        if ((await this.peekBuffer(W, { position: X })) < $.len) throw new g$();
        return $.get(W, 0);
    }
    async readNumber($) {
        if ((await this.readBuffer(this.numBuffer, { length: $.len })) < $.len)
            throw new g$();
        return $.get(this.numBuffer, 0);
    }
    async peekNumber($) {
        if ((await this.peekBuffer(this.numBuffer, { length: $.len })) < $.len)
            throw new g$();
        return $.get(this.numBuffer, 0);
    }
    async ignore($) {
        if (this.fileInfo.size !== void 0) {
            let X = this.fileInfo.size - this.position;
            if ($ > X) return (this.position += X), X;
        }
        return (this.position += $), $;
    }
    async close() {
        await this.abort(), await this.onClose?.();
    }
    normalizeOptions($, X) {
        if (
            !this.supportsRandomAccess() &&
            X &&
            X.position !== void 0 &&
            X.position < this.position
        )
            throw new Error(
                '`options.position` must be equal or greater than `tokenizer.position`',
            );
        return {
            ...{
                mayBeLess: !1,
                offset: 0,
                length: $.length,
                position: this.position,
            },
            ...X,
        };
    }
    abort() {
        return Promise.resolve();
    }
}
var qX = h$(() => {
    Y0();
});
var zK = 256000,
    $8;
var oG = h$(() => {
    qX();
    Y0();
    $8 = class $8 extends E1 {
        constructor($, X) {
            super(X);
            (this.streamReader = $), (this.fileInfo = X?.fileInfo ?? {});
        }
        async readBuffer($, X) {
            let W = this.normalizeOptions($, X),
                Q = W.position - this.position;
            if (Q > 0) return await this.ignore(Q), this.readBuffer($, X);
            if (Q < 0)
                throw new Error(
                    '`options.position` must be equal or greater than `tokenizer.position`',
                );
            if (W.length === 0) return 0;
            let Y = await this.streamReader.read(
                $.subarray(0, W.length),
                W.mayBeLess,
            );
            if (((this.position += Y), (!X || !X.mayBeLess) && Y < W.length))
                throw new g$();
            return Y;
        }
        async peekBuffer($, X) {
            let W = this.normalizeOptions($, X),
                Q = 0;
            if (W.position) {
                let Y = W.position - this.position;
                if (Y > 0) {
                    let J = new Uint8Array(W.length + Y);
                    return (
                        (Q = await this.peekBuffer(J, {
                            mayBeLess: W.mayBeLess,
                        })),
                        $.set(J.subarray(Y)),
                        Q - Y
                    );
                }
                if (Y < 0)
                    throw new Error(
                        'Cannot peek from a negative offset in a stream',
                    );
            }
            if (W.length > 0) {
                try {
                    Q = await this.streamReader.peek(
                        $.subarray(0, W.length),
                        W.mayBeLess,
                    );
                } catch (Y) {
                    if (X?.mayBeLess && Y instanceof g$) return 0;
                    throw Y;
                }
                if (!W.mayBeLess && Q < W.length) throw new g$();
            }
            return Q;
        }
        async ignore($) {
            let X = Math.min(zK, $),
                W = new Uint8Array(X),
                Q = 0;
            while (Q < $) {
                let Y = $ - Q,
                    J = await this.readBuffer(W, { length: Math.min(X, Y) });
                if (J < 0) return J;
                Q += J;
            }
            return Q;
        }
        abort() {
            return this.streamReader.abort();
        }
        async close() {
            return this.streamReader.close();
        }
        supportsRandomAccess() {
            return !1;
        }
    };
});
var VJ;
var rG = h$(() => {
    Y0();
    qX();
    VJ = class VJ extends E1 {
        constructor($, X) {
            super(X);
            (this.uint8Array = $),
                (this.fileInfo = {
                    ...(X?.fileInfo ?? {}),
                    ...{ size: $.length },
                });
        }
        async readBuffer($, X) {
            if (X?.position) this.position = X.position;
            let W = await this.peekBuffer($, X);
            return (this.position += W), W;
        }
        async peekBuffer($, X) {
            let W = this.normalizeOptions($, X),
                Q = Math.min(this.uint8Array.length - W.position, W.length);
            if (!W.mayBeLess && Q < W.length) throw new g$();
            return (
                $.set(this.uint8Array.subarray(W.position, W.position + Q)), Q
            );
        }
        close() {
            return super.close();
        }
        supportsRandomAccess() {
            return !0;
        }
        setPosition($) {
            this.position = $;
        }
    };
});
var tG = h$(() => {
    Y0();
    qX();
});
function aG($, X) {
    let W = new sY($),
        Q = X ?? {},
        Y = Q.onClose;
    return (
        (Q.onClose = async () => {
            if ((await W.close(), Y)) return Y();
        }),
        new $8(W, Q)
    );
}
function X8($, X) {
    let W = RJ($),
        Q = X ?? {},
        Y = Q.onClose;
    return (
        (Q.onClose = async () => {
            if ((await W.close(), Y)) return Y();
        }),
        new $8(W, Q)
    );
}
function sG($, X) {
    return new VJ($, X);
}
var W8 = h$(() => {
    Y0();
    oG();
    rG();
    tG();
    Y0();
    qX();
});
import { open as wK } from 'fs/promises';
var zW;
var EJ = h$(() => {
    qX();
    Y0();
    zW = class zW extends E1 {
        static async fromFile($) {
            let X = await wK($, 'r'),
                W = await X.stat();
            return new zW(X, { fileInfo: { path: $, size: W.size } });
        }
        constructor($, X) {
            super(X);
            (this.fileHandle = $), (this.fileInfo = X.fileInfo);
        }
        async readBuffer($, X) {
            let W = this.normalizeOptions($, X);
            if (((this.position = W.position), W.length === 0)) return 0;
            let Q = await this.fileHandle.read($, 0, W.length, W.position);
            if (
                ((this.position += Q.bytesRead),
                Q.bytesRead < W.length && (!X || !X.mayBeLess))
            )
                throw new g$();
            return Q.bytesRead;
        }
        async peekBuffer($, X) {
            let W = this.normalizeOptions($, X),
                Q = await this.fileHandle.read($, 0, W.length, W.position);
            if (!W.mayBeLess && Q.bytesRead < W.length) throw new g$();
            return Q.bytesRead;
        }
        async close() {
            return await this.fileHandle.close(), super.close();
        }
        setPosition($) {
            this.position = $;
        }
        supportsRandomAccess() {
            return !0;
        }
    };
});
import { stat as DK } from 'fs/promises';
async function eG($, X) {
    let W = aG($, X);
    if ($.path) {
        let Q = await DK($.path);
        (W.fileInfo.path = $.path), (W.fileInfo.size = Q.size);
    }
    return W;
}
var $z;
var Xz = h$(() => {
    W8();
    EJ();
    EJ();
    W8();
    $z = zW.fromFile;
});
var Wz = h$(() => {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});
function o6($) {
    return new DataView($.buffer, $.byteOffset);
}
class b6 {
    constructor($, X) {
        if (((this.len = $), X && X.toLowerCase() === 'windows-1252'))
            this.decoder = b6.decodeWindows1252;
        else {
            let W = new TextDecoder(X);
            this.decoder = (Q) => W.decode(Q);
        }
    }
    get($, X = 0) {
        let W = $.subarray(X, X + this.len);
        return this.decoder(W);
    }
    static decodeWindows1252($) {
        let X = '';
        for (let W = 0; W < $.length; W++) {
            let Q = $[W];
            X +=
                Q < 128 || Q >= 160
                    ? String.fromCharCode(Q)
                    : b6.win1252Map[Q - 128];
        }
        return X;
    }
}
var Yz, l$, AX, J6, Qz, Jz, Uz;
var ZW = h$(() => {
    Wz();
    (Yz = {
        len: 1,
        get($, X) {
            return o6($).getUint8(X);
        },
        put($, X, W) {
            return o6($).setUint8(X, W), X + 1;
        },
    }),
        (l$ = {
            len: 2,
            get($, X) {
                return o6($).getUint16(X, !0);
            },
            put($, X, W) {
                return o6($).setUint16(X, W, !0), X + 2;
            },
        }),
        (AX = {
            len: 2,
            get($, X) {
                return o6($).getUint16(X);
            },
            put($, X, W) {
                return o6($).setUint16(X, W), X + 2;
            },
        }),
        (J6 = {
            len: 4,
            get($, X) {
                return o6($).getUint32(X, !0);
            },
            put($, X, W) {
                return o6($).setUint32(X, W, !0), X + 4;
            },
        }),
        (Qz = {
            len: 4,
            get($, X) {
                return o6($).getUint32(X);
            },
            put($, X, W) {
                return o6($).setUint32(X, W), X + 4;
            },
        }),
        (Jz = {
            len: 4,
            get($, X) {
                return o6($).getInt32(X);
            },
            put($, X, W) {
                return o6($).setInt32(X, W), X + 4;
            },
        }),
        (Uz = {
            len: 8,
            get($, X) {
                return o6($).getBigUint64(X, !0);
            },
            put($, X, W) {
                return o6($).setBigUint64(X, W, !0), X + 8;
            },
        });
    b6.win1252Map =
        '\u20AC\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\u017D\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\u017E\u0178';
});
import { createRequire as qK } from 'module';
function gK($, X) {
    return TJ($, { i: 2 }, X && X.out, X && X.dictionary);
}
function TK($, X) {
    var W = EK($);
    if (W + 8 > $.length) D4(6, 'invalid gzip data');
    return TJ(
        $.subarray(W, -8),
        { i: 2 },
        (X && X.out) || new B4(xK($)),
        X && X.dictionary,
    );
}
function kK($, X) {
    return TJ(
        $.subarray(bK($, X && X.dictionary), -4),
        { i: 2 },
        X && X.out,
        X && X.dictionary,
    );
}
function Bz($, X) {
    return $[0] == 31 && $[1] == 139 && $[2] == 8
        ? TK($, X)
        : ($[0] & 15) != 8 || $[0] >> 4 > 7 || (($[0] << 8) | $[1]) % 31
          ? gK($, X)
          : kK($, X);
}
var AK,
    PK,
    B4,
    PX,
    SK,
    Nz,
    Mz,
    jK,
    Gz = function ($, X) {
        var W = new PX(31);
        for (var Q = 0; Q < 31; ++Q) W[Q] = X += 1 << $[Q - 1];
        var Y = new SK(W[30]);
        for (var Q = 1; Q < 30; ++Q)
            for (var J = W[Q]; J < W[Q + 1]; ++J) Y[J] = ((J - W[Q]) << 5) | Q;
        return { b: W, r: Y };
    },
    zz,
    Zz,
    LK,
    wz,
    KK,
    Jd,
    gJ,
    J1,
    G$,
    wW = function ($, X, W) {
        var Q = $.length,
            Y = 0,
            J = new PX(X);
        for (; Y < Q; ++Y) if ($[Y]) ++J[$[Y] - 1];
        var U = new PX(X);
        for (Y = 1; Y < X; ++Y) U[Y] = (U[Y - 1] + J[Y - 1]) << 1;
        var N;
        if (W) {
            N = new PX(1 << X);
            var M = 15 - X;
            for (Y = 0; Y < Q; ++Y)
                if ($[Y]) {
                    var G = (Y << 4) | $[Y],
                        Z = X - $[Y],
                        B = U[$[Y] - 1]++ << Z;
                    for (var O = B | ((1 << Z) - 1); B <= O; ++B)
                        N[gJ[B] >> M] = G;
                }
        } else {
            N = new PX(Q);
            for (Y = 0; Y < Q; ++Y)
                if ($[Y]) N[Y] = gJ[U[$[Y] - 1]++] >> (15 - $[Y]);
        }
        return N;
    },
    DW,
    G$,
    G$,
    G$,
    G$,
    Dz,
    G$,
    _K,
    FK,
    xJ = function ($) {
        var X = $[0];
        for (var W = 1; W < $.length; ++W) if ($[W] > X) X = $[W];
        return X;
    },
    r4 = function ($, X, W) {
        var Q = (X / 8) | 0;
        return (($[Q] | ($[Q + 1] << 8)) >> (X & 7)) & W;
    },
    bJ = function ($, X) {
        var W = (X / 8) | 0;
        return ($[W] | ($[W + 1] << 8) | ($[W + 2] << 16)) >> (X & 7);
    },
    IK = function ($) {
        return (($ + 7) / 8) | 0;
    },
    CK = function ($, X, W) {
        if (X == null || X < 0) X = 0;
        if (W == null || W > $.length) W = $.length;
        return new B4($.subarray(X, W));
    },
    RK,
    D4 = function ($, X, W) {
        var Q = new Error(X || RK[$]);
        if (((Q.code = $), Error.captureStackTrace))
            Error.captureStackTrace(Q, D4);
        if (!W) throw Q;
        return Q;
    },
    TJ = function ($, X, W, Q) {
        var Y = $.length,
            J = Q ? Q.length : 0;
        if (!Y || (X.f && !X.l)) return W || new B4(0);
        var U = !W,
            N = U || X.i != 2,
            M = X.i;
        if (U) W = new B4(Y * 3);
        var G = function (D) {
                var K = W.length;
                if (D > K) {
                    var q = new B4(Math.max(K * 2, D));
                    q.set(W), (W = q);
                }
            },
            Z = X.f || 0,
            B = X.p || 0,
            O = X.b || 0,
            w = X.l,
            z = X.d,
            H = X.m,
            P = X.n,
            E = Y * 8;
        do {
            if (!w) {
                Z = r4($, B, 1);
                var j = r4($, B + 1, 3);
                if (((B += 3), !j)) {
                    var V = IK(B) + 4,
                        i = $[V - 4] | ($[V - 3] << 8),
                        $$ = V + i;
                    if ($$ > Y) {
                        if (M) D4(0);
                        break;
                    }
                    if (N) G(O + i);
                    W.set($.subarray(V, $$), O),
                        (X.b = O += i),
                        (X.p = B = $$ * 8),
                        (X.f = Z);
                    continue;
                } else if (j == 1) (w = _K), (z = FK), (H = 9), (P = 5);
                else if (j == 2) {
                    var y = r4($, B, 31) + 257,
                        n = r4($, B + 10, 15) + 4,
                        k = y + r4($, B + 5, 31) + 1;
                    B += 14;
                    var b = new B4(k),
                        T = new B4(19);
                    for (var o = 0; o < n; ++o) T[jK[o]] = r4($, B + o * 3, 7);
                    B += n * 3;
                    var e = xJ(T),
                        W$ = (1 << e) - 1,
                        W4 = wW(T, e, 1);
                    for (var o = 0; o < k; ) {
                        var A$ = W4[r4($, B, W$)];
                        B += A$ & 15;
                        var V = A$ >> 4;
                        if (V < 16) b[o++] = V;
                        else {
                            var c6 = 0,
                                Z1 = 0;
                            if (V == 16)
                                (Z1 = 3 + r4($, B, 3)),
                                    (B += 2),
                                    (c6 = b[o - 1]);
                            else if (V == 17) (Z1 = 3 + r4($, B, 7)), (B += 3);
                            else if (V == 18)
                                (Z1 = 11 + r4($, B, 127)), (B += 7);
                            while (Z1--) b[o++] = c6;
                        }
                    }
                    var w1 = b.subarray(0, y),
                        q4 = b.subarray(y);
                    (H = xJ(w1)),
                        (P = xJ(q4)),
                        (w = wW(w1, H, 1)),
                        (z = wW(q4, P, 1));
                } else D4(1);
                if (B > E) {
                    if (M) D4(0);
                    break;
                }
            }
            if (N) G(O + 131072);
            var e4 = (1 << H) - 1,
                s$ = (1 << P) - 1,
                U6 = B;
            for (; ; U6 = B) {
                var c6 = w[bJ($, B) & e4],
                    j6 = c6 >> 4;
                if (((B += c6 & 15), B > E)) {
                    if (M) D4(0);
                    break;
                }
                if (!c6) D4(2);
                if (j6 < 256) W[O++] = j6;
                else if (j6 == 256) {
                    (U6 = B), (w = null);
                    break;
                } else {
                    var x4 = j6 - 254;
                    if (j6 > 264) {
                        var o = j6 - 257,
                            T6 = Nz[o];
                        (x4 = r4($, B, (1 << T6) - 1) + Zz[o]), (B += T6);
                    }
                    var A4 = z[bJ($, B) & s$],
                        n1 = A4 >> 4;
                    if (!A4) D4(3);
                    B += A4 & 15;
                    var q4 = KK[n1];
                    if (n1 > 3) {
                        var T6 = Mz[n1];
                        (q4 += bJ($, B) & ((1 << T6) - 1)), (B += T6);
                    }
                    if (B > E) {
                        if (M) D4(0);
                        break;
                    }
                    if (N) G(O + 131072);
                    var b4 = O + x4;
                    if (O < q4) {
                        var u = J - q4,
                            R = Math.min(q4, b4);
                        if (u + O < 0) D4(3);
                        for (; O < R; ++O) W[O] = Q[u + O];
                    }
                    for (; O < b4; ++O) W[O] = W[O - q4];
                }
            }
            if (((X.l = w), (X.p = U6), (X.b = O), (X.f = Z), w))
                (Z = 1), (X.m = H), (X.d = z), (X.n = P);
        } while (!Z);
        return O != W.length && U ? CK(W, 0, O) : W.subarray(0, O);
    },
    VK,
    EK = function ($) {
        if ($[0] != 31 || $[1] != 139 || $[2] != 8) D4(6, 'invalid gzip data');
        var X = $[3],
            W = 10;
        if (X & 4) W += ($[10] | ($[11] << 8)) + 2;
        for (var Q = ((X >> 3) & 1) + ((X >> 4) & 1); Q > 0; Q -= !$[W++]);
        return W + (X & 2);
    },
    xK = function ($) {
        var X = $.length;
        return (
            ($[X - 4] |
                ($[X - 3] << 8) |
                ($[X - 2] << 16) |
                ($[X - 1] << 24)) >>>
            0
        );
    },
    bK = function ($, X) {
        if (($[0] & 15) != 8 || $[0] >> 4 > 7 || (($[0] << 8) | $[1]) % 31)
            D4(6, 'invalid zlib data');
        if ((($[1] >> 5) & 1) == +!X)
            D4(
                6,
                'invalid zlib data: ' +
                    ($[1] & 32 ? 'need' : 'unexpected') +
                    ' dictionary',
            );
        return (($[1] >> 3) & 4) + 2;
    },
    vK,
    fK = 0;
var Oz = h$(() => {
    AK = qK('/');
    try {
        PK = AK('worker_threads').Worker;
    } catch ($) {}
    (B4 = Uint8Array),
        (PX = Uint16Array),
        (SK = Int32Array),
        (Nz = new B4([
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
            4, 5, 5, 5, 5, 0, 0, 0, 0,
        ])),
        (Mz = new B4([
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
        ])),
        (jK = new B4([
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
        ])),
        (zz = Gz(Nz, 2)),
        (Zz = zz.b),
        (LK = zz.r);
    (Zz[28] = 258), (LK[258] = 28);
    (wz = Gz(Mz, 0)), (KK = wz.b), (Jd = wz.r), (gJ = new PX(32768));
    for (G$ = 0; G$ < 32768; ++G$)
        (J1 = ((G$ & 43690) >> 1) | ((G$ & 21845) << 1)),
            (J1 = ((J1 & 52428) >> 2) | ((J1 & 13107) << 2)),
            (J1 = ((J1 & 61680) >> 4) | ((J1 & 3855) << 4)),
            (gJ[G$] = (((J1 & 65280) >> 8) | ((J1 & 255) << 8)) >> 1);
    DW = new B4(288);
    for (G$ = 0; G$ < 144; ++G$) DW[G$] = 8;
    for (G$ = 144; G$ < 256; ++G$) DW[G$] = 9;
    for (G$ = 256; G$ < 280; ++G$) DW[G$] = 7;
    for (G$ = 280; G$ < 288; ++G$) DW[G$] = 8;
    Dz = new B4(32);
    for (G$ = 0; G$ < 32; ++G$) Dz[G$] = 5;
    (_K = wW(DW, 9, 1)),
        (FK = wW(Dz, 5, 1)),
        (RK = [
            'unexpected EOF',
            'invalid block type',
            'invalid length/literal',
            'invalid distance',
            'stream finished',
            'no stream handler',
            ,
            'no callback',
            'invalid UTF-8 data',
            'extra field too long',
            'date not in range 1980-2099',
            'filename too long',
            'stream finishing',
            'invalid zip data',
        ]),
        (VK = new B4(0));
    vK = typeof TextDecoder != 'undefined' && new TextDecoder();
    try {
        vK.decode(VK, { stream: !0 }), (fK = 1);
    } catch ($) {}
});
var qz = H0((Nd, Hz) => {
    var SX = 1000,
        jX = SX * 60,
        LX = jX * 60,
        x0 = LX * 24,
        yK = x0 * 7,
        hK = x0 * 365.25;
    Hz.exports = function ($, X) {
        X = X || {};
        var W = typeof $;
        if (W === 'string' && $.length > 0) return mK($);
        else if (W === 'number' && isFinite($)) return X.long ? uK($) : cK($);
        throw new Error(
            'val is not a non-empty string or a valid number. val=' +
                JSON.stringify($),
        );
    };
    function mK($) {
        if ((($ = String($)), $.length > 100)) return;
        var X =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                $,
            );
        if (!X) return;
        var W = parseFloat(X[1]),
            Q = (X[2] || 'ms').toLowerCase();
        switch (Q) {
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
                return W * hK;
            case 'weeks':
            case 'week':
            case 'w':
                return W * yK;
            case 'days':
            case 'day':
            case 'd':
                return W * x0;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
                return W * LX;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
                return W * jX;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
                return W * SX;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
                return W;
            default:
                return;
        }
    }
    function cK($) {
        var X = Math.abs($);
        if (X >= x0) return Math.round($ / x0) + 'd';
        if (X >= LX) return Math.round($ / LX) + 'h';
        if (X >= jX) return Math.round($ / jX) + 'm';
        if (X >= SX) return Math.round($ / SX) + 's';
        return $ + 'ms';
    }
    function uK($) {
        var X = Math.abs($);
        if (X >= x0) return Y8($, X, x0, 'day');
        if (X >= LX) return Y8($, X, LX, 'hour');
        if (X >= jX) return Y8($, X, jX, 'minute');
        if (X >= SX) return Y8($, X, SX, 'second');
        return $ + ' ms';
    }
    function Y8($, X, W, Q) {
        var Y = X >= W * 1.5;
        return Math.round($ / W) + ' ' + Q + (Y ? 's' : '');
    }
});
var kJ = H0((Md, Az) => {
    function dK($) {
        (W.debug = W),
            (W.default = W),
            (W.coerce = M),
            (W.disable = U),
            (W.enable = Y),
            (W.enabled = N),
            (W.humanize = qz()),
            (W.destroy = G),
            Object.keys($).forEach((Z) => {
                W[Z] = $[Z];
            }),
            (W.names = []),
            (W.skips = []),
            (W.formatters = {});
        function X(Z) {
            let B = 0;
            for (let O = 0; O < Z.length; O++)
                (B = (B << 5) - B + Z.charCodeAt(O)), (B |= 0);
            return W.colors[Math.abs(B) % W.colors.length];
        }
        W.selectColor = X;
        function W(Z) {
            let B,
                O = null,
                w,
                z;
            function H(...P) {
                if (!H.enabled) return;
                let E = H,
                    j = Number(new Date()),
                    V = j - (B || j);
                if (
                    ((E.diff = V),
                    (E.prev = B),
                    (E.curr = j),
                    (B = j),
                    (P[0] = W.coerce(P[0])),
                    typeof P[0] !== 'string')
                )
                    P.unshift('%O');
                let i = 0;
                (P[0] = P[0].replace(/%([a-zA-Z%])/g, (y, n) => {
                    if (y === '%%') return '%';
                    i++;
                    let k = W.formatters[n];
                    if (typeof k === 'function') {
                        let b = P[i];
                        (y = k.call(E, b)), P.splice(i, 1), i--;
                    }
                    return y;
                })),
                    W.formatArgs.call(E, P),
                    (E.log || W.log).apply(E, P);
            }
            if (
                ((H.namespace = Z),
                (H.useColors = W.useColors()),
                (H.color = W.selectColor(Z)),
                (H.extend = Q),
                (H.destroy = W.destroy),
                Object.defineProperty(H, 'enabled', {
                    enumerable: !0,
                    configurable: !1,
                    get: () => {
                        if (O !== null) return O;
                        if (w !== W.namespaces)
                            (w = W.namespaces), (z = W.enabled(Z));
                        return z;
                    },
                    set: (P) => {
                        O = P;
                    },
                }),
                typeof W.init === 'function')
            )
                W.init(H);
            return H;
        }
        function Q(Z, B) {
            let O = W(
                this.namespace + (typeof B === 'undefined' ? ':' : B) + Z,
            );
            return (O.log = this.log), O;
        }
        function Y(Z) {
            W.save(Z), (W.namespaces = Z), (W.names = []), (W.skips = []);
            let B = (typeof Z === 'string' ? Z : '')
                .trim()
                .replace(/\s+/g, ',')
                .split(',')
                .filter(Boolean);
            for (let O of B)
                if (O[0] === '-') W.skips.push(O.slice(1));
                else W.names.push(O);
        }
        function J(Z, B) {
            let O = 0,
                w = 0,
                z = -1,
                H = 0;
            while (O < Z.length)
                if (w < B.length && (B[w] === Z[O] || B[w] === '*'))
                    if (B[w] === '*') (z = w), (H = O), w++;
                    else O++, w++;
                else if (z !== -1) (w = z + 1), H++, (O = H);
                else return !1;
            while (w < B.length && B[w] === '*') w++;
            return w === B.length;
        }
        function U() {
            let Z = [...W.names, ...W.skips.map((B) => '-' + B)].join(',');
            return W.enable(''), Z;
        }
        function N(Z) {
            for (let B of W.skips) if (J(Z, B)) return !1;
            for (let B of W.names) if (J(Z, B)) return !0;
            return !1;
        }
        function M(Z) {
            if (Z instanceof Error) return Z.stack || Z.message;
            return Z;
        }
        function G() {
            console.warn(
                'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
            );
        }
        return W.enable(W.load()), W;
    }
    Az.exports = dK;
});
var Sz = H0((Pz, Q8) => {
    Pz.formatArgs = nK;
    Pz.save = pK;
    Pz.load = lK;
    Pz.useColors = iK;
    Pz.storage = oK();
    Pz.destroy = (() => {
        let $ = !1;
        return () => {
            if (!$)
                ($ = !0),
                    console.warn(
                        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
                    );
        };
    })();
    Pz.colors = [
        '#0000CC',
        '#0000FF',
        '#0033CC',
        '#0033FF',
        '#0066CC',
        '#0066FF',
        '#0099CC',
        '#0099FF',
        '#00CC00',
        '#00CC33',
        '#00CC66',
        '#00CC99',
        '#00CCCC',
        '#00CCFF',
        '#3300CC',
        '#3300FF',
        '#3333CC',
        '#3333FF',
        '#3366CC',
        '#3366FF',
        '#3399CC',
        '#3399FF',
        '#33CC00',
        '#33CC33',
        '#33CC66',
        '#33CC99',
        '#33CCCC',
        '#33CCFF',
        '#6600CC',
        '#6600FF',
        '#6633CC',
        '#6633FF',
        '#66CC00',
        '#66CC33',
        '#9900CC',
        '#9900FF',
        '#9933CC',
        '#9933FF',
        '#99CC00',
        '#99CC33',
        '#CC0000',
        '#CC0033',
        '#CC0066',
        '#CC0099',
        '#CC00CC',
        '#CC00FF',
        '#CC3300',
        '#CC3333',
        '#CC3366',
        '#CC3399',
        '#CC33CC',
        '#CC33FF',
        '#CC6600',
        '#CC6633',
        '#CC9900',
        '#CC9933',
        '#CCCC00',
        '#CCCC33',
        '#FF0000',
        '#FF0033',
        '#FF0066',
        '#FF0099',
        '#FF00CC',
        '#FF00FF',
        '#FF3300',
        '#FF3333',
        '#FF3366',
        '#FF3399',
        '#FF33CC',
        '#FF33FF',
        '#FF6600',
        '#FF6633',
        '#FF9900',
        '#FF9933',
        '#FFCC00',
        '#FFCC33',
    ];
    function iK() {
        if (
            typeof window !== 'undefined' &&
            window.process &&
            (window.process.type === 'renderer' || window.process.__nwjs)
        )
            return !0;
        if (
            typeof navigator !== 'undefined' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        )
            return !1;
        let $;
        return (
            (typeof document !== 'undefined' &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
            (typeof window !== 'undefined' &&
                window.console &&
                (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
            (typeof navigator !== 'undefined' &&
                navigator.userAgent &&
                ($ = navigator.userAgent
                    .toLowerCase()
                    .match(/firefox\/(\d+)/)) &&
                parseInt($[1], 10) >= 31) ||
            (typeof navigator !== 'undefined' &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        );
    }
    function nK($) {
        if (
            (($[0] =
                (this.useColors ? '%c' : '') +
                this.namespace +
                (this.useColors ? ' %c' : ' ') +
                $[0] +
                (this.useColors ? '%c ' : ' ') +
                '+' +
                Q8.exports.humanize(this.diff)),
            !this.useColors)
        )
            return;
        let X = 'color: ' + this.color;
        $.splice(1, 0, X, 'color: inherit');
        let W = 0,
            Q = 0;
        $[0].replace(/%[a-zA-Z%]/g, (Y) => {
            if (Y === '%%') return;
            if ((W++, Y === '%c')) Q = W;
        }),
            $.splice(Q, 0, X);
    }
    Pz.log = console.debug || console.log || (() => {});
    function pK($) {
        try {
            if ($) Pz.storage.setItem('debug', $);
            else Pz.storage.removeItem('debug');
        } catch (X) {}
    }
    function lK() {
        let $;
        try {
            $ = Pz.storage.getItem('debug') || Pz.storage.getItem('DEBUG');
        } catch (X) {}
        if (!$ && typeof process !== 'undefined' && 'env' in process)
            $ = process.env.DEBUG;
        return $;
    }
    function oK() {
        try {
            return localStorage;
        } catch ($) {}
    }
    Q8.exports = kJ()(Pz);
    var { formatters: rK } = Q8.exports;
    rK.j = function ($) {
        try {
            return JSON.stringify($);
        } catch (X) {
            return '[UnexpectedJSONParseError]: ' + X.message;
        }
    };
});
var Lz = H0((zd, jz) => {
    jz.exports = ($, X = process.argv) => {
        let W = $.startsWith('-') ? '' : $.length === 1 ? '-' : '--',
            Q = X.indexOf(W + $),
            Y = X.indexOf('--');
        return Q !== -1 && (Y === -1 || Q < Y);
    };
});
var Fz = H0((Zd, _z) => {
    var Y_ = n0('os'),
        Kz = n0('tty'),
        R4 = Lz(),
        { env: A6 } = process,
        Q0;
    if (
        R4('no-color') ||
        R4('no-colors') ||
        R4('color=false') ||
        R4('color=never')
    )
        Q0 = 0;
    else if (
        R4('color') ||
        R4('colors') ||
        R4('color=true') ||
        R4('color=always')
    )
        Q0 = 1;
    if ('FORCE_COLOR' in A6)
        if (A6.FORCE_COLOR === 'true') Q0 = 1;
        else if (A6.FORCE_COLOR === 'false') Q0 = 0;
        else
            Q0 =
                A6.FORCE_COLOR.length === 0
                    ? 1
                    : Math.min(parseInt(A6.FORCE_COLOR, 10), 3);
    function vJ($) {
        if ($ === 0) return !1;
        return { level: $, hasBasic: !0, has256: $ >= 2, has16m: $ >= 3 };
    }
    function fJ($, X) {
        if (Q0 === 0) return 0;
        if (R4('color=16m') || R4('color=full') || R4('color=truecolor'))
            return 3;
        if (R4('color=256')) return 2;
        if ($ && !X && Q0 === void 0) return 0;
        let W = Q0 || 0;
        if (A6.TERM === 'dumb') return W;
        if (process.platform === 'win32') {
            let Q = Y_.release().split('.');
            if (Number(Q[0]) >= 10 && Number(Q[2]) >= 10586)
                return Number(Q[2]) >= 14931 ? 3 : 2;
            return 1;
        }
        if ('CI' in A6) {
            if (
                [
                    'TRAVIS',
                    'CIRCLECI',
                    'APPVEYOR',
                    'GITLAB_CI',
                    'GITHUB_ACTIONS',
                    'BUILDKITE',
                ].some((Q) => Q in A6) ||
                A6.CI_NAME === 'codeship'
            )
                return 1;
            return W;
        }
        if ('TEAMCITY_VERSION' in A6)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(A6.TEAMCITY_VERSION)
                ? 1
                : 0;
        if (A6.COLORTERM === 'truecolor') return 3;
        if ('TERM_PROGRAM' in A6) {
            let Q = parseInt((A6.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
            switch (A6.TERM_PROGRAM) {
                case 'iTerm.app':
                    return Q >= 3 ? 3 : 2;
                case 'Apple_Terminal':
                    return 2;
            }
        }
        if (/-256(color)?$/i.test(A6.TERM)) return 2;
        if (
            /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
                A6.TERM,
            )
        )
            return 1;
        if ('COLORTERM' in A6) return 1;
        return W;
    }
    function Q_($) {
        let X = fJ($, $ && $.isTTY);
        return vJ(X);
    }
    _z.exports = {
        supportsColor: Q_,
        stdout: vJ(fJ(!0, Kz.isatty(1))),
        stderr: vJ(fJ(!0, Kz.isatty(2))),
    };
});
var Vz = H0((Cz, U8) => {
    var J_ = n0('tty'),
        J8 = n0('util');
    Cz.init = w_;
    Cz.log = G_;
    Cz.formatArgs = N_;
    Cz.save = z_;
    Cz.load = Z_;
    Cz.useColors = U_;
    Cz.destroy = J8.deprecate(
        () => {},
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
    );
    Cz.colors = [6, 2, 3, 4, 5, 1];
    try {
        let $ = Fz();
        if ($ && ($.stderr || $).level >= 2)
            Cz.colors = [
                20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
                62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
                112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
                165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
                196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
                209, 214, 215, 220, 221,
            ];
    } catch ($) {}
    Cz.inspectOpts = Object.keys(process.env)
        .filter(($) => {
            return /^debug_/i.test($);
        })
        .reduce(($, X) => {
            let W = X.substring(6)
                    .toLowerCase()
                    .replace(/_([a-z])/g, (Y, J) => {
                        return J.toUpperCase();
                    }),
                Q = process.env[X];
            if (/^(yes|on|true|enabled)$/i.test(Q)) Q = !0;
            else if (/^(no|off|false|disabled)$/i.test(Q)) Q = !1;
            else if (Q === 'null') Q = null;
            else Q = Number(Q);
            return ($[W] = Q), $;
        }, {});
    function U_() {
        return 'colors' in Cz.inspectOpts
            ? Boolean(Cz.inspectOpts.colors)
            : J_.isatty(process.stderr.fd);
    }
    function N_($) {
        let { namespace: X, useColors: W } = this;
        if (W) {
            let Q = this.color,
                Y = '\x1B[3' + (Q < 8 ? Q : '8;5;' + Q),
                J = `  ${Y};1m${X} \x1B[0m`;
            ($[0] =
                J +
                $[0]
                    .split(`
`)
                    .join(
                        `
` + J,
                    )),
                $.push(Y + 'm+' + U8.exports.humanize(this.diff) + '\x1B[0m');
        } else $[0] = M_() + X + ' ' + $[0];
    }
    function M_() {
        if (Cz.inspectOpts.hideDate) return '';
        return new Date().toISOString() + ' ';
    }
    function G_(...$) {
        return process.stderr.write(
            J8.formatWithOptions(Cz.inspectOpts, ...$) +
                `
`,
        );
    }
    function z_($) {
        if ($) process.env.DEBUG = $;
        else delete process.env.DEBUG;
    }
    function Z_() {
        return process.env.DEBUG;
    }
    function w_($) {
        $.inspectOpts = {};
        let X = Object.keys(Cz.inspectOpts);
        for (let W = 0; W < X.length; W++)
            $.inspectOpts[X[W]] = Cz.inspectOpts[X[W]];
    }
    U8.exports = kJ()(Cz);
    var { formatters: Iz } = U8.exports;
    Iz.o = function ($) {
        return (
            (this.inspectOpts.colors = this.useColors),
            J8.inspect($, this.inspectOpts)
                .split(`
`)
                .map((X) => X.trim())
                .join(' ')
        );
    };
    Iz.O = function ($) {
        return (
            (this.inspectOpts.colors = this.useColors),
            J8.inspect($, this.inspectOpts)
        );
    };
});
var Ez = H0((Dd, yJ) => {
    if (
        typeof process === 'undefined' ||
        process.type === 'renderer' ||
        !1 ||
        process.__nwjs
    )
        yJ.exports = Sz();
    else yJ.exports = Vz();
});
var g0, hJ, xz, bz, gz;
var Tz = h$(() => {
    ZW();
    (g0 = {
        LocalFileHeader: 67324752,
        DataDescriptor: 134695760,
        CentralFileHeader: 33639248,
        EndOfCentralDirectory: 101010256,
    }),
        (hJ = {
            get($) {
                let X = l$.get($, 6);
                return {
                    signature: J6.get($, 0),
                    compressedSize: J6.get($, 8),
                    uncompressedSize: J6.get($, 12),
                };
            },
            len: 16,
        }),
        (xz = {
            get($) {
                let X = l$.get($, 6);
                return {
                    signature: J6.get($, 0),
                    minVersion: l$.get($, 4),
                    dataDescriptor: !!(X & 8),
                    compressedMethod: l$.get($, 8),
                    compressedSize: J6.get($, 18),
                    uncompressedSize: J6.get($, 22),
                    filenameLength: l$.get($, 26),
                    extraFieldLength: l$.get($, 28),
                    filename: null,
                };
            },
            len: 30,
        }),
        (bz = {
            get($) {
                return {
                    signature: J6.get($, 0),
                    nrOfThisDisk: l$.get($, 4),
                    nrOfThisDiskWithTheStart: l$.get($, 6),
                    nrOfEntriesOnThisDisk: l$.get($, 8),
                    nrOfEntriesOfSize: l$.get($, 10),
                    sizeOfCd: J6.get($, 12),
                    offsetOfStartOfCd: J6.get($, 16),
                    zipFileCommentLength: l$.get($, 20),
                };
            },
            len: 22,
        }),
        (gz = {
            get($) {
                let X = l$.get($, 8);
                return {
                    signature: J6.get($, 0),
                    minVersion: l$.get($, 6),
                    dataDescriptor: !!(X & 8),
                    compressedMethod: l$.get($, 10),
                    compressedSize: J6.get($, 20),
                    uncompressedSize: J6.get($, 24),
                    filenameLength: l$.get($, 28),
                    extraFieldLength: l$.get($, 30),
                    fileCommentLength: l$.get($, 32),
                    relativeOffsetOfLocalHeader: J6.get($, 42),
                    filename: null,
                };
            },
            len: 46,
        });
});
function vz($) {
    let X = new Uint8Array(J6.len);
    return J6.put(X, 0, $), X;
}
class cJ {
    constructor($) {
        (this.tokenizer = $), (this.syncBuffer = new Uint8Array(mJ));
    }
    async isZip() {
        return (await this.peekSignature()) === g0.LocalFileHeader;
    }
    peekSignature() {
        return this.tokenizer.peekToken(J6);
    }
    async findEndOfCentralDirectoryLocator() {
        let $ = this.tokenizer,
            X = Math.min(16384, $.fileInfo.size),
            W = this.syncBuffer.subarray(0, X);
        await this.tokenizer.readBuffer(W, { position: $.fileInfo.size - X });
        for (let Q = W.length - 4; Q >= 0; Q--)
            if (
                W[Q] === N8[0] &&
                W[Q + 1] === N8[1] &&
                W[Q + 2] === N8[2] &&
                W[Q + 3] === N8[3]
            )
                return $.fileInfo.size - X + Q;
        return -1;
    }
    async readCentralDirectory() {
        if (!this.tokenizer.supportsRandomAccess()) {
            U1('Cannot reading central-directory without random-read support');
            return;
        }
        U1('Reading central-directory...');
        let $ = this.tokenizer.position,
            X = await this.findEndOfCentralDirectoryLocator();
        if (X > 0) {
            U1('Central-directory 32-bit signature found');
            let W = await this.tokenizer.readToken(bz, X),
                Q = [];
            this.tokenizer.setPosition(W.offsetOfStartOfCd);
            for (let Y = 0; Y < W.nrOfEntriesOfSize; ++Y) {
                let J = await this.tokenizer.readToken(gz);
                if (J.signature !== g0.CentralFileHeader)
                    throw new Error('Expected Central-File-Header signature');
                (J.filename = await this.tokenizer.readToken(
                    new b6(J.filenameLength, 'utf-8'),
                )),
                    await this.tokenizer.ignore(J.extraFieldLength),
                    await this.tokenizer.ignore(J.fileCommentLength),
                    Q.push(J),
                    U1(
                        `Add central-directory file-entry: n=${Y + 1}/${Q.length}: filename=${Q[Y].filename}`,
                    );
            }
            return this.tokenizer.setPosition($), Q;
        }
        this.tokenizer.setPosition($);
    }
    async unzip($) {
        let X = await this.readCentralDirectory();
        if (X) return this.iterateOverCentralDirectory(X, $);
        let W = !1;
        do {
            let Q = await this.readLocalFileHeader();
            if (!Q) break;
            let Y = $(Q);
            W = !!Y.stop;
            let J = void 0;
            if (
                (await this.tokenizer.ignore(Q.extraFieldLength),
                Q.dataDescriptor && Q.compressedSize === 0)
            ) {
                let U = [],
                    N = mJ;
                U1(
                    'Compressed-file-size unknown, scanning for next data-descriptor-signature....',
                );
                let M = -1;
                while (M < 0 && N === mJ) {
                    (N = await this.tokenizer.peekBuffer(this.syncBuffer, {
                        mayBeLess: !0,
                    })),
                        (M = j_(this.syncBuffer.subarray(0, N), S_));
                    let G = M >= 0 ? M : N;
                    if (Y.handler) {
                        let Z = new Uint8Array(G);
                        await this.tokenizer.readBuffer(Z), U.push(Z);
                    } else await this.tokenizer.ignore(G);
                }
                if (
                    (U1(
                        `Found data-descriptor-signature at pos=${this.tokenizer.position}`,
                    ),
                    Y.handler)
                )
                    await this.inflate(Q, L_(U), Y.handler);
            } else if (Y.handler)
                U1(`Reading compressed-file-data: ${Q.compressedSize} bytes`),
                    (J = new Uint8Array(Q.compressedSize)),
                    await this.tokenizer.readBuffer(J),
                    await this.inflate(Q, J, Y.handler);
            else
                U1(`Ignoring compressed-file-data: ${Q.compressedSize} bytes`),
                    await this.tokenizer.ignore(Q.compressedSize);
            if (
                (U1(
                    `Reading data-descriptor at pos=${this.tokenizer.position}`,
                ),
                Q.dataDescriptor)
            ) {
                if (
                    (await this.tokenizer.readToken(hJ)).signature !== 134695760
                )
                    throw new Error(
                        `Expected data-descriptor-signature at position ${this.tokenizer.position - hJ.len}`,
                    );
            }
        } while (!W);
    }
    async iterateOverCentralDirectory($, X) {
        for (let W of $) {
            let Q = X(W);
            if (Q.handler) {
                this.tokenizer.setPosition(W.relativeOffsetOfLocalHeader);
                let Y = await this.readLocalFileHeader();
                if (Y) {
                    await this.tokenizer.ignore(Y.extraFieldLength);
                    let J = new Uint8Array(W.compressedSize);
                    await this.tokenizer.readBuffer(J),
                        await this.inflate(Y, J, Q.handler);
                }
            }
            if (Q.stop) break;
        }
    }
    inflate($, X, W) {
        if ($.compressedMethod === 0) return W(X);
        U1(`Decompress filename=${$.filename}, compressed-size=${X.length}`);
        let Q = Bz(X);
        return W(Q);
    }
    async readLocalFileHeader() {
        let $ = await this.tokenizer.peekToken(J6);
        if ($ === g0.LocalFileHeader) {
            let X = await this.tokenizer.readToken(xz);
            return (
                (X.filename = await this.tokenizer.readToken(
                    new b6(X.filenameLength, 'utf-8'),
                )),
                X
            );
        }
        if ($ === g0.CentralFileHeader) return !1;
        if ($ === 3759263696) throw new Error('Encrypted ZIP');
        throw new Error('Unexpected signature');
    }
}
function j_($, X) {
    let W = $.length,
        Q = X.length;
    if (Q > W) return -1;
    for (let Y = 0; Y <= W - Q; Y++) {
        let J = !0;
        for (let U = 0; U < Q; U++)
            if ($[Y + U] !== X[U]) {
                J = !1;
                break;
            }
        if (J) return Y;
    }
    return -1;
}
function L_($) {
    let X = $.reduce((Y, J) => Y + J.length, 0),
        W = new Uint8Array(X),
        Q = 0;
    for (let Y of $) W.set(Y, Q), (Q += Y.length);
    return W;
}
var kz,
    U1,
    mJ = 262144,
    S_,
    N8;
var fz = h$(() => {
    ZW();
    Oz();
    kz = kQ(Ez(), 1);
    Tz();
    (U1 = kz.default('tokenizer:inflate')),
        (S_ = vz(g0.DataDescriptor)),
        (N8 = vz(g0.EndOfCentralDirectory));
});
function uJ($) {
    let { byteLength: X } = $;
    if (X === 6) return $.getUint16(0) * 4294967296 + $.getUint32(2);
    if (X === 5) return $.getUint8(0) * 4294967296 + $.getUint32(1);
    if (X === 4) return $.getUint32(0);
    if (X === 3) return $.getUint8(0) * 65536 + $.getUint16(1);
    if (X === 2) return $.getUint16(0);
    if (X === 1) return $.getUint8(0);
}
var Sd, jd, Ld;
var yz = h$(() => {
    (Sd = { utf8: new globalThis.TextDecoder('utf8') }),
        (jd = new globalThis.TextEncoder()),
        (Ld = Array.from({ length: 256 }, ($, X) =>
            X.toString(16).padStart(2, '0'),
        ));
});
function hz($) {
    return [...$].map((X) => X.charCodeAt(0));
}
function mz($, X = 0) {
    let W = Number.parseInt(
        new b6(6).get($, 148).replace(/\0.*$/, '').trim(),
        8,
    );
    if (Number.isNaN(W)) return !1;
    let Q = 256;
    for (let Y = X; Y < X + 148; Y++) Q += $[Y];
    for (let Y = X + 156; Y < X + 512; Y++) Q += $[Y];
    return W === Q;
}
var cz;
var uz = h$(() => {
    ZW();
    cz = {
        get: ($, X) =>
            ($[X + 3] & 127) |
            ($[X + 2] << 7) |
            ($[X + 1] << 14) |
            ($[X] << 21),
        len: 4,
    };
});
var dz, iz;
var nz = h$(() => {
    (dz = [
        'jpg',
        'png',
        'apng',
        'gif',
        'webp',
        'flif',
        'xcf',
        'cr2',
        'cr3',
        'orf',
        'arw',
        'dng',
        'nef',
        'rw2',
        'raf',
        'tif',
        'bmp',
        'icns',
        'jxr',
        'psd',
        'indd',
        'zip',
        'tar',
        'rar',
        'gz',
        'bz2',
        '7z',
        'dmg',
        'mp4',
        'mid',
        'mkv',
        'webm',
        'mov',
        'avi',
        'mpg',
        'mp2',
        'mp3',
        'm4a',
        'oga',
        'ogg',
        'ogv',
        'opus',
        'flac',
        'wav',
        'spx',
        'amr',
        'pdf',
        'epub',
        'elf',
        'macho',
        'exe',
        'swf',
        'rtf',
        'wasm',
        'woff',
        'woff2',
        'eot',
        'ttf',
        'otf',
        'ttc',
        'ico',
        'flv',
        'ps',
        'xz',
        'sqlite',
        'nes',
        'crx',
        'xpi',
        'cab',
        'deb',
        'ar',
        'rpm',
        'Z',
        'lz',
        'cfb',
        'mxf',
        'mts',
        'blend',
        'bpg',
        'docx',
        'pptx',
        'xlsx',
        '3gp',
        '3g2',
        'j2c',
        'jp2',
        'jpm',
        'jpx',
        'mj2',
        'aif',
        'qcp',
        'odt',
        'ods',
        'odp',
        'xml',
        'mobi',
        'heic',
        'cur',
        'ktx',
        'ape',
        'wv',
        'dcm',
        'ics',
        'glb',
        'pcap',
        'dsf',
        'lnk',
        'alias',
        'voc',
        'ac3',
        'm4v',
        'm4p',
        'm4b',
        'f4v',
        'f4p',
        'f4b',
        'f4a',
        'mie',
        'asf',
        'ogm',
        'ogx',
        'mpc',
        'arrow',
        'shp',
        'aac',
        'mp1',
        'it',
        's3m',
        'xm',
        'skp',
        'avif',
        'eps',
        'lzh',
        'pgp',
        'asar',
        'stl',
        'chm',
        '3mf',
        'zst',
        'jxl',
        'vcf',
        'jls',
        'pst',
        'dwg',
        'parquet',
        'class',
        'arj',
        'cpio',
        'ace',
        'avro',
        'icc',
        'fbx',
        'vsdx',
        'vtt',
        'apk',
        'drc',
        'lz4',
        'potx',
        'xltx',
        'dotx',
        'xltm',
        'ott',
        'ots',
        'otp',
        'odg',
        'otg',
        'xlsm',
        'docm',
        'dotm',
        'potm',
        'pptm',
        'jar',
        'rm',
        'ppsm',
        'ppsx',
    ]),
        (iz = [
            'image/jpeg',
            'image/png',
            'image/gif',
            'image/webp',
            'image/flif',
            'image/x-xcf',
            'image/x-canon-cr2',
            'image/x-canon-cr3',
            'image/tiff',
            'image/bmp',
            'image/vnd.ms-photo',
            'image/vnd.adobe.photoshop',
            'application/x-indesign',
            'application/epub+zip',
            'application/x-xpinstall',
            'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
            'application/vnd.oasis.opendocument.text',
            'application/vnd.oasis.opendocument.spreadsheet',
            'application/vnd.oasis.opendocument.presentation',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
            'application/zip',
            'application/x-tar',
            'application/x-rar-compressed',
            'application/gzip',
            'application/x-bzip2',
            'application/x-7z-compressed',
            'application/x-apple-diskimage',
            'application/vnd.apache.arrow.file',
            'video/mp4',
            'audio/midi',
            'video/matroska',
            'video/webm',
            'video/quicktime',
            'video/vnd.avi',
            'audio/wav',
            'audio/qcelp',
            'audio/x-ms-asf',
            'video/x-ms-asf',
            'application/vnd.ms-asf',
            'video/mpeg',
            'video/3gpp',
            'audio/mpeg',
            'audio/mp4',
            'video/ogg',
            'audio/ogg',
            'audio/ogg; codecs=opus',
            'application/ogg',
            'audio/flac',
            'audio/ape',
            'audio/wavpack',
            'audio/amr',
            'application/pdf',
            'application/x-elf',
            'application/x-mach-binary',
            'application/x-msdownload',
            'application/x-shockwave-flash',
            'application/rtf',
            'application/wasm',
            'font/woff',
            'font/woff2',
            'application/vnd.ms-fontobject',
            'font/ttf',
            'font/otf',
            'font/collection',
            'image/x-icon',
            'video/x-flv',
            'application/postscript',
            'application/eps',
            'application/x-xz',
            'application/x-sqlite3',
            'application/x-nintendo-nes-rom',
            'application/x-google-chrome-extension',
            'application/vnd.ms-cab-compressed',
            'application/x-deb',
            'application/x-unix-archive',
            'application/x-rpm',
            'application/x-compress',
            'application/x-lzip',
            'application/x-cfb',
            'application/x-mie',
            'application/mxf',
            'video/mp2t',
            'application/x-blender',
            'image/bpg',
            'image/j2c',
            'image/jp2',
            'image/jpx',
            'image/jpm',
            'image/mj2',
            'audio/aiff',
            'application/xml',
            'application/x-mobipocket-ebook',
            'image/heif',
            'image/heif-sequence',
            'image/heic',
            'image/heic-sequence',
            'image/icns',
            'image/ktx',
            'application/dicom',
            'audio/x-musepack',
            'text/calendar',
            'text/vcard',
            'text/vtt',
            'model/gltf-binary',
            'application/vnd.tcpdump.pcap',
            'audio/x-dsf',
            'application/x.ms.shortcut',
            'application/x.apple.alias',
            'audio/x-voc',
            'audio/vnd.dolby.dd-raw',
            'audio/x-m4a',
            'image/apng',
            'image/x-olympus-orf',
            'image/x-sony-arw',
            'image/x-adobe-dng',
            'image/x-nikon-nef',
            'image/x-panasonic-rw2',
            'image/x-fujifilm-raf',
            'video/x-m4v',
            'video/3gpp2',
            'application/x-esri-shape',
            'audio/aac',
            'audio/x-it',
            'audio/x-s3m',
            'audio/x-xm',
            'video/MP1S',
            'video/MP2P',
            'application/vnd.sketchup.skp',
            'image/avif',
            'application/x-lzh-compressed',
            'application/pgp-encrypted',
            'application/x-asar',
            'model/stl',
            'application/vnd.ms-htmlhelp',
            'model/3mf',
            'image/jxl',
            'application/zstd',
            'image/jls',
            'application/vnd.ms-outlook',
            'image/vnd.dwg',
            'application/vnd.apache.parquet',
            'application/java-vm',
            'application/x-arj',
            'application/x-cpio',
            'application/x-ace-compressed',
            'application/avro',
            'application/vnd.iccprofile',
            'application/x.autodesk.fbx',
            'application/vnd.visio',
            'application/vnd.android.package-archive',
            'application/vnd.google.draco',
            'application/x-lz4',
            'application/vnd.openxmlformats-officedocument.presentationml.template',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
            'application/vnd.ms-excel.template.macroenabled.12',
            'application/vnd.oasis.opendocument.text-template',
            'application/vnd.oasis.opendocument.spreadsheet-template',
            'application/vnd.oasis.opendocument.presentation-template',
            'application/vnd.oasis.opendocument.graphics',
            'application/vnd.oasis.opendocument.graphics-template',
            'application/vnd.ms-excel.sheet.macroenabled.12',
            'application/vnd.ms-word.document.macroenabled.12',
            'application/vnd.ms-word.template.macroenabled.12',
            'application/vnd.ms-powerpoint.template.macroenabled.12',
            'application/vnd.ms-powerpoint.presentation.macroenabled.12',
            'application/java-archive',
            'application/vnd.rn-realmedia',
        ]);
});
async function pz($, X) {
    return new KX(X).fromBuffer($);
}
async function lz($, X) {
    return new KX(X).fromBlob($);
}
function dJ($) {
    switch ((($ = $.toLowerCase()), $)) {
        case 'application/epub+zip':
            return { ext: 'epub', mime: $ };
        case 'application/vnd.oasis.opendocument.text':
            return { ext: 'odt', mime: $ };
        case 'application/vnd.oasis.opendocument.text-template':
            return { ext: 'ott', mime: $ };
        case 'application/vnd.oasis.opendocument.spreadsheet':
            return { ext: 'ods', mime: $ };
        case 'application/vnd.oasis.opendocument.spreadsheet-template':
            return { ext: 'ots', mime: $ };
        case 'application/vnd.oasis.opendocument.presentation':
            return { ext: 'odp', mime: $ };
        case 'application/vnd.oasis.opendocument.presentation-template':
            return { ext: 'otp', mime: $ };
        case 'application/vnd.oasis.opendocument.graphics':
            return { ext: 'odg', mime: $ };
        case 'application/vnd.oasis.opendocument.graphics-template':
            return { ext: 'otg', mime: $ };
        case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
            return { ext: 'ppsx', mime: $ };
        case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
            return { ext: 'xlsx', mime: $ };
        case 'application/vnd.ms-excel.sheet.macroenabled':
            return {
                ext: 'xlsm',
                mime: 'application/vnd.ms-excel.sheet.macroenabled.12',
            };
        case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
            return { ext: 'xltx', mime: $ };
        case 'application/vnd.ms-excel.template.macroenabled':
            return {
                ext: 'xltm',
                mime: 'application/vnd.ms-excel.template.macroenabled.12',
            };
        case 'application/vnd.ms-powerpoint.slideshow.macroenabled':
            return {
                ext: 'ppsm',
                mime: 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
            };
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
            return { ext: 'docx', mime: $ };
        case 'application/vnd.ms-word.document.macroenabled':
            return {
                ext: 'docm',
                mime: 'application/vnd.ms-word.document.macroenabled.12',
            };
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
            return { ext: 'dotx', mime: $ };
        case 'application/vnd.ms-word.template.macroenabledtemplate':
            return {
                ext: 'dotm',
                mime: 'application/vnd.ms-word.template.macroenabled.12',
            };
        case 'application/vnd.openxmlformats-officedocument.presentationml.template':
            return { ext: 'potx', mime: $ };
        case 'application/vnd.ms-powerpoint.template.macroenabled':
            return {
                ext: 'potm',
                mime: 'application/vnd.ms-powerpoint.template.macroenabled.12',
            };
        case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
            return { ext: 'pptx', mime: $ };
        case 'application/vnd.ms-powerpoint.presentation.macroenabled':
            return {
                ext: 'pptm',
                mime: 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
            };
        case 'application/vnd.ms-visio.drawing':
            return { ext: 'vsdx', mime: 'application/vnd.visio' };
        case 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml':
            return { ext: '3mf', mime: 'model/3mf' };
        default:
    }
}
function N1($, X, W) {
    W = { offset: 0, ...W };
    for (let [Q, Y] of X.entries())
        if (W.mask) {
            if (Y !== (W.mask[Q] & $[Q + W.offset])) return !1;
        } else if (Y !== $[Q + W.offset]) return !1;
    return !0;
}
async function oz($, X) {
    return new KX(X).fromTokenizer($);
}
class KX {
    constructor($) {
        (this.options = { mpegOffsetTolerance: 0, ...$ }),
            (this.detectors = [
                ...($?.customDetectors ?? []),
                { id: 'core', detect: this.detectConfident },
                { id: 'core.imprecise', detect: this.detectImprecise },
            ]),
            (this.tokenizerOptions = { abortSignal: $?.signal });
    }
    async fromTokenizer($) {
        let X = $.position;
        for (let W of this.detectors) {
            let Q = await W.detect($);
            if (Q) return Q;
            if (X !== $.position) return;
        }
    }
    async fromBuffer($) {
        if (!($ instanceof Uint8Array || $ instanceof ArrayBuffer))
            throw new TypeError(
                `Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof $}\``,
            );
        let X = $ instanceof Uint8Array ? $ : new Uint8Array($);
        if (!(X?.length > 1)) return;
        return this.fromTokenizer(sG(X, this.tokenizerOptions));
    }
    async fromBlob($) {
        return this.fromStream($.stream());
    }
    async fromStream($) {
        let X = await X8($, this.tokenizerOptions);
        try {
            return await this.fromTokenizer(X);
        } finally {
            await X.close();
        }
    }
    async toDetectionStream($, X) {
        let { sampleSize: W = OW } = X,
            Q,
            Y,
            J = $.getReader({ mode: 'byob' });
        try {
            let { value: M, done: G } = await J.read(new Uint8Array(W));
            if (((Y = M), !G && M))
                try {
                    Q = await this.fromBuffer(M.subarray(0, W));
                } catch (Z) {
                    if (!(Z instanceof g$)) throw Z;
                    Q = void 0;
                }
            Y = M;
        } finally {
            J.releaseLock();
        }
        let U = new TransformStream({
                async start(M) {
                    M.enqueue(Y);
                },
                transform(M, G) {
                    G.enqueue(M);
                },
            }),
            N = $.pipeThrough(U);
        return (N.fileType = Q), N;
    }
    check($, X) {
        return N1(this.buffer, $, X);
    }
    checkString($, X) {
        return this.check(hz($), X);
    }
    detectConfident = async ($) => {
        if (((this.buffer = new Uint8Array(OW)), $.fileInfo.size === void 0))
            $.fileInfo.size = Number.MAX_SAFE_INTEGER;
        if (
            ((this.tokenizer = $),
            await $.peekBuffer(this.buffer, { length: 12, mayBeLess: !0 }),
            this.check([66, 77]))
        )
            return { ext: 'bmp', mime: 'image/bmp' };
        if (this.check([11, 119]))
            return { ext: 'ac3', mime: 'audio/vnd.dolby.dd-raw' };
        if (this.check([120, 1]))
            return { ext: 'dmg', mime: 'application/x-apple-diskimage' };
        if (this.check([77, 90]))
            return { ext: 'exe', mime: 'application/x-msdownload' };
        if (this.check([37, 33])) {
            if (
                (await $.peekBuffer(this.buffer, { length: 24, mayBeLess: !0 }),
                this.checkString('PS-Adobe-', { offset: 2 }) &&
                    this.checkString(' EPSF-', { offset: 14 }))
            )
                return { ext: 'eps', mime: 'application/eps' };
            return { ext: 'ps', mime: 'application/postscript' };
        }
        if (this.check([31, 160]) || this.check([31, 157]))
            return { ext: 'Z', mime: 'application/x-compress' };
        if (this.check([199, 113]))
            return { ext: 'cpio', mime: 'application/x-cpio' };
        if (this.check([96, 234]))
            return { ext: 'arj', mime: 'application/x-arj' };
        if (this.check([239, 187, 191]))
            return this.tokenizer.ignore(3), this.detectConfident($);
        if (this.check([71, 73, 70])) return { ext: 'gif', mime: 'image/gif' };
        if (this.check([73, 73, 188]))
            return { ext: 'jxr', mime: 'image/vnd.ms-photo' };
        if (this.check([31, 139, 8]))
            return { ext: 'gz', mime: 'application/gzip' };
        if (this.check([66, 90, 104]))
            return { ext: 'bz2', mime: 'application/x-bzip2' };
        if (this.checkString('ID3')) {
            await $.ignore(6);
            let X = await $.readToken(cz);
            if ($.position + X > $.fileInfo.size)
                return { ext: 'mp3', mime: 'audio/mpeg' };
            return await $.ignore(X), this.fromTokenizer($);
        }
        if (this.checkString('MP+'))
            return { ext: 'mpc', mime: 'audio/x-musepack' };
        if (
            (this.buffer[0] === 67 || this.buffer[0] === 70) &&
            this.check([87, 83], { offset: 1 })
        )
            return { ext: 'swf', mime: 'application/x-shockwave-flash' };
        if (this.check([255, 216, 255])) {
            if (this.check([247], { offset: 3 }))
                return { ext: 'jls', mime: 'image/jls' };
            return { ext: 'jpg', mime: 'image/jpeg' };
        }
        if (this.check([79, 98, 106, 1]))
            return { ext: 'avro', mime: 'application/avro' };
        if (this.checkString('FLIF'))
            return { ext: 'flif', mime: 'image/flif' };
        if (this.checkString('8BPS'))
            return { ext: 'psd', mime: 'image/vnd.adobe.photoshop' };
        if (this.checkString('MPCK'))
            return { ext: 'mpc', mime: 'audio/x-musepack' };
        if (this.checkString('FORM')) return { ext: 'aif', mime: 'audio/aiff' };
        if (this.checkString('icns', { offset: 0 }))
            return { ext: 'icns', mime: 'image/icns' };
        if (this.check([80, 75, 3, 4])) {
            let X;
            return (
                await new cJ($).unzip((W) => {
                    switch (W.filename) {
                        case 'META-INF/mozilla.rsa':
                            return (
                                (X = {
                                    ext: 'xpi',
                                    mime: 'application/x-xpinstall',
                                }),
                                { stop: !0 }
                            );
                        case 'META-INF/MANIFEST.MF':
                            return (
                                (X = {
                                    ext: 'jar',
                                    mime: 'application/java-archive',
                                }),
                                { stop: !0 }
                            );
                        case 'mimetype':
                            return {
                                async handler(Q) {
                                    let Y = new TextDecoder('utf-8')
                                        .decode(Q)
                                        .trim();
                                    X = dJ(Y);
                                },
                                stop: !0,
                            };
                        case '[Content_Types].xml':
                            return {
                                async handler(Q) {
                                    let Y = new TextDecoder('utf-8').decode(Q),
                                        J = Y.indexOf('.main+xml"');
                                    if (J === -1) {
                                        if (
                                            Y.includes(
                                                'ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"',
                                            )
                                        )
                                            X = dJ(
                                                'application/vnd.ms-package.3dmanufacturing-3dmodel+xml',
                                            );
                                    } else {
                                        Y = Y.slice(0, Math.max(0, J));
                                        let U = Y.lastIndexOf('"'),
                                            N = Y.slice(Math.max(0, U + 1));
                                        X = dJ(N);
                                    }
                                },
                                stop: !0,
                            };
                        default:
                            if (/classes\d*\.dex/.test(W.filename))
                                return (
                                    (X = {
                                        ext: 'apk',
                                        mime: 'application/vnd.android.package-archive',
                                    }),
                                    { stop: !0 }
                                );
                            return {};
                    }
                }),
                X ?? { ext: 'zip', mime: 'application/zip' }
            );
        }
        if (this.checkString('OggS')) {
            await $.ignore(28);
            let X = new Uint8Array(8);
            if (
                (await $.readBuffer(X),
                N1(X, [79, 112, 117, 115, 72, 101, 97, 100]))
            )
                return { ext: 'opus', mime: 'audio/ogg; codecs=opus' };
            if (N1(X, [128, 116, 104, 101, 111, 114, 97]))
                return { ext: 'ogv', mime: 'video/ogg' };
            if (N1(X, [1, 118, 105, 100, 101, 111, 0]))
                return { ext: 'ogm', mime: 'video/ogg' };
            if (N1(X, [127, 70, 76, 65, 67]))
                return { ext: 'oga', mime: 'audio/ogg' };
            if (N1(X, [83, 112, 101, 101, 120, 32, 32]))
                return { ext: 'spx', mime: 'audio/ogg' };
            if (N1(X, [1, 118, 111, 114, 98, 105, 115]))
                return { ext: 'ogg', mime: 'audio/ogg' };
            return { ext: 'ogx', mime: 'application/ogg' };
        }
        if (
            this.check([80, 75]) &&
            (this.buffer[2] === 3 ||
                this.buffer[2] === 5 ||
                this.buffer[2] === 7) &&
            (this.buffer[3] === 4 ||
                this.buffer[3] === 6 ||
                this.buffer[3] === 8)
        )
            return { ext: 'zip', mime: 'application/zip' };
        if (this.checkString('MThd')) return { ext: 'mid', mime: 'audio/midi' };
        if (
            this.checkString('wOFF') &&
            (this.check([0, 1, 0, 0], { offset: 4 }) ||
                this.checkString('OTTO', { offset: 4 }))
        )
            return { ext: 'woff', mime: 'font/woff' };
        if (
            this.checkString('wOF2') &&
            (this.check([0, 1, 0, 0], { offset: 4 }) ||
                this.checkString('OTTO', { offset: 4 }))
        )
            return { ext: 'woff2', mime: 'font/woff2' };
        if (
            this.check([212, 195, 178, 161]) ||
            this.check([161, 178, 195, 212])
        )
            return { ext: 'pcap', mime: 'application/vnd.tcpdump.pcap' };
        if (this.checkString('DSD '))
            return { ext: 'dsf', mime: 'audio/x-dsf' };
        if (this.checkString('LZIP'))
            return { ext: 'lz', mime: 'application/x-lzip' };
        if (this.checkString('fLaC'))
            return { ext: 'flac', mime: 'audio/flac' };
        if (this.check([66, 80, 71, 251]))
            return { ext: 'bpg', mime: 'image/bpg' };
        if (this.checkString('wvpk'))
            return { ext: 'wv', mime: 'audio/wavpack' };
        if (this.checkString('%PDF'))
            return { ext: 'pdf', mime: 'application/pdf' };
        if (this.check([0, 97, 115, 109]))
            return { ext: 'wasm', mime: 'application/wasm' };
        if (this.check([73, 73])) {
            let X = await this.readTiffHeader(!1);
            if (X) return X;
        }
        if (this.check([77, 77])) {
            let X = await this.readTiffHeader(!0);
            if (X) return X;
        }
        if (this.checkString('MAC ')) return { ext: 'ape', mime: 'audio/ape' };
        if (this.check([26, 69, 223, 163])) {
            async function X() {
                let U = await $.peekNumber(Yz),
                    N = 128,
                    M = 0;
                while ((U & N) === 0 && N !== 0) ++M, (N >>= 1);
                let G = new Uint8Array(M + 1);
                return await $.readBuffer(G), G;
            }
            async function W() {
                let U = await X(),
                    N = await X();
                N[0] ^= 128 >> (N.length - 1);
                let M = Math.min(6, N.length),
                    G = new DataView(U.buffer),
                    Z = new DataView(N.buffer, N.length - M, M);
                return { id: uJ(G), len: uJ(Z) };
            }
            async function Q(U) {
                while (U > 0) {
                    let N = await W();
                    if (N.id === 17026)
                        return (await $.readToken(new b6(N.len))).replaceAll(
                            /\00.*$/g,
                            '',
                        );
                    await $.ignore(N.len), --U;
                }
            }
            let Y = await W();
            switch (await Q(Y.len)) {
                case 'webm':
                    return { ext: 'webm', mime: 'video/webm' };
                case 'matroska':
                    return { ext: 'mkv', mime: 'video/matroska' };
                default:
                    return;
            }
        }
        if (this.checkString('SQLi'))
            return { ext: 'sqlite', mime: 'application/x-sqlite3' };
        if (this.check([78, 69, 83, 26]))
            return { ext: 'nes', mime: 'application/x-nintendo-nes-rom' };
        if (this.checkString('Cr24'))
            return {
                ext: 'crx',
                mime: 'application/x-google-chrome-extension',
            };
        if (this.checkString('MSCF') || this.checkString('ISc('))
            return { ext: 'cab', mime: 'application/vnd.ms-cab-compressed' };
        if (this.check([237, 171, 238, 219]))
            return { ext: 'rpm', mime: 'application/x-rpm' };
        if (this.check([197, 208, 211, 198]))
            return { ext: 'eps', mime: 'application/eps' };
        if (this.check([40, 181, 47, 253]))
            return { ext: 'zst', mime: 'application/zstd' };
        if (this.check([127, 69, 76, 70]))
            return { ext: 'elf', mime: 'application/x-elf' };
        if (this.check([33, 66, 68, 78]))
            return { ext: 'pst', mime: 'application/vnd.ms-outlook' };
        if (this.checkString('PAR1') || this.checkString('PARE'))
            return { ext: 'parquet', mime: 'application/vnd.apache.parquet' };
        if (this.checkString('ttcf'))
            return { ext: 'ttc', mime: 'font/collection' };
        if (this.check([207, 250, 237, 254]))
            return { ext: 'macho', mime: 'application/x-mach-binary' };
        if (this.check([4, 34, 77, 24]))
            return { ext: 'lz4', mime: 'application/x-lz4' };
        if (this.check([79, 84, 84, 79, 0]))
            return { ext: 'otf', mime: 'font/otf' };
        if (this.checkString('#!AMR')) return { ext: 'amr', mime: 'audio/amr' };
        if (this.checkString('{\\rtf'))
            return { ext: 'rtf', mime: 'application/rtf' };
        if (this.check([70, 76, 86, 1]))
            return { ext: 'flv', mime: 'video/x-flv' };
        if (this.checkString('IMPM')) return { ext: 'it', mime: 'audio/x-it' };
        if (
            this.checkString('-lh0-', { offset: 2 }) ||
            this.checkString('-lh1-', { offset: 2 }) ||
            this.checkString('-lh2-', { offset: 2 }) ||
            this.checkString('-lh3-', { offset: 2 }) ||
            this.checkString('-lh4-', { offset: 2 }) ||
            this.checkString('-lh5-', { offset: 2 }) ||
            this.checkString('-lh6-', { offset: 2 }) ||
            this.checkString('-lh7-', { offset: 2 }) ||
            this.checkString('-lzs-', { offset: 2 }) ||
            this.checkString('-lz4-', { offset: 2 }) ||
            this.checkString('-lz5-', { offset: 2 }) ||
            this.checkString('-lhd-', { offset: 2 })
        )
            return { ext: 'lzh', mime: 'application/x-lzh-compressed' };
        if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] }))
                return { ext: 'mpg', mime: 'video/MP1S' };
            if (this.check([68], { offset: 4, mask: [196] }))
                return { ext: 'mpg', mime: 'video/MP2P' };
        }
        if (this.checkString('ITSF'))
            return { ext: 'chm', mime: 'application/vnd.ms-htmlhelp' };
        if (this.check([202, 254, 186, 190]))
            return { ext: 'class', mime: 'application/java-vm' };
        if (this.checkString('.RMF'))
            return { ext: 'rm', mime: 'application/vnd.rn-realmedia' };
        if (this.checkString('DRACO'))
            return { ext: 'drc', mime: 'application/vnd.google.draco' };
        if (this.check([253, 55, 122, 88, 90, 0]))
            return { ext: 'xz', mime: 'application/x-xz' };
        if (this.checkString('<?xml '))
            return { ext: 'xml', mime: 'application/xml' };
        if (this.check([55, 122, 188, 175, 39, 28]))
            return { ext: '7z', mime: 'application/x-7z-compressed' };
        if (
            this.check([82, 97, 114, 33, 26, 7]) &&
            (this.buffer[6] === 0 || this.buffer[6] === 1)
        )
            return { ext: 'rar', mime: 'application/x-rar-compressed' };
        if (this.checkString('solid '))
            return { ext: 'stl', mime: 'model/stl' };
        if (this.checkString('AC')) {
            let X = new b6(4, 'latin1').get(this.buffer, 2);
            if (X.match('^d*') && X >= 1000 && X <= 1050)
                return { ext: 'dwg', mime: 'image/vnd.dwg' };
        }
        if (this.checkString('070707'))
            return { ext: 'cpio', mime: 'application/x-cpio' };
        if (this.checkString('BLENDER'))
            return { ext: 'blend', mime: 'application/x-blender' };
        if (this.checkString('!<arch>')) {
            if (
                (await $.ignore(8),
                (await $.readToken(new b6(13, 'ascii'))) === 'debian-binary')
            )
                return { ext: 'deb', mime: 'application/x-deb' };
            return { ext: 'ar', mime: 'application/x-unix-archive' };
        }
        if (
            this.checkString('WEBVTT') &&
            [
                `
`,
                '\r',
                '\t',
                ' ',
                '\x00',
            ].some((X) => this.checkString(X, { offset: 6 }))
        )
            return { ext: 'vtt', mime: 'text/vtt' };
        if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            await $.ignore(8);
            async function X() {
                return {
                    length: await $.readToken(Jz),
                    type: await $.readToken(new b6(4, 'latin1')),
                };
            }
            do {
                let W = await X();
                if (W.length < 0) return;
                switch (W.type) {
                    case 'IDAT':
                        return { ext: 'png', mime: 'image/png' };
                    case 'acTL':
                        return { ext: 'apng', mime: 'image/apng' };
                    default:
                        await $.ignore(W.length + 4);
                }
            } while ($.position + 8 < $.fileInfo.size);
            return { ext: 'png', mime: 'image/png' };
        }
        if (this.check([65, 82, 82, 79, 87, 49, 0, 0]))
            return { ext: 'arrow', mime: 'application/vnd.apache.arrow.file' };
        if (this.check([103, 108, 84, 70, 2, 0, 0, 0]))
            return { ext: 'glb', mime: 'model/gltf-binary' };
        if (
            this.check([102, 114, 101, 101], { offset: 4 }) ||
            this.check([109, 100, 97, 116], { offset: 4 }) ||
            this.check([109, 111, 111, 118], { offset: 4 }) ||
            this.check([119, 105, 100, 101], { offset: 4 })
        )
            return { ext: 'mov', mime: 'video/quicktime' };
        if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24]))
            return { ext: 'orf', mime: 'image/x-olympus-orf' };
        if (this.checkString('gimp xcf '))
            return { ext: 'xcf', mime: 'image/x-xcf' };
        if (
            this.checkString('ftyp', { offset: 4 }) &&
            (this.buffer[8] & 96) !== 0
        ) {
            let X = new b6(4, 'latin1')
                .get(this.buffer, 8)
                .replace('\x00', ' ')
                .trim();
            switch (X) {
                case 'avif':
                case 'avis':
                    return { ext: 'avif', mime: 'image/avif' };
                case 'mif1':
                    return { ext: 'heic', mime: 'image/heif' };
                case 'msf1':
                    return { ext: 'heic', mime: 'image/heif-sequence' };
                case 'heic':
                case 'heix':
                    return { ext: 'heic', mime: 'image/heic' };
                case 'hevc':
                case 'hevx':
                    return { ext: 'heic', mime: 'image/heic-sequence' };
                case 'qt':
                    return { ext: 'mov', mime: 'video/quicktime' };
                case 'M4V':
                case 'M4VH':
                case 'M4VP':
                    return { ext: 'm4v', mime: 'video/x-m4v' };
                case 'M4P':
                    return { ext: 'm4p', mime: 'video/mp4' };
                case 'M4B':
                    return { ext: 'm4b', mime: 'audio/mp4' };
                case 'M4A':
                    return { ext: 'm4a', mime: 'audio/x-m4a' };
                case 'F4V':
                    return { ext: 'f4v', mime: 'video/mp4' };
                case 'F4P':
                    return { ext: 'f4p', mime: 'video/mp4' };
                case 'F4A':
                    return { ext: 'f4a', mime: 'audio/mp4' };
                case 'F4B':
                    return { ext: 'f4b', mime: 'audio/mp4' };
                case 'crx':
                    return { ext: 'cr3', mime: 'image/x-canon-cr3' };
                default:
                    if (X.startsWith('3g')) {
                        if (X.startsWith('3g2'))
                            return { ext: '3g2', mime: 'video/3gpp2' };
                        return { ext: '3gp', mime: 'video/3gpp' };
                    }
                    return { ext: 'mp4', mime: 'video/mp4' };
            }
        }
        if (this.check([82, 73, 70, 70])) {
            if (this.checkString('WEBP', { offset: 8 }))
                return { ext: 'webp', mime: 'image/webp' };
            if (this.check([65, 86, 73], { offset: 8 }))
                return { ext: 'avi', mime: 'video/vnd.avi' };
            if (this.check([87, 65, 86, 69], { offset: 8 }))
                return { ext: 'wav', mime: 'audio/wav' };
            if (this.check([81, 76, 67, 77], { offset: 8 }))
                return { ext: 'qcp', mime: 'audio/qcelp' };
        }
        if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
            return { ext: 'rw2', mime: 'image/x-panasonic-rw2' };
        if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function X() {
                let W = new Uint8Array(16);
                return (
                    await $.readBuffer(W),
                    { id: W, size: Number(await $.readToken(Uz)) }
                );
            }
            await $.ignore(30);
            while ($.position + 24 < $.fileInfo.size) {
                let W = await X(),
                    Q = W.size - 24;
                if (
                    N1(
                        W.id,
                        [
                            145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0,
                            192, 12, 32, 83, 101,
                        ],
                    )
                ) {
                    let Y = new Uint8Array(16);
                    if (
                        ((Q -= await $.readBuffer(Y)),
                        N1(
                            Y,
                            [
                                64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0,
                                128, 95, 92, 68, 43,
                            ],
                        ))
                    )
                        return { ext: 'asf', mime: 'audio/x-ms-asf' };
                    if (
                        N1(
                            Y,
                            [
                                192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0,
                                128, 95, 92, 68, 43,
                            ],
                        )
                    )
                        return { ext: 'asf', mime: 'video/x-ms-asf' };
                    break;
                }
                await $.ignore(Q);
            }
            return { ext: 'asf', mime: 'application/vnd.ms-asf' };
        }
        if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
            return { ext: 'ktx', mime: 'image/ktx' };
        if (
            (this.check([126, 16, 4]) || this.check([126, 24, 4])) &&
            this.check([48, 77, 73, 69], { offset: 4 })
        )
            return { ext: 'mie', mime: 'application/x-mie' };
        if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
            return { ext: 'shp', mime: 'application/x-esri-shape' };
        if (this.check([255, 79, 255, 81]))
            return { ext: 'j2c', mime: 'image/j2c' };
        if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
            switch (
                (await $.ignore(20), await $.readToken(new b6(4, 'ascii')))
            ) {
                case 'jp2 ':
                    return { ext: 'jp2', mime: 'image/jp2' };
                case 'jpx ':
                    return { ext: 'jpx', mime: 'image/jpx' };
                case 'jpm ':
                    return { ext: 'jpm', mime: 'image/jpm' };
                case 'mjp2':
                    return { ext: 'mj2', mime: 'image/mj2' };
                default:
                    return;
            }
        if (
            this.check([255, 10]) ||
            this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])
        )
            return { ext: 'jxl', mime: 'image/jxl' };
        if (this.check([254, 255])) {
            if (
                this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], {
                    offset: 2,
                })
            )
                return { ext: 'xml', mime: 'application/xml' };
            return;
        }
        if (this.check([208, 207, 17, 224, 161, 177, 26, 225]))
            return { ext: 'cfb', mime: 'application/x-cfb' };
        if (
            (await $.peekBuffer(this.buffer, {
                length: Math.min(256, $.fileInfo.size),
                mayBeLess: !0,
            }),
            this.check([97, 99, 115, 112], { offset: 36 }))
        )
            return { ext: 'icc', mime: 'application/vnd.iccprofile' };
        if (
            this.checkString('**ACE', { offset: 7 }) &&
            this.checkString('**', { offset: 12 })
        )
            return { ext: 'ace', mime: 'application/x-ace-compressed' };
        if (this.checkString('BEGIN:')) {
            if (this.checkString('VCARD', { offset: 6 }))
                return { ext: 'vcf', mime: 'text/vcard' };
            if (this.checkString('VCALENDAR', { offset: 6 }))
                return { ext: 'ics', mime: 'text/calendar' };
        }
        if (this.checkString('FUJIFILMCCD-RAW'))
            return { ext: 'raf', mime: 'image/x-fujifilm-raf' };
        if (this.checkString('Extended Module:'))
            return { ext: 'xm', mime: 'audio/x-xm' };
        if (this.checkString('Creative Voice File'))
            return { ext: 'voc', mime: 'audio/x-voc' };
        if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            let X = new DataView(this.buffer.buffer).getUint32(12, !0);
            if (X > 12 && this.buffer.length >= X + 16)
                try {
                    let W = new TextDecoder().decode(
                        this.buffer.subarray(16, X + 16),
                    );
                    if (JSON.parse(W).files)
                        return { ext: 'asar', mime: 'application/x-asar' };
                } catch {}
        }
        if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
            return { ext: 'mxf', mime: 'application/mxf' };
        if (this.checkString('SCRM', { offset: 44 }))
            return { ext: 's3m', mime: 'audio/x-s3m' };
        if (this.check([71]) && this.check([71], { offset: 188 }))
            return { ext: 'mts', mime: 'video/mp2t' };
        if (
            this.check([71], { offset: 4 }) &&
            this.check([71], { offset: 196 })
        )
            return { ext: 'mts', mime: 'video/mp2t' };
        if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
            return { ext: 'mobi', mime: 'application/x-mobipocket-ebook' };
        if (this.check([68, 73, 67, 77], { offset: 128 }))
            return { ext: 'dcm', mime: 'application/dicom' };
        if (
            this.check([
                76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70,
            ])
        )
            return { ext: 'lnk', mime: 'application/x.ms.shortcut' };
        if (
            this.check([
                98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0,
            ])
        )
            return { ext: 'alias', mime: 'application/x.apple.alias' };
        if (this.checkString('Kaydara FBX Binary  \x00'))
            return { ext: 'fbx', mime: 'application/x.autodesk.fbx' };
        if (
            this.check([76, 80], { offset: 34 }) &&
            (this.check([0, 0, 1], { offset: 8 }) ||
                this.check([1, 0, 2], { offset: 8 }) ||
                this.check([2, 0, 2], { offset: 8 }))
        )
            return { ext: 'eot', mime: 'application/vnd.ms-fontobject' };
        if (
            this.check([
                6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116,
                183, 29,
            ])
        )
            return { ext: 'indd', mime: 'application/x-indesign' };
        if (
            (await $.peekBuffer(this.buffer, {
                length: Math.min(512, $.fileInfo.size),
                mayBeLess: !0,
            }),
            (this.checkString('ustar', { offset: 257 }) &&
                (this.checkString('\x00', { offset: 262 }) ||
                    this.checkString(' ', { offset: 262 }))) ||
                (this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) &&
                    mz(this.buffer)))
        )
            return { ext: 'tar', mime: 'application/x-tar' };
        if (this.check([255, 254])) {
            if (
                this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], {
                    offset: 2,
                })
            )
                return { ext: 'xml', mime: 'application/xml' };
            if (
                this.check(
                    [
                        255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0,
                        85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0,
                        108, 0,
                    ],
                    { offset: 2 },
                )
            )
                return { ext: 'skp', mime: 'application/vnd.sketchup.skp' };
            return;
        }
        if (this.checkString('-----BEGIN PGP MESSAGE-----'))
            return { ext: 'pgp', mime: 'application/pgp-encrypted' };
    };
    detectImprecise = async ($) => {
        if (
            ((this.buffer = new Uint8Array(OW)),
            await $.peekBuffer(this.buffer, {
                length: Math.min(8, $.fileInfo.size),
                mayBeLess: !0,
            }),
            this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179]))
        )
            return { ext: 'mpg', mime: 'video/mpeg' };
        if (this.check([0, 1, 0, 0, 0]))
            return { ext: 'ttf', mime: 'font/ttf' };
        if (this.check([0, 0, 1, 0]))
            return { ext: 'ico', mime: 'image/x-icon' };
        if (this.check([0, 0, 2, 0]))
            return { ext: 'cur', mime: 'image/x-icon' };
        if (
            (await $.peekBuffer(this.buffer, {
                length: Math.min(
                    2 + this.options.mpegOffsetTolerance,
                    $.fileInfo.size,
                ),
                mayBeLess: !0,
            }),
            this.buffer.length >= 2 + this.options.mpegOffsetTolerance)
        )
            for (let X = 0; X <= this.options.mpegOffsetTolerance; ++X) {
                let W = this.scanMpeg(X);
                if (W) return W;
            }
    };
    async readTiffTag($) {
        let X = await this.tokenizer.readToken($ ? AX : l$);
        switch ((this.tokenizer.ignore(10), X)) {
            case 50341:
                return { ext: 'arw', mime: 'image/x-sony-arw' };
            case 50706:
                return { ext: 'dng', mime: 'image/x-adobe-dng' };
            default:
        }
    }
    async readTiffIFD($) {
        let X = await this.tokenizer.readToken($ ? AX : l$);
        for (let W = 0; W < X; ++W) {
            let Q = await this.readTiffTag($);
            if (Q) return Q;
        }
    }
    async readTiffHeader($) {
        let X = ($ ? AX : l$).get(this.buffer, 2),
            W = ($ ? Qz : J6).get(this.buffer, 4);
        if (X === 42) {
            if (W >= 6) {
                if (this.checkString('CR', { offset: 8 }))
                    return { ext: 'cr2', mime: 'image/x-canon-cr2' };
                if (W >= 8) {
                    let Y = ($ ? AX : l$).get(this.buffer, 8),
                        J = ($ ? AX : l$).get(this.buffer, 10);
                    if ((Y === 28 && J === 254) || (Y === 31 && J === 11))
                        return { ext: 'nef', mime: 'image/x-nikon-nef' };
                }
            }
            return (
                await this.tokenizer.ignore(W),
                (await this.readTiffIFD($)) ?? {
                    ext: 'tif',
                    mime: 'image/tiff',
                }
            );
        }
        if (X === 43) return { ext: 'tif', mime: 'image/tiff' };
    }
    scanMpeg($) {
        if (this.check([255, 224], { offset: $, mask: [255, 224] })) {
            if (this.check([16], { offset: $ + 1, mask: [22] })) {
                if (this.check([8], { offset: $ + 1, mask: [8] }))
                    return { ext: 'aac', mime: 'audio/aac' };
                return { ext: 'aac', mime: 'audio/aac' };
            }
            if (this.check([2], { offset: $ + 1, mask: [6] }))
                return { ext: 'mp3', mime: 'audio/mpeg' };
            if (this.check([4], { offset: $ + 1, mask: [6] }))
                return { ext: 'mp2', mime: 'audio/mpeg' };
            if (this.check([6], { offset: $ + 1, mask: [6] }))
                return { ext: 'mp1', mime: 'audio/mpeg' };
        }
    }
}
var OW = 4100,
    rz,
    tz;
var iJ = h$(() => {
    ZW();
    W8();
    fz();
    yz();
    uz();
    nz();
    (rz = new Set(dz)), (tz = new Set(iz));
});
var sz = {};
k6(sz, {
    supportedMimeTypes: () => tz,
    supportedExtensions: () => rz,
    fileTypeStream: () => R_,
    fileTypeFromTokenizer: () => oz,
    fileTypeFromStream: () => C_,
    fileTypeFromFile: () => I_,
    fileTypeFromBuffer: () => pz,
    fileTypeFromBlob: () => lz,
    FileTypeParser: () => HW,
});
import { ReadableStream as K_ } from 'stream/web';
import { pipeline as az, PassThrough as __, Readable as F_ } from 'stream';
async function I_($, X) {
    return new HW(X).fromFile($, X);
}
async function C_($, X) {
    return new HW(X).fromStream($);
}
async function R_($, X = {}) {
    return new HW(X).toDetectionStream($, X);
}
var HW;
var ez = h$(() => {
    Xz();
    iJ();
    iJ();
    HW = class HW extends KX {
        async fromStream($) {
            let X = await ($ instanceof K_
                ? X8($, this.tokenizerOptions)
                : eG($, this.tokenizerOptions));
            try {
                return await super.fromTokenizer(X);
            } finally {
                await X.close();
            }
        }
        async fromFile($) {
            let X = await $z($);
            try {
                return await super.fromTokenizer(X);
            } finally {
                await X.close();
            }
        }
        async toDetectionStream($, X = {}) {
            if (!($ instanceof F_)) return super.toDetectionStream($, X);
            let { sampleSize: W = OW } = X;
            return new Promise((Q, Y) => {
                $.on('error', Y),
                    $.once('readable', () => {
                        (async () => {
                            try {
                                let J = new __(),
                                    U = az ? az($, J, () => {}) : $.pipe(J),
                                    N =
                                        $.read(W) ??
                                        $.read() ??
                                        new Uint8Array(0);
                                try {
                                    J.fileType = await this.fromBuffer(N);
                                } catch (M) {
                                    if (M instanceof g$) J.fileType = void 0;
                                    else Y(M);
                                }
                                Q(U);
                            } catch (J) {
                                Y(J);
                            }
                        })();
                    });
            });
        }
    };
});
var C6 = {};
k6(C6, {
    IsUndefined: () => W6,
    IsUint8Array: () => O1,
    IsSymbol: () => mQ,
    IsString: () => x$,
    IsRegExp: () => uX,
    IsObject: () => F$,
    IsNumber: () => Q4,
    IsNull: () => hQ,
    IsIterator: () => yQ,
    IsFunction: () => fQ,
    IsDate: () => q0,
    IsBoolean: () => B1,
    IsBigInt: () => cX,
    IsAsyncIterator: () => vQ,
    IsArray: () => X6,
    HasPropertyKey: () => wY,
});
function wY($, X) {
    return X in $;
}
function vQ($) {
    return F$($) && !X6($) && !O1($) && Symbol.asyncIterator in $;
}
function X6($) {
    return Array.isArray($);
}
function cX($) {
    return typeof $ === 'bigint';
}
function B1($) {
    return typeof $ === 'boolean';
}
function q0($) {
    return $ instanceof globalThis.Date;
}
function fQ($) {
    return typeof $ === 'function';
}
function yQ($) {
    return F$($) && !X6($) && !O1($) && Symbol.iterator in $;
}
function hQ($) {
    return $ === null;
}
function Q4($) {
    return typeof $ === 'number';
}
function F$($) {
    return typeof $ === 'object' && $ !== null;
}
function uX($) {
    return $ instanceof globalThis.RegExp;
}
function x$($) {
    return typeof $ === 'string';
}
function mQ($) {
    return typeof $ === 'symbol';
}
function O1($) {
    return $ instanceof globalThis.Uint8Array;
}
function W6($) {
    return $ === void 0;
}
function VD($) {
    return $.map((X) => DY(X));
}
function ED($) {
    return new Date($.getTime());
}
function xD($) {
    return new Uint8Array($);
}
function bD($) {
    return new RegExp($.source, $.flags);
}
function gD($) {
    let X = {};
    for (let W of Object.getOwnPropertyNames($)) X[W] = DY($[W]);
    for (let W of Object.getOwnPropertySymbols($)) X[W] = DY($[W]);
    return X;
}
function DY($) {
    return X6($)
        ? VD($)
        : q0($)
          ? ED($)
          : O1($)
            ? xD($)
            : uX($)
              ? bD($)
              : F$($)
                ? gD($)
                : $;
}
function m$($) {
    return DY($);
}
function p0($, X) {
    return X === void 0 ? m$($) : m$({ ...X, ...$ });
}
function BY($) {
    return X$($) && globalThis.Symbol.asyncIterator in $;
}
function OY($) {
    return X$($) && globalThis.Symbol.iterator in $;
}
function cQ($) {
    return (
        X$($) &&
        (globalThis.Object.getPrototypeOf($) === Object.prototype ||
            globalThis.Object.getPrototypeOf($) === null)
    );
}
function HY($) {
    return $ instanceof globalThis.Promise;
}
function v6($) {
    return $ instanceof Date && globalThis.Number.isFinite($.getTime());
}
function d9($) {
    return $ instanceof globalThis.Map;
}
function i9($) {
    return $ instanceof globalThis.Set;
}
function P4($) {
    return globalThis.ArrayBuffer.isView($);
}
function l0($) {
    return $ instanceof globalThis.Uint8Array;
}
function t($, X) {
    return X in $;
}
function X$($) {
    return $ !== null && typeof $ === 'object';
}
function a($) {
    return globalThis.Array.isArray($) && !globalThis.ArrayBuffer.isView($);
}
function c$($) {
    return $ === void 0;
}
function H1($) {
    return $ === null;
}
function $1($) {
    return typeof $ === 'boolean';
}
function l($) {
    return typeof $ === 'number';
}
function qY($) {
    return globalThis.Number.isInteger($);
}
function K6($) {
    return typeof $ === 'bigint';
}
function w$($) {
    return typeof $ === 'string';
}
function p1($) {
    return typeof $ === 'function';
}
function q1($) {
    return typeof $ === 'symbol';
}
function J4($) {
    return K6($) || $1($) || H1($) || l($) || w$($) || q1($) || c$($);
}
var k$;
(function ($) {
    ($.InstanceMode = 'default'),
        ($.ExactOptionalPropertyTypes = !1),
        ($.AllowArrayObject = !1),
        ($.AllowNaN = !1),
        ($.AllowNullVoid = !1);
    function X(U, N) {
        return $.ExactOptionalPropertyTypes ? N in U : U[N] !== void 0;
    }
    $.IsExactOptionalProperty = X;
    function W(U) {
        let N = X$(U);
        return $.AllowArrayObject ? N : N && !a(U);
    }
    $.IsObjectLike = W;
    function Q(U) {
        return W(U) && !(U instanceof Date) && !(U instanceof Uint8Array);
    }
    $.IsRecordLike = Q;
    function Y(U) {
        return $.AllowNaN ? l(U) : Number.isFinite(U);
    }
    $.IsNumberLike = Y;
    function J(U) {
        let N = c$(U);
        return $.AllowNullVoid ? N || U === null : N;
    }
    $.IsVoidLike = J;
})(k$ || (k$ = {}));
function TD($) {
    return globalThis.Object.freeze($).map((X) => dX(X));
}
function kD($) {
    return $;
}
function vD($) {
    return $;
}
function fD($) {
    return $;
}
function yD($) {
    let X = {};
    for (let W of Object.getOwnPropertyNames($)) X[W] = dX($[W]);
    for (let W of Object.getOwnPropertySymbols($)) X[W] = dX($[W]);
    return globalThis.Object.freeze(X);
}
function dX($) {
    return X6($)
        ? TD($)
        : q0($)
          ? kD($)
          : O1($)
            ? vD($)
            : uX($)
              ? fD($)
              : F$($)
                ? yD($)
                : $;
}
function F($, X) {
    let W = X !== void 0 ? { ...X, ...$ } : $;
    switch (k$.InstanceMode) {
        case 'freeze':
            return dX(W);
        case 'clone':
            return m$(W);
        default:
            return W;
    }
}
class r extends Error {
    constructor($) {
        super($);
    }
}
var R$ = Symbol.for('TypeBox.Transform'),
    g4 = Symbol.for('TypeBox.Readonly'),
    Y6 = Symbol.for('TypeBox.Optional'),
    S4 = Symbol.for('TypeBox.Hint'),
    S = Symbol.for('TypeBox.Kind');
function o0($) {
    return F$($) && $[g4] === 'Readonly';
}
function u6($) {
    return F$($) && $[Y6] === 'Optional';
}
function uQ($) {
    return z$($, 'Any');
}
function dQ($) {
    return z$($, 'Argument');
}
function T4($) {
    return z$($, 'Array');
}
function A0($) {
    return z$($, 'AsyncIterator');
}
function P0($) {
    return z$($, 'BigInt');
}
function A1($) {
    return z$($, 'Boolean');
}
function k4($) {
    return z$($, 'Computed');
}
function v4($) {
    return z$($, 'Constructor');
}
function hD($) {
    return z$($, 'Date');
}
function f4($) {
    return z$($, 'Function');
}
function y4($) {
    return z$($, 'Integer');
}
function o$($) {
    return z$($, 'Intersect');
}
function S0($) {
    return z$($, 'Iterator');
}
function z$($, X) {
    return F$($) && S in $ && $[S] === X;
}
function AY($) {
    return B1($) || Q4($) || x$($);
}
function U4($) {
    return z$($, 'Literal');
}
function N4($) {
    return z$($, 'MappedKey');
}
function u$($) {
    return z$($, 'MappedResult');
}
function l1($) {
    return z$($, 'Never');
}
function mD($) {
    return z$($, 'Not');
}
function iX($) {
    return z$($, 'Null');
}
function h4($) {
    return z$($, 'Number');
}
function Q6($) {
    return z$($, 'Object');
}
function j0($) {
    return z$($, 'Promise');
}
function L0($) {
    return z$($, 'Record');
}
function e$($) {
    return z$($, 'Ref');
}
function iQ($) {
    return z$($, 'RegExp');
}
function P1($) {
    return z$($, 'String');
}
function nX($) {
    return z$($, 'Symbol');
}
function M4($) {
    return z$($, 'TemplateLiteral');
}
function cD($) {
    return z$($, 'This');
}
function P$($) {
    return F$($) && R$ in $;
}
function G4($) {
    return z$($, 'Tuple');
}
function S1($) {
    return z$($, 'Undefined');
}
function D$($) {
    return z$($, 'Union');
}
function uD($) {
    return z$($, 'Uint8Array');
}
function dD($) {
    return z$($, 'Unknown');
}
function iD($) {
    return z$($, 'Unsafe');
}
function nD($) {
    return z$($, 'Void');
}
function o1($) {
    return F$($) && S in $ && x$($[S]);
}
function n$($) {
    return (
        uQ($) ||
        dQ($) ||
        T4($) ||
        A1($) ||
        P0($) ||
        A0($) ||
        k4($) ||
        v4($) ||
        hD($) ||
        f4($) ||
        y4($) ||
        o$($) ||
        S0($) ||
        U4($) ||
        N4($) ||
        u$($) ||
        l1($) ||
        mD($) ||
        iX($) ||
        h4($) ||
        Q6($) ||
        j0($) ||
        L0($) ||
        e$($) ||
        iQ($) ||
        P1($) ||
        nX($) ||
        M4($) ||
        cD($) ||
        G4($) ||
        S1($) ||
        D$($) ||
        uD($) ||
        dD($) ||
        iD($) ||
        nD($) ||
        o1($)
    );
}
var A = {};
k6(A, {
    TypeGuardUnknownTypeError: () => n9,
    IsVoid: () => bM,
    IsUnsafe: () => xM,
    IsUnknown: () => EM,
    IsUnionLiteral: () => $B,
    IsUnion: () => lQ,
    IsUndefined: () => RM,
    IsUint8Array: () => VM,
    IsTuple: () => CM,
    IsTransform: () => IM,
    IsThis: () => FM,
    IsTemplateLiteral: () => _M,
    IsSymbol: () => KM,
    IsString: () => LM,
    IsSchema: () => d$,
    IsRegExp: () => jM,
    IsRef: () => SM,
    IsRecursive: () => eD,
    IsRecord: () => PM,
    IsReadonly: () => rD,
    IsProperties: () => PY,
    IsPromise: () => AM,
    IsOptional: () => tD,
    IsObject: () => qM,
    IsNumber: () => HM,
    IsNull: () => OM,
    IsNot: () => BM,
    IsNever: () => DM,
    IsMappedResult: () => wM,
    IsMappedKey: () => ZM,
    IsLiteralValue: () => zM,
    IsLiteralString: () => MM,
    IsLiteralNumber: () => GM,
    IsLiteralBoolean: () => sD,
    IsLiteral: () => lX,
    IsKindOf: () => U$,
    IsKind: () => gM,
    IsIterator: () => NM,
    IsIntersect: () => UM,
    IsInteger: () => JM,
    IsImport: () => aD,
    IsFunction: () => QM,
    IsDate: () => YM,
    IsConstructor: () => WM,
    IsComputed: () => XM,
    IsBoolean: () => $M,
    IsBigInt: () => e9,
    IsAsyncIterator: () => s9,
    IsArray: () => a9,
    IsArgument: () => t9,
    IsAny: () => r9,
});
class n9 extends r {}
var pD = [
    'Argument',
    'Any',
    'Array',
    'AsyncIterator',
    'BigInt',
    'Boolean',
    'Computed',
    'Constructor',
    'Date',
    'Enum',
    'Function',
    'Integer',
    'Intersect',
    'Iterator',
    'Literal',
    'MappedKey',
    'MappedResult',
    'Not',
    'Null',
    'Number',
    'Object',
    'Promise',
    'Record',
    'Ref',
    'RegExp',
    'String',
    'Symbol',
    'TemplateLiteral',
    'This',
    'Tuple',
    'Undefined',
    'Union',
    'Uint8Array',
    'Unknown',
    'Void',
];
function p9($) {
    try {
        return new RegExp($), !0;
    } catch {
        return !1;
    }
}
function nQ($) {
    if (!x$($)) return !1;
    for (let X = 0; X < $.length; X++) {
        let W = $.charCodeAt(X);
        if ((W >= 7 && W <= 13) || W === 27 || W === 127) return !1;
    }
    return !0;
}
function l9($) {
    return pQ($) || d$($);
}
function pX($) {
    return W6($) || cX($);
}
function b$($) {
    return W6($) || Q4($);
}
function pQ($) {
    return W6($) || B1($);
}
function I$($) {
    return W6($) || x$($);
}
function lD($) {
    return W6($) || (x$($) && nQ($) && p9($));
}
function oD($) {
    return W6($) || (x$($) && nQ($));
}
function o9($) {
    return W6($) || d$($);
}
function rD($) {
    return F$($) && $[g4] === 'Readonly';
}
function tD($) {
    return F$($) && $[Y6] === 'Optional';
}
function r9($) {
    return U$($, 'Any') && I$($.$id);
}
function t9($) {
    return U$($, 'Argument') && Q4($.index);
}
function a9($) {
    return (
        U$($, 'Array') &&
        $.type === 'array' &&
        I$($.$id) &&
        d$($.items) &&
        b$($.minItems) &&
        b$($.maxItems) &&
        pQ($.uniqueItems) &&
        o9($.contains) &&
        b$($.minContains) &&
        b$($.maxContains)
    );
}
function s9($) {
    return (
        U$($, 'AsyncIterator') &&
        $.type === 'AsyncIterator' &&
        I$($.$id) &&
        d$($.items)
    );
}
function e9($) {
    return (
        U$($, 'BigInt') &&
        $.type === 'bigint' &&
        I$($.$id) &&
        pX($.exclusiveMaximum) &&
        pX($.exclusiveMinimum) &&
        pX($.maximum) &&
        pX($.minimum) &&
        pX($.multipleOf)
    );
}
function $M($) {
    return U$($, 'Boolean') && $.type === 'boolean' && I$($.$id);
}
function XM($) {
    return (
        U$($, 'Computed') &&
        x$($.target) &&
        X6($.parameters) &&
        $.parameters.every((X) => d$(X))
    );
}
function WM($) {
    return (
        U$($, 'Constructor') &&
        $.type === 'Constructor' &&
        I$($.$id) &&
        X6($.parameters) &&
        $.parameters.every((X) => d$(X)) &&
        d$($.returns)
    );
}
function YM($) {
    return (
        U$($, 'Date') &&
        $.type === 'Date' &&
        I$($.$id) &&
        b$($.exclusiveMaximumTimestamp) &&
        b$($.exclusiveMinimumTimestamp) &&
        b$($.maximumTimestamp) &&
        b$($.minimumTimestamp) &&
        b$($.multipleOfTimestamp)
    );
}
function QM($) {
    return (
        U$($, 'Function') &&
        $.type === 'Function' &&
        I$($.$id) &&
        X6($.parameters) &&
        $.parameters.every((X) => d$(X)) &&
        d$($.returns)
    );
}
function aD($) {
    return (
        U$($, 'Import') &&
        wY($, '$defs') &&
        F$($.$defs) &&
        PY($.$defs) &&
        wY($, '$ref') &&
        x$($.$ref) &&
        $.$ref in $.$defs
    );
}
function JM($) {
    return (
        U$($, 'Integer') &&
        $.type === 'integer' &&
        I$($.$id) &&
        b$($.exclusiveMaximum) &&
        b$($.exclusiveMinimum) &&
        b$($.maximum) &&
        b$($.minimum) &&
        b$($.multipleOf)
    );
}
function PY($) {
    return F$($) && Object.entries($).every(([X, W]) => nQ(X) && d$(W));
}
function UM($) {
    return (
        U$($, 'Intersect') &&
        (x$($.type) && $.type !== 'object' ? !1 : !0) &&
        X6($.allOf) &&
        $.allOf.every((X) => d$(X) && !IM(X)) &&
        I$($.type) &&
        (pQ($.unevaluatedProperties) || o9($.unevaluatedProperties)) &&
        I$($.$id)
    );
}
function NM($) {
    return (
        U$($, 'Iterator') && $.type === 'Iterator' && I$($.$id) && d$($.items)
    );
}
function U$($, X) {
    return F$($) && S in $ && $[S] === X;
}
function MM($) {
    return lX($) && x$($.const);
}
function GM($) {
    return lX($) && Q4($.const);
}
function sD($) {
    return lX($) && B1($.const);
}
function lX($) {
    return U$($, 'Literal') && I$($.$id) && zM($.const);
}
function zM($) {
    return B1($) || Q4($) || x$($);
}
function ZM($) {
    return (
        U$($, 'MappedKey') && X6($.keys) && $.keys.every((X) => Q4(X) || x$(X))
    );
}
function wM($) {
    return U$($, 'MappedResult') && PY($.properties);
}
function DM($) {
    return (
        U$($, 'Never') &&
        F$($.not) &&
        Object.getOwnPropertyNames($.not).length === 0
    );
}
function BM($) {
    return U$($, 'Not') && d$($.not);
}
function OM($) {
    return U$($, 'Null') && $.type === 'null' && I$($.$id);
}
function HM($) {
    return (
        U$($, 'Number') &&
        $.type === 'number' &&
        I$($.$id) &&
        b$($.exclusiveMaximum) &&
        b$($.exclusiveMinimum) &&
        b$($.maximum) &&
        b$($.minimum) &&
        b$($.multipleOf)
    );
}
function qM($) {
    return (
        U$($, 'Object') &&
        $.type === 'object' &&
        I$($.$id) &&
        PY($.properties) &&
        l9($.additionalProperties) &&
        b$($.minProperties) &&
        b$($.maxProperties)
    );
}
function AM($) {
    return U$($, 'Promise') && $.type === 'Promise' && I$($.$id) && d$($.item);
}
function PM($) {
    return (
        U$($, 'Record') &&
        $.type === 'object' &&
        I$($.$id) &&
        l9($.additionalProperties) &&
        F$($.patternProperties) &&
        ((X) => {
            let W = Object.getOwnPropertyNames(X.patternProperties);
            return (
                W.length === 1 &&
                p9(W[0]) &&
                F$(X.patternProperties) &&
                d$(X.patternProperties[W[0]])
            );
        })($)
    );
}
function eD($) {
    return F$($) && S4 in $ && $[S4] === 'Recursive';
}
function SM($) {
    return U$($, 'Ref') && I$($.$id) && x$($.$ref);
}
function jM($) {
    return (
        U$($, 'RegExp') &&
        I$($.$id) &&
        x$($.source) &&
        x$($.flags) &&
        b$($.maxLength) &&
        b$($.minLength)
    );
}
function LM($) {
    return (
        U$($, 'String') &&
        $.type === 'string' &&
        I$($.$id) &&
        b$($.minLength) &&
        b$($.maxLength) &&
        lD($.pattern) &&
        oD($.format)
    );
}
function KM($) {
    return U$($, 'Symbol') && $.type === 'symbol' && I$($.$id);
}
function _M($) {
    return (
        U$($, 'TemplateLiteral') &&
        $.type === 'string' &&
        x$($.pattern) &&
        $.pattern[0] === '^' &&
        $.pattern[$.pattern.length - 1] === '$'
    );
}
function FM($) {
    return U$($, 'This') && I$($.$id) && x$($.$ref);
}
function IM($) {
    return F$($) && R$ in $;
}
function CM($) {
    return (
        U$($, 'Tuple') &&
        $.type === 'array' &&
        I$($.$id) &&
        Q4($.minItems) &&
        Q4($.maxItems) &&
        $.minItems === $.maxItems &&
        ((W6($.items) && W6($.additionalItems) && $.minItems === 0) ||
            (X6($.items) && $.items.every((X) => d$(X))))
    );
}
function RM($) {
    return U$($, 'Undefined') && $.type === 'undefined' && I$($.$id);
}
function $B($) {
    return lQ($) && $.anyOf.every((X) => MM(X) || GM(X));
}
function lQ($) {
    return (
        U$($, 'Union') &&
        I$($.$id) &&
        F$($) &&
        X6($.anyOf) &&
        $.anyOf.every((X) => d$(X))
    );
}
function VM($) {
    return (
        U$($, 'Uint8Array') &&
        $.type === 'Uint8Array' &&
        I$($.$id) &&
        b$($.minByteLength) &&
        b$($.maxByteLength)
    );
}
function EM($) {
    return U$($, 'Unknown') && I$($.$id);
}
function xM($) {
    return U$($, 'Unsafe');
}
function bM($) {
    return U$($, 'Void') && $.type === 'void' && I$($.$id);
}
function gM($) {
    return F$($) && S in $ && x$($[S]) && !pD.includes($[S]);
}
function d$($) {
    return (
        F$($) &&
        (r9($) ||
            t9($) ||
            a9($) ||
            $M($) ||
            e9($) ||
            s9($) ||
            XM($) ||
            WM($) ||
            YM($) ||
            QM($) ||
            JM($) ||
            UM($) ||
            NM($) ||
            lX($) ||
            ZM($) ||
            wM($) ||
            DM($) ||
            BM($) ||
            OM($) ||
            HM($) ||
            qM($) ||
            AM($) ||
            PM($) ||
            SM($) ||
            jM($) ||
            LM($) ||
            KM($) ||
            _M($) ||
            FM($) ||
            CM($) ||
            RM($) ||
            lQ($) ||
            VM($) ||
            EM($) ||
            xM($) ||
            bM($) ||
            gM($))
    );
}
var TM = '(true|false)',
    SY = '(0|[1-9][0-9]*)',
    kM = '(.*)';
var r1 = '^(0|[1-9][0-9]*)$',
    t1 = '^(.*)$',
    vM = '^(?!.*)$';
var _$ = {};
k6(_$, {
    Set: () => JB,
    Has: () => QB,
    Get: () => UB,
    Entries: () => XB,
    Delete: () => YB,
    Clear: () => WB,
});
var r0 = new Map();
function XB() {
    return new Map(r0);
}
function WB() {
    return r0.clear();
}
function YB($) {
    return r0.delete($);
}
function QB($) {
    return r0.has($);
}
function JB($, X) {
    r0.set($, X);
}
function UB($) {
    return r0.get($);
}
var Z6 = {};
k6(Z6, {
    Set: () => ZB,
    Has: () => zB,
    Get: () => wB,
    Entries: () => NB,
    Delete: () => GB,
    Clear: () => MB,
});
var t0 = new Map();
function NB() {
    return new Map(t0);
}
function MB() {
    return t0.clear();
}
function GB($) {
    return t0.delete($);
}
function zB($) {
    return t0.has($);
}
function ZB($, X) {
    t0.set($, X);
}
function wB($) {
    return t0.get($);
}
function fM($, X) {
    return $.includes(X);
}
function yM($) {
    return [...new Set($)];
}
function DB($, X) {
    return $.filter((W) => X.includes(W));
}
function BB($, X) {
    return $.reduce((W, Q) => {
        return DB(W, Q);
    }, X);
}
function hM($) {
    return $.length === 1 ? $[0] : $.length > 1 ? BB($.slice(1), $[0]) : [];
}
function mM($) {
    let X = [];
    for (let W of $) X.push(...W);
    return X;
}
function a1($) {
    return F({ [S]: 'Any' }, $);
}
function a0($, X) {
    return F({ [S]: 'Array', type: 'array', items: $ }, X);
}
function cM($) {
    return F({ [S]: 'Argument', index: $ });
}
function s0($, X) {
    return F({ [S]: 'AsyncIterator', type: 'AsyncIterator', items: $ }, X);
}
function v$($, X, W) {
    return F({ [S]: 'Computed', target: $, parameters: X }, W);
}
function OB($, X) {
    let { [X]: W, ...Q } = $;
    return Q;
}
function r$($, X) {
    return X.reduce((W, Q) => OB(W, Q), $);
}
function Y$($) {
    return F({ [S]: 'Never', not: {} }, $);
}
function O$($) {
    return F({ [S]: 'MappedResult', properties: $ });
}
function e0($, X, W) {
    return F(
        { [S]: 'Constructor', type: 'Constructor', parameters: $, returns: X },
        W,
    );
}
function X1($, X, W) {
    return F(
        { [S]: 'Function', type: 'Function', parameters: $, returns: X },
        W,
    );
}
function oX($, X) {
    return F({ [S]: 'Union', anyOf: $ }, X);
}
function HB($) {
    return $.some((X) => u6(X));
}
function uM($) {
    return $.map((X) => (u6(X) ? qB(X) : X));
}
function qB($) {
    return r$($, [Y6]);
}
function AB($, X) {
    return HB($) ? R6(oX(uM($), X)) : oX(uM($), X);
}
function W1($, X) {
    return $.length === 1 ? F($[0], X) : $.length === 0 ? Y$(X) : AB($, X);
}
function S$($, X) {
    return $.length === 0 ? Y$(X) : $.length === 1 ? F($[0], X) : oX($, X);
}
class oQ extends r {}
function PB($) {
    return $.replace(/\\\$/g, '$')
        .replace(/\\\*/g, '*')
        .replace(/\\\^/g, '^')
        .replace(/\\\|/g, '|')
        .replace(/\\\(/g, '(')
        .replace(/\\\)/g, ')');
}
function rQ($, X, W) {
    return $[X] === W && $.charCodeAt(X - 1) !== 92;
}
function L1($, X) {
    return rQ($, X, '(');
}
function rX($, X) {
    return rQ($, X, ')');
}
function dM($, X) {
    return rQ($, X, '|');
}
function SB($) {
    if (!(L1($, 0) && rX($, $.length - 1))) return !1;
    let X = 0;
    for (let W = 0; W < $.length; W++) {
        if (L1($, W)) X += 1;
        if (rX($, W)) X -= 1;
        if (X === 0 && W !== $.length - 1) return !1;
    }
    return !0;
}
function jB($) {
    return $.slice(1, $.length - 1);
}
function LB($) {
    let X = 0;
    for (let W = 0; W < $.length; W++) {
        if (L1($, W)) X += 1;
        if (rX($, W)) X -= 1;
        if (dM($, W) && X === 0) return !0;
    }
    return !1;
}
function KB($) {
    for (let X = 0; X < $.length; X++) if (L1($, X)) return !0;
    return !1;
}
function _B($) {
    let [X, W] = [0, 0],
        Q = [];
    for (let J = 0; J < $.length; J++) {
        if (L1($, J)) X += 1;
        if (rX($, J)) X -= 1;
        if (dM($, J) && X === 0) {
            let U = $.slice(W, J);
            if (U.length > 0) Q.push($X(U));
            W = J + 1;
        }
    }
    let Y = $.slice(W);
    if (Y.length > 0) Q.push($X(Y));
    if (Q.length === 0) return { type: 'const', const: '' };
    if (Q.length === 1) return Q[0];
    return { type: 'or', expr: Q };
}
function FB($) {
    function X(Y, J) {
        if (!L1(Y, J))
            throw new oQ(
                'TemplateLiteralParser: Index must point to open parens',
            );
        let U = 0;
        for (let N = J; N < Y.length; N++) {
            if (L1(Y, N)) U += 1;
            if (rX(Y, N)) U -= 1;
            if (U === 0) return [J, N];
        }
        throw new oQ(
            'TemplateLiteralParser: Unclosed group parens in expression',
        );
    }
    function W(Y, J) {
        for (let U = J; U < Y.length; U++) if (L1(Y, U)) return [J, U];
        return [J, Y.length];
    }
    let Q = [];
    for (let Y = 0; Y < $.length; Y++)
        if (L1($, Y)) {
            let [J, U] = X($, Y),
                N = $.slice(J, U + 1);
            Q.push($X(N)), (Y = U);
        } else {
            let [J, U] = W($, Y),
                N = $.slice(J, U);
            if (N.length > 0) Q.push($X(N));
            Y = U - 1;
        }
    return Q.length === 0
        ? { type: 'const', const: '' }
        : Q.length === 1
          ? Q[0]
          : { type: 'and', expr: Q };
}
function $X($) {
    return SB($)
        ? $X(jB($))
        : LB($)
          ? _B($)
          : KB($)
            ? FB($)
            : { type: 'const', const: PB($) };
}
function XX($) {
    return $X($.slice(1, $.length - 1));
}
class iM extends r {}
function IB($) {
    return (
        $.type === 'or' &&
        $.expr.length === 2 &&
        $.expr[0].type === 'const' &&
        $.expr[0].const === '0' &&
        $.expr[1].type === 'const' &&
        $.expr[1].const === '[1-9][0-9]*'
    );
}
function CB($) {
    return (
        $.type === 'or' &&
        $.expr.length === 2 &&
        $.expr[0].type === 'const' &&
        $.expr[0].const === 'true' &&
        $.expr[1].type === 'const' &&
        $.expr[1].const === 'false'
    );
}
function RB($) {
    return $.type === 'const' && $.const === '.*';
}
function K0($) {
    return IB($) || RB($)
        ? !1
        : CB($)
          ? !0
          : $.type === 'and'
            ? $.expr.every((X) => K0(X))
            : $.type === 'or'
              ? $.expr.every((X) => K0(X))
              : $.type === 'const'
                ? !0
                : (() => {
                      throw new iM('Unknown expression type');
                  })();
}
function jY($) {
    let X = XX($.pattern);
    return K0(X);
}
class nM extends r {}
function* pM($) {
    if ($.length === 1) return yield* $[0];
    for (let X of $[0]) for (let W of pM($.slice(1))) yield `${X}${W}`;
}
function* VB($) {
    return yield* pM($.expr.map((X) => [...tX(X)]));
}
function* EB($) {
    for (let X of $.expr) yield* tX(X);
}
function* xB($) {
    return yield $.const;
}
function* tX($) {
    return $.type === 'and'
        ? yield* VB($)
        : $.type === 'or'
          ? yield* EB($)
          : $.type === 'const'
            ? yield* xB($)
            : (() => {
                  throw new nM('Unknown expression');
              })();
}
function WX($) {
    let X = XX($.pattern);
    return K0(X) ? [...tX(X)] : [];
}
function Z$($, X) {
    return F({ [S]: 'Literal', const: $, type: typeof $ }, X);
}
function LY($) {
    return F({ [S]: 'Boolean', type: 'boolean' }, $);
}
function YX($) {
    return F({ [S]: 'BigInt', type: 'bigint' }, $);
}
function j4($) {
    return F({ [S]: 'Number', type: 'number' }, $);
}
function f6($) {
    return F({ [S]: 'String', type: 'string' }, $);
}
function* bB($) {
    let X = $.trim().replace(/"|'/g, '');
    return X === 'boolean'
        ? yield LY()
        : X === 'number'
          ? yield j4()
          : X === 'bigint'
            ? yield YX()
            : X === 'string'
              ? yield f6()
              : yield (() => {
                    let W = X.split('|').map((Q) => Z$(Q.trim()));
                    return W.length === 0
                        ? Y$()
                        : W.length === 1
                          ? W[0]
                          : W1(W);
                })();
}
function* gB($) {
    if ($[1] !== '{') {
        let X = Z$('$'),
            W = tQ($.slice(1));
        return yield* [X, ...W];
    }
    for (let X = 2; X < $.length; X++)
        if ($[X] === '}') {
            let W = bB($.slice(2, X)),
                Q = tQ($.slice(X + 1));
            return yield* [...W, ...Q];
        }
    yield Z$($);
}
function* tQ($) {
    for (let X = 0; X < $.length; X++)
        if ($[X] === '$') {
            let W = Z$($.slice(0, X)),
                Q = gB($.slice(X));
            return yield* [W, ...Q];
        }
    yield Z$($);
}
function lM($) {
    return [...tQ($)];
}
class oM extends r {}
function TB($) {
    return $.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function rM($, X) {
    return M4($)
        ? $.pattern.slice(1, $.pattern.length - 1)
        : D$($)
          ? `(${$.anyOf.map((W) => rM(W, X)).join('|')})`
          : h4($)
            ? `${X}${SY}`
            : y4($)
              ? `${X}${SY}`
              : P0($)
                ? `${X}${SY}`
                : P1($)
                  ? `${X}${kM}`
                  : U4($)
                    ? `${X}${TB($.const.toString())}`
                    : A1($)
                      ? `${X}${TM}`
                      : (() => {
                            throw new oM(`Unexpected Kind '${$[S]}'`);
                        })();
}
function aQ($) {
    return `^${$.map((X) => rM(X, '')).join('')}$`;
}
function _0($) {
    let W = WX($).map((Q) => Z$(Q));
    return W1(W);
}
function KY($, X) {
    let W = x$($) ? aQ(lM($)) : aQ($);
    return F({ [S]: 'TemplateLiteral', type: 'string', pattern: W }, X);
}
function kB($) {
    return WX($).map((W) => W.toString());
}
function vB($) {
    let X = [];
    for (let W of $) X.push(...d6(W));
    return X;
}
function fB($) {
    return [$.toString()];
}
function d6($) {
    return [
        ...new Set(
            M4($)
                ? kB($)
                : D$($)
                  ? vB($.anyOf)
                  : U4($)
                    ? fB($.const)
                    : h4($)
                      ? ['[number]']
                      : y4($)
                        ? ['[number]']
                        : [],
        ),
    ];
}
function yB($, X, W) {
    let Q = {};
    for (let Y of Object.getOwnPropertyNames(X)) Q[Y] = s1($, d6(X[Y]), W);
    return Q;
}
function hB($, X, W) {
    return yB($, X.properties, W);
}
function tM($, X, W) {
    let Q = hB($, X, W);
    return O$(Q);
}
function sM($, X) {
    return $.map((W) => eM(W, X));
}
function mB($) {
    return $.filter((X) => !l1(X));
}
function cB($, X) {
    return _Y(mB(sM($, X)));
}
function uB($) {
    return $.some((X) => l1(X)) ? [] : $;
}
function dB($, X) {
    return W1(uB(sM($, X)));
}
function iB($, X) {
    return X in $ ? $[X] : X === '[number]' ? W1($) : Y$();
}
function nB($, X) {
    return X === '[number]' ? $ : Y$();
}
function pB($, X) {
    return X in $ ? $[X] : Y$();
}
function eM($, X) {
    return o$($)
        ? cB($.allOf, X)
        : D$($)
          ? dB($.anyOf, X)
          : G4($)
            ? iB($.items ?? [], X)
            : T4($)
              ? nB($.items, X)
              : Q6($)
                ? pB($.properties, X)
                : Y$();
}
function aX($, X) {
    return X.map((W) => eM($, W));
}
function aM($, X) {
    return W1(aX($, X));
}
function s1($, X, W) {
    if (e$($) || e$(X)) {
        if (!n$($) || !n$(X))
            throw new r(
                'Index types using Ref parameters require both Type and Key to be of TSchema',
            );
        return v$('Index', [$, X]);
    }
    if (u$(X)) return tM($, X, W);
    if (N4(X)) return $2($, X, W);
    return F(n$(X) ? aM($, d6(X)) : aM($, X), W);
}
function lB($, X, W) {
    return { [X]: s1($, [X], m$(W)) };
}
function oB($, X, W) {
    return X.reduce((Q, Y) => {
        return { ...Q, ...lB($, Y, W) };
    }, {});
}
function rB($, X, W) {
    return oB($, X.keys, W);
}
function $2($, X, W) {
    let Q = rB($, X, W);
    return O$(Q);
}
function QX($, X) {
    return F({ [S]: 'Iterator', type: 'Iterator', items: $ }, X);
}
function tB($) {
    let X = [];
    for (let W in $) if (!u6($[W])) X.push(W);
    return X;
}
function aB($, X) {
    let W = tB($),
        Q =
            W.length > 0
                ? { [S]: 'Object', type: 'object', properties: $, required: W }
                : { [S]: 'Object', type: 'object', properties: $ };
    return F(Q, X);
}
var j$ = aB;
function FY($, X) {
    return F({ [S]: 'Promise', type: 'Promise', item: $ }, X);
}
function sB($) {
    return F(r$($, [g4]));
}
function eB($) {
    return F({ ...$, [g4]: 'Readonly' });
}
function $O($, X) {
    return X === !1 ? sB($) : eB($);
}
function i6($, X) {
    let W = X ?? !0;
    return u$($) ? X2($, W) : $O($, W);
}
function XO($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($)) W[Q] = i6($[Q], X);
    return W;
}
function WO($, X) {
    return XO($.properties, X);
}
function X2($, X) {
    let W = WO($, X);
    return O$(W);
}
function L4($, X) {
    return F(
        $.length > 0
            ? {
                  [S]: 'Tuple',
                  type: 'array',
                  items: $,
                  additionalItems: !1,
                  minItems: $.length,
                  maxItems: $.length,
              }
            : {
                  [S]: 'Tuple',
                  type: 'array',
                  minItems: $.length,
                  maxItems: $.length,
              },
        X,
    );
}
function W2($, X) {
    return $ in X ? K4($, X[$]) : O$(X);
}
function YO($) {
    return { [$]: Z$($) };
}
function QO($) {
    let X = {};
    for (let W of $) X[W] = Z$(W);
    return X;
}
function JO($, X) {
    return fM(X, $) ? YO($) : QO(X);
}
function UO($, X) {
    let W = JO($, X);
    return W2($, W);
}
function sX($, X) {
    return X.map((W) => K4($, W));
}
function NO($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames(X)) W[Q] = K4($, X[Q]);
    return W;
}
function K4($, X) {
    let W = { ...X };
    return u6(X)
        ? R6(K4($, r$(X, [Y6])))
        : o0(X)
          ? i6(K4($, r$(X, [g4])))
          : u$(X)
            ? W2($, X.properties)
            : N4(X)
              ? UO($, X.keys)
              : v4(X)
                ? e0(sX($, X.parameters), K4($, X.returns), W)
                : f4(X)
                  ? X1(sX($, X.parameters), K4($, X.returns), W)
                  : A0(X)
                    ? s0(K4($, X.items), W)
                    : S0(X)
                      ? QX(K4($, X.items), W)
                      : o$(X)
                        ? V6(sX($, X.allOf), W)
                        : D$(X)
                          ? S$(sX($, X.anyOf), W)
                          : G4(X)
                            ? L4(sX($, X.items ?? []), W)
                            : Q6(X)
                              ? j$(NO($, X.properties), W)
                              : T4(X)
                                ? a0(K4($, X.items), W)
                                : j0(X)
                                  ? FY(K4($, X.item), W)
                                  : X;
}
function MO($, X) {
    let W = {};
    for (let Q of $) W[Q] = K4(Q, X);
    return W;
}
function Y2($, X, W) {
    let Q = n$($) ? d6($) : $,
        Y = X({ [S]: 'MappedKey', keys: Q }),
        J = MO(Q, Y);
    return j$(J, W);
}
function GO($) {
    return F(r$($, [Y6]));
}
function zO($) {
    return F({ ...$, [Y6]: 'Optional' });
}
function ZO($, X) {
    return X === !1 ? GO($) : zO($);
}
function R6($, X) {
    let W = X ?? !0;
    return u$($) ? Q2($, W) : ZO($, W);
}
function wO($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($)) W[Q] = R6($[Q], X);
    return W;
}
function DO($, X) {
    return wO($.properties, X);
}
function Q2($, X) {
    let W = DO($, X);
    return O$(W);
}
function eX($, X = {}) {
    let W = $.every((Y) => Q6(Y)),
        Q = n$(X.unevaluatedProperties)
            ? { unevaluatedProperties: X.unevaluatedProperties }
            : {};
    return F(
        X.unevaluatedProperties === !1 || n$(X.unevaluatedProperties) || W
            ? { ...Q, [S]: 'Intersect', type: 'object', allOf: $ }
            : { ...Q, [S]: 'Intersect', allOf: $ },
        X,
    );
}
function BO($) {
    return $.every((X) => u6(X));
}
function OO($) {
    return r$($, [Y6]);
}
function J2($) {
    return $.map((X) => (u6(X) ? OO(X) : X));
}
function HO($, X) {
    return BO($) ? R6(eX(J2($), X)) : eX(J2($), X);
}
function _Y($, X = {}) {
    if ($.length === 1) return F($[0], X);
    if ($.length === 0) return Y$(X);
    if ($.some((W) => P$(W)))
        throw new Error('Cannot intersect transform types');
    return HO($, X);
}
function V6($, X) {
    if ($.length === 1) return F($[0], X);
    if ($.length === 0) return Y$(X);
    if ($.some((W) => P$(W)))
        throw new Error('Cannot intersect transform types');
    return eX($, X);
}
function _4(...$) {
    let [X, W] = typeof $[0] === 'string' ? [$[0], $[1]] : [$[0].$id, $[1]];
    if (typeof X !== 'string') throw new r('Ref: $ref must be a string');
    return F({ [S]: 'Ref', $ref: X }, W);
}
function qO($, X) {
    return v$('Awaited', [v$($, X)]);
}
function AO($) {
    return v$('Awaited', [_4($)]);
}
function PO($) {
    return V6(U2($));
}
function SO($) {
    return S$(U2($));
}
function jO($) {
    return JX($);
}
function U2($) {
    return $.map((X) => JX(X));
}
function JX($, X) {
    return F(
        k4($)
            ? qO($.target, $.parameters)
            : o$($)
              ? PO($.allOf)
              : D$($)
                ? SO($.anyOf)
                : j0($)
                  ? jO($.item)
                  : e$($)
                    ? AO($.$ref)
                    : $,
        X,
    );
}
function N2($) {
    let X = [];
    for (let W of $) X.push(n6(W));
    return X;
}
function LO($) {
    let X = N2($);
    return mM(X);
}
function KO($) {
    let X = N2($);
    return hM(X);
}
function _O($) {
    return $.map((X, W) => W.toString());
}
function FO($) {
    return ['[number]'];
}
function IO($) {
    return globalThis.Object.getOwnPropertyNames($);
}
function CO($) {
    if (!sQ) return [];
    return globalThis.Object.getOwnPropertyNames($).map((W) => {
        return W[0] === '^' && W[W.length - 1] === '$'
            ? W.slice(1, W.length - 1)
            : W;
    });
}
function n6($) {
    return o$($)
        ? LO($.allOf)
        : D$($)
          ? KO($.anyOf)
          : G4($)
            ? _O($.items ?? [])
            : T4($)
              ? FO($.items)
              : Q6($)
                ? IO($.properties)
                : L0($)
                  ? CO($.patternProperties)
                  : [];
}
var sQ = !1;
function K1($) {
    sQ = !0;
    let X = n6($);
    return (sQ = !1), `^(${X.map((Q) => `(${Q})`).join('|')})$`;
}
function RO($, X) {
    return v$('KeyOf', [v$($, X)]);
}
function VO($) {
    return v$('KeyOf', [_4($)]);
}
function EO($, X) {
    let W = n6($),
        Q = xO(W),
        Y = W1(Q);
    return F(Y, X);
}
function xO($) {
    return $.map((X) => (X === '[number]' ? j4() : Z$(X)));
}
function UX($, X) {
    return k4($)
        ? RO($.target, $.parameters)
        : e$($)
          ? VO($.$ref)
          : u$($)
            ? M2($, X)
            : EO($, X);
}
function bO($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($))
        W[Q] = UX($[Q], m$(X));
    return W;
}
function gO($, X) {
    return bO($.properties, X);
}
function M2($, X) {
    let W = gO($, X);
    return O$(W);
}
function IY($) {
    let X = n6($),
        W = aX($, X);
    return X.map((Q, Y) => [X[Y], W[Y]]);
}
function TO($) {
    let X = [];
    for (let W of $) X.push(...n6(W));
    return yM(X);
}
function kO($) {
    return $.filter((X) => !l1(X));
}
function vO($, X) {
    let W = [];
    for (let Q of $) W.push(...aX(Q, [X]));
    return kO(W);
}
function fO($, X) {
    let W = {};
    for (let Q of X) W[Q] = _Y(vO($, Q));
    return W;
}
function G2($, X) {
    let W = TO($),
        Q = fO($, W);
    return j$(Q, X);
}
function CY($) {
    return F({ [S]: 'Date', type: 'Date' }, $);
}
function RY($) {
    return F({ [S]: 'Null', type: 'null' }, $);
}
function VY($) {
    return F({ [S]: 'Symbol', type: 'symbol' }, $);
}
function EY($) {
    return F({ [S]: 'Undefined', type: 'undefined' }, $);
}
function xY($) {
    return F({ [S]: 'Uint8Array', type: 'Uint8Array' }, $);
}
function m4($) {
    return F({ [S]: 'Unknown' }, $);
}
function yO($) {
    return $.map((X) => eQ(X, !1));
}
function hO($) {
    let X = {};
    for (let W of globalThis.Object.getOwnPropertyNames($))
        X[W] = i6(eQ($[W], !1));
    return X;
}
function bY($, X) {
    return X === !0 ? $ : i6($);
}
function eQ($, X) {
    return vQ($)
        ? bY(a1(), X)
        : yQ($)
          ? bY(a1(), X)
          : X6($)
            ? i6(L4(yO($)))
            : O1($)
              ? xY()
              : q0($)
                ? CY()
                : F$($)
                  ? bY(j$(hO($)), X)
                  : fQ($)
                    ? bY(X1([], m4()), X)
                    : W6($)
                      ? EY()
                      : hQ($)
                        ? RY()
                        : mQ($)
                          ? VY()
                          : cX($)
                            ? YX()
                            : Q4($)
                              ? Z$($)
                              : B1($)
                                ? Z$($)
                                : x$($)
                                  ? Z$($)
                                  : j$({});
}
function z2($, X) {
    return F(eQ($, !0), X);
}
function Z2($, X) {
    return v4($) ? L4($.parameters, X) : Y$(X);
}
function w2($, X) {
    if (W6($)) throw new Error('Enum undefined or empty');
    let W = globalThis.Object.getOwnPropertyNames($)
            .filter((J) => isNaN(J))
            .map((J) => $[J]),
        Y = [...new Set(W)].map((J) => Z$(J));
    return S$(Y, { ...X, [S4]: 'Enum' });
}
class q2 extends r {}
var I;
(function ($) {
    ($[($.Union = 0)] = 'Union'),
        ($[($.True = 1)] = 'True'),
        ($[($.False = 2)] = 'False');
})(I || (I = {}));
function F4($) {
    return $ === I.False ? $ : I.True;
}
function NX($) {
    throw new q2($);
}
function N6($) {
    return (
        A.IsNever($) ||
        A.IsIntersect($) ||
        A.IsUnion($) ||
        A.IsUnknown($) ||
        A.IsAny($)
    );
}
function M6($, X) {
    return A.IsNever(X)
        ? S2($, X)
        : A.IsIntersect(X)
          ? gY($, X)
          : A.IsUnion(X)
            ? QJ($, X)
            : A.IsUnknown(X)
              ? _2($, X)
              : A.IsAny(X)
                ? YJ($, X)
                : NX('StructuralRight');
}
function YJ($, X) {
    return I.True;
}
function mO($, X) {
    return A.IsIntersect(X)
        ? gY($, X)
        : A.IsUnion(X) && X.anyOf.some((W) => A.IsAny(W) || A.IsUnknown(W))
          ? I.True
          : A.IsUnion(X)
            ? I.Union
            : A.IsUnknown(X)
              ? I.True
              : A.IsAny(X)
                ? I.True
                : I.Union;
}
function cO($, X) {
    return A.IsUnknown($)
        ? I.False
        : A.IsAny($)
          ? I.Union
          : A.IsNever($)
            ? I.True
            : I.False;
}
function uO($, X) {
    return A.IsObject(X) && TY(X)
        ? I.True
        : N6(X)
          ? M6($, X)
          : !A.IsArray(X)
            ? I.False
            : F4(C$($.items, X.items));
}
function dO($, X) {
    return N6(X)
        ? M6($, X)
        : !A.IsAsyncIterator(X)
          ? I.False
          : F4(C$($.items, X.items));
}
function iO($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsBigInt(X)
              ? I.True
              : I.False;
}
function A2($, X) {
    return A.IsLiteralBoolean($) ? I.True : A.IsBoolean($) ? I.True : I.False;
}
function nO($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsBoolean(X)
              ? I.True
              : I.False;
}
function pO($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : !A.IsConstructor(X)
            ? I.False
            : $.parameters.length > X.parameters.length
              ? I.False
              : !$.parameters.every(
                      (W, Q) => F4(C$(X.parameters[Q], W)) === I.True,
                  )
                ? I.False
                : F4(C$($.returns, X.returns));
}
function lO($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsDate(X)
              ? I.True
              : I.False;
}
function oO($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : !A.IsFunction(X)
            ? I.False
            : $.parameters.length > X.parameters.length
              ? I.False
              : !$.parameters.every(
                      (W, Q) => F4(C$(X.parameters[Q], W)) === I.True,
                  )
                ? I.False
                : F4(C$($.returns, X.returns));
}
function P2($, X) {
    return A.IsLiteral($) && C6.IsNumber($.const)
        ? I.True
        : A.IsNumber($) || A.IsInteger($)
          ? I.True
          : I.False;
}
function rO($, X) {
    return A.IsInteger(X) || A.IsNumber(X)
        ? I.True
        : N6(X)
          ? M6($, X)
          : A.IsObject(X)
            ? E6($, X)
            : A.IsRecord(X)
              ? I4($, X)
              : I.False;
}
function gY($, X) {
    return X.allOf.every((W) => C$($, W) === I.True) ? I.True : I.False;
}
function tO($, X) {
    return $.allOf.some((W) => C$(W, X) === I.True) ? I.True : I.False;
}
function aO($, X) {
    return N6(X)
        ? M6($, X)
        : !A.IsIterator(X)
          ? I.False
          : F4(C$($.items, X.items));
}
function sO($, X) {
    return A.IsLiteral(X) && X.const === $.const
        ? I.True
        : N6(X)
          ? M6($, X)
          : A.IsObject(X)
            ? E6($, X)
            : A.IsRecord(X)
              ? I4($, X)
              : A.IsString(X)
                ? K2($, X)
                : A.IsNumber(X)
                  ? j2($, X)
                  : A.IsInteger(X)
                    ? P2($, X)
                    : A.IsBoolean(X)
                      ? A2($, X)
                      : I.False;
}
function S2($, X) {
    return I.False;
}
function eO($, X) {
    return I.True;
}
function D2($) {
    let [X, W] = [$, 0];
    while (!0) {
        if (!A.IsNot(X)) break;
        (X = X.not), (W += 1);
    }
    return W % 2 === 0 ? X : m4();
}
function $H($, X) {
    return A.IsNot($)
        ? C$(D2($), X)
        : A.IsNot(X)
          ? C$($, D2(X))
          : NX('Invalid fallthrough for Not');
}
function XH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsNull(X)
              ? I.True
              : I.False;
}
function j2($, X) {
    return A.IsLiteralNumber($)
        ? I.True
        : A.IsNumber($) || A.IsInteger($)
          ? I.True
          : I.False;
}
function WH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsInteger(X) || A.IsNumber(X)
              ? I.True
              : I.False;
}
function p6($, X) {
    return Object.getOwnPropertyNames($.properties).length === X;
}
function B2($) {
    return TY($);
}
function O2($) {
    return (
        p6($, 0) ||
        (p6($, 1) &&
            'description' in $.properties &&
            A.IsUnion($.properties.description) &&
            $.properties.description.anyOf.length === 2 &&
            ((A.IsString($.properties.description.anyOf[0]) &&
                A.IsUndefined($.properties.description.anyOf[1])) ||
                (A.IsString($.properties.description.anyOf[1]) &&
                    A.IsUndefined($.properties.description.anyOf[0]))))
    );
}
function $J($) {
    return p6($, 0);
}
function H2($) {
    return p6($, 0);
}
function YH($) {
    return p6($, 0);
}
function QH($) {
    return p6($, 0);
}
function JH($) {
    return TY($);
}
function UH($) {
    let X = j4();
    return (
        p6($, 0) ||
        (p6($, 1) &&
            'length' in $.properties &&
            F4(C$($.properties.length, X)) === I.True)
    );
}
function NH($) {
    return p6($, 0);
}
function TY($) {
    let X = j4();
    return (
        p6($, 0) ||
        (p6($, 1) &&
            'length' in $.properties &&
            F4(C$($.properties.length, X)) === I.True)
    );
}
function MH($) {
    let X = X1([a1()], a1());
    return (
        p6($, 0) ||
        (p6($, 1) &&
            'then' in $.properties &&
            F4(C$($.properties.then, X)) === I.True)
    );
}
function L2($, X) {
    return C$($, X) === I.False
        ? I.False
        : A.IsOptional($) && !A.IsOptional(X)
          ? I.False
          : I.True;
}
function E6($, X) {
    return A.IsUnknown($)
        ? I.False
        : A.IsAny($)
          ? I.Union
          : A.IsNever($) ||
              (A.IsLiteralString($) && B2(X)) ||
              (A.IsLiteralNumber($) && $J(X)) ||
              (A.IsLiteralBoolean($) && H2(X)) ||
              (A.IsSymbol($) && O2(X)) ||
              (A.IsBigInt($) && YH(X)) ||
              (A.IsString($) && B2(X)) ||
              (A.IsSymbol($) && O2(X)) ||
              (A.IsNumber($) && $J(X)) ||
              (A.IsInteger($) && $J(X)) ||
              (A.IsBoolean($) && H2(X)) ||
              (A.IsUint8Array($) && JH(X)) ||
              (A.IsDate($) && QH(X)) ||
              (A.IsConstructor($) && NH(X)) ||
              (A.IsFunction($) && UH(X))
            ? I.True
            : A.IsRecord($) && A.IsString(XJ($))
              ? (() => {
                    return X[S4] === 'Record' ? I.True : I.False;
                })()
              : A.IsRecord($) && A.IsNumber(XJ($))
                ? (() => {
                      return p6(X, 0) ? I.True : I.False;
                  })()
                : I.False;
}
function GH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsRecord(X)
          ? I4($, X)
          : !A.IsObject(X)
            ? I.False
            : (() => {
                  for (let W of Object.getOwnPropertyNames(X.properties)) {
                      if (
                          !(W in $.properties) &&
                          !A.IsOptional(X.properties[W])
                      )
                          return I.False;
                      if (A.IsOptional(X.properties[W])) return I.True;
                      if (L2($.properties[W], X.properties[W]) === I.False)
                          return I.False;
                  }
                  return I.True;
              })();
}
function zH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X) && MH(X)
          ? I.True
          : !A.IsPromise(X)
            ? I.False
            : F4(C$($.item, X.item));
}
function XJ($) {
    return r1 in $.patternProperties
        ? j4()
        : t1 in $.patternProperties
          ? f6()
          : NX('Unknown record key pattern');
}
function WJ($) {
    return r1 in $.patternProperties
        ? $.patternProperties[r1]
        : t1 in $.patternProperties
          ? $.patternProperties[t1]
          : NX('Unable to get record value schema');
}
function I4($, X) {
    let [W, Q] = [XJ(X), WJ(X)];
    return A.IsLiteralString($) && A.IsNumber(W) && F4(C$($, Q)) === I.True
        ? I.True
        : A.IsUint8Array($) && A.IsNumber(W)
          ? C$($, Q)
          : A.IsString($) && A.IsNumber(W)
            ? C$($, Q)
            : A.IsArray($) && A.IsNumber(W)
              ? C$($, Q)
              : A.IsObject($)
                ? (() => {
                      for (let Y of Object.getOwnPropertyNames($.properties))
                          if (L2(Q, $.properties[Y]) === I.False)
                              return I.False;
                      return I.True;
                  })()
                : I.False;
}
function ZH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : !A.IsRecord(X)
            ? I.False
            : C$(WJ($), WJ(X));
}
function wH($, X) {
    let W = A.IsRegExp($) ? f6() : $,
        Q = A.IsRegExp(X) ? f6() : X;
    return C$(W, Q);
}
function K2($, X) {
    return A.IsLiteral($) && C6.IsString($.const)
        ? I.True
        : A.IsString($)
          ? I.True
          : I.False;
}
function DH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsString(X)
              ? I.True
              : I.False;
}
function BH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsSymbol(X)
              ? I.True
              : I.False;
}
function OH($, X) {
    return A.IsTemplateLiteral($)
        ? C$(_0($), X)
        : A.IsTemplateLiteral(X)
          ? C$($, _0(X))
          : NX('Invalid fallthrough for TemplateLiteral');
}
function HH($, X) {
    return (
        A.IsArray(X) &&
        $.items !== void 0 &&
        $.items.every((W) => C$(W, X.items) === I.True)
    );
}
function qH($, X) {
    return A.IsNever($)
        ? I.True
        : A.IsUnknown($)
          ? I.False
          : A.IsAny($)
            ? I.Union
            : I.False;
}
function AH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X) && TY(X)
          ? I.True
          : A.IsArray(X) && HH($, X)
            ? I.True
            : !A.IsTuple(X)
              ? I.False
              : (C6.IsUndefined($.items) && !C6.IsUndefined(X.items)) ||
                  (!C6.IsUndefined($.items) && C6.IsUndefined(X.items))
                ? I.False
                : C6.IsUndefined($.items) && !C6.IsUndefined(X.items)
                  ? I.True
                  : $.items.every((W, Q) => C$(W, X.items[Q]) === I.True)
                    ? I.True
                    : I.False;
}
function PH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsUint8Array(X)
              ? I.True
              : I.False;
}
function SH($, X) {
    return N6(X)
        ? M6($, X)
        : A.IsObject(X)
          ? E6($, X)
          : A.IsRecord(X)
            ? I4($, X)
            : A.IsVoid(X)
              ? KH($, X)
              : A.IsUndefined(X)
                ? I.True
                : I.False;
}
function QJ($, X) {
    return X.anyOf.some((W) => C$($, W) === I.True) ? I.True : I.False;
}
function jH($, X) {
    return $.anyOf.every((W) => C$(W, X) === I.True) ? I.True : I.False;
}
function _2($, X) {
    return I.True;
}
function LH($, X) {
    return A.IsNever(X)
        ? S2($, X)
        : A.IsIntersect(X)
          ? gY($, X)
          : A.IsUnion(X)
            ? QJ($, X)
            : A.IsAny(X)
              ? YJ($, X)
              : A.IsString(X)
                ? K2($, X)
                : A.IsNumber(X)
                  ? j2($, X)
                  : A.IsInteger(X)
                    ? P2($, X)
                    : A.IsBoolean(X)
                      ? A2($, X)
                      : A.IsArray(X)
                        ? cO($, X)
                        : A.IsTuple(X)
                          ? qH($, X)
                          : A.IsObject(X)
                            ? E6($, X)
                            : A.IsUnknown(X)
                              ? I.True
                              : I.False;
}
function KH($, X) {
    return A.IsUndefined($) ? I.True : A.IsUndefined($) ? I.True : I.False;
}
function _H($, X) {
    return A.IsIntersect(X)
        ? gY($, X)
        : A.IsUnion(X)
          ? QJ($, X)
          : A.IsUnknown(X)
            ? _2($, X)
            : A.IsAny(X)
              ? YJ($, X)
              : A.IsObject(X)
                ? E6($, X)
                : A.IsVoid(X)
                  ? I.True
                  : I.False;
}
function C$($, X) {
    return A.IsTemplateLiteral($) || A.IsTemplateLiteral(X)
        ? OH($, X)
        : A.IsRegExp($) || A.IsRegExp(X)
          ? wH($, X)
          : A.IsNot($) || A.IsNot(X)
            ? $H($, X)
            : A.IsAny($)
              ? mO($, X)
              : A.IsArray($)
                ? uO($, X)
                : A.IsBigInt($)
                  ? iO($, X)
                  : A.IsBoolean($)
                    ? nO($, X)
                    : A.IsAsyncIterator($)
                      ? dO($, X)
                      : A.IsConstructor($)
                        ? pO($, X)
                        : A.IsDate($)
                          ? lO($, X)
                          : A.IsFunction($)
                            ? oO($, X)
                            : A.IsInteger($)
                              ? rO($, X)
                              : A.IsIntersect($)
                                ? tO($, X)
                                : A.IsIterator($)
                                  ? aO($, X)
                                  : A.IsLiteral($)
                                    ? sO($, X)
                                    : A.IsNever($)
                                      ? eO($, X)
                                      : A.IsNull($)
                                        ? XH($, X)
                                        : A.IsNumber($)
                                          ? WH($, X)
                                          : A.IsObject($)
                                            ? GH($, X)
                                            : A.IsRecord($)
                                              ? ZH($, X)
                                              : A.IsString($)
                                                ? DH($, X)
                                                : A.IsSymbol($)
                                                  ? BH($, X)
                                                  : A.IsTuple($)
                                                    ? AH($, X)
                                                    : A.IsPromise($)
                                                      ? zH($, X)
                                                      : A.IsUint8Array($)
                                                        ? PH($, X)
                                                        : A.IsUndefined($)
                                                          ? SH($, X)
                                                          : A.IsUnion($)
                                                            ? jH($, X)
                                                            : A.IsUnknown($)
                                                              ? LH($, X)
                                                              : A.IsVoid($)
                                                                ? _H($, X)
                                                                : NX(
                                                                      `Unknown left type operand '${$[S]}'`,
                                                                  );
}
function e1($, X) {
    return C$($, X);
}
function FH($, X, W, Q, Y) {
    let J = {};
    for (let U of globalThis.Object.getOwnPropertyNames($))
        J[U] = MX($[U], X, W, Q, m$(Y));
    return J;
}
function IH($, X, W, Q, Y) {
    return FH($.properties, X, W, Q, Y);
}
function F2($, X, W, Q, Y) {
    let J = IH($, X, W, Q, Y);
    return O$(J);
}
function CH($, X, W, Q) {
    let Y = e1($, X);
    return Y === I.Union ? S$([W, Q]) : Y === I.True ? W : Q;
}
function MX($, X, W, Q, Y) {
    return u$($)
        ? F2($, X, W, Q, Y)
        : N4($)
          ? F(I2($, X, W, Q, Y))
          : F(CH($, X, W, Q), Y);
}
function RH($, X, W, Q, Y) {
    return { [$]: MX(Z$($), X, W, Q, m$(Y)) };
}
function VH($, X, W, Q, Y) {
    return $.reduce((J, U) => {
        return { ...J, ...RH(U, X, W, Q, Y) };
    }, {});
}
function EH($, X, W, Q, Y) {
    return VH($.keys, X, W, Q, Y);
}
function I2($, X, W, Q, Y) {
    let J = EH($, X, W, Q, Y);
    return O$(J);
}
function xH($) {
    return $.allOf.every((X) => _1(X));
}
function bH($) {
    return $.anyOf.some((X) => _1(X));
}
function gH($) {
    return !_1($.not);
}
function _1($) {
    return $[S] === 'Intersect'
        ? xH($)
        : $[S] === 'Union'
          ? bH($)
          : $[S] === 'Not'
            ? gH($)
            : $[S] === 'Undefined'
              ? !0
              : !1;
}
function C2($, X) {
    return GX(_0($), X);
}
function TH($, X) {
    let W = $.filter((Q) => e1(Q, X) === I.False);
    return W.length === 1 ? W[0] : S$(W);
}
function GX($, X, W = {}) {
    if (M4($)) return F(C2($, X), W);
    if (u$($)) return F(R2($, X), W);
    return F(D$($) ? TH($.anyOf, X) : e1($, X) !== I.False ? Y$() : $, W);
}
function kH($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($)) W[Q] = GX($[Q], X);
    return W;
}
function vH($, X) {
    return kH($.properties, X);
}
function R2($, X) {
    let W = vH($, X);
    return O$(W);
}
function V2($, X) {
    return zX(_0($), X);
}
function fH($, X) {
    let W = $.filter((Q) => e1(Q, X) !== I.False);
    return W.length === 1 ? W[0] : S$(W);
}
function zX($, X, W) {
    if (M4($)) return F(V2($, X), W);
    if (u$($)) return F(E2($, X), W);
    return F(D$($) ? fH($.anyOf, X) : e1($, X) !== I.False ? $ : Y$(), W);
}
function yH($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($)) W[Q] = zX($[Q], X);
    return W;
}
function hH($, X) {
    return yH($.properties, X);
}
function E2($, X) {
    let W = hH($, X);
    return O$(W);
}
function x2($, X) {
    return v4($) ? F($.returns, X) : Y$(X);
}
function kY($) {
    return i6(R6($));
}
function F0($, X, W) {
    return F(
        { [S]: 'Record', type: 'object', patternProperties: { [$]: X } },
        W,
    );
}
function JJ($, X, W) {
    let Q = {};
    for (let Y of $) Q[Y] = X;
    return j$(Q, { ...W, [S4]: 'Record' });
}
function mH($, X, W) {
    return jY($) ? JJ(d6($), X, W) : F0($.pattern, X, W);
}
function cH($, X, W) {
    return JJ(d6(S$($)), X, W);
}
function uH($, X, W) {
    return JJ([$.toString()], X, W);
}
function dH($, X, W) {
    return F0($.source, X, W);
}
function iH($, X, W) {
    let Q = W6($.pattern) ? t1 : $.pattern;
    return F0(Q, X, W);
}
function nH($, X, W) {
    return F0(t1, X, W);
}
function pH($, X, W) {
    return F0(vM, X, W);
}
function lH($, X, W) {
    return j$({ true: X, false: X }, W);
}
function oH($, X, W) {
    return F0(r1, X, W);
}
function rH($, X, W) {
    return F0(r1, X, W);
}
function vY($, X, W = {}) {
    return D$($)
        ? cH($.anyOf, X, W)
        : M4($)
          ? mH($, X, W)
          : U4($)
            ? uH($.const, X, W)
            : A1($)
              ? lH($, X, W)
              : y4($)
                ? oH($, X, W)
                : h4($)
                  ? rH($, X, W)
                  : iQ($)
                    ? dH($, X, W)
                    : P1($)
                      ? iH($, X, W)
                      : uQ($)
                        ? nH($, X, W)
                        : l1($)
                          ? pH($, X, W)
                          : Y$(W);
}
function fY($) {
    return globalThis.Object.getOwnPropertyNames($.patternProperties)[0];
}
function b2($) {
    let X = fY($);
    return X === t1 ? f6() : X === r1 ? j4() : f6({ pattern: X });
}
function yY($) {
    return $.patternProperties[fY($)];
}
function tH($, X) {
    return (
        (X.parameters = $W($, X.parameters)), (X.returns = c4($, X.returns)), X
    );
}
function aH($, X) {
    return (
        (X.parameters = $W($, X.parameters)), (X.returns = c4($, X.returns)), X
    );
}
function sH($, X) {
    return (X.allOf = $W($, X.allOf)), X;
}
function eH($, X) {
    return (X.anyOf = $W($, X.anyOf)), X;
}
function $q($, X) {
    if (W6(X.items)) return X;
    return (X.items = $W($, X.items)), X;
}
function Xq($, X) {
    return (X.items = c4($, X.items)), X;
}
function Wq($, X) {
    return (X.items = c4($, X.items)), X;
}
function Yq($, X) {
    return (X.items = c4($, X.items)), X;
}
function Qq($, X) {
    return (X.item = c4($, X.item)), X;
}
function Jq($, X) {
    let W = Gq($, X.properties);
    return { ...X, ...j$(W) };
}
function Uq($, X) {
    let W = c4($, b2(X)),
        Q = c4($, yY(X)),
        Y = vY(W, Q);
    return { ...X, ...Y };
}
function Nq($, X) {
    return X.index in $ ? $[X.index] : m4();
}
function Mq($, X) {
    let W = o0(X),
        Q = u6(X),
        Y = c4($, X);
    return W && Q ? kY(Y) : W && !Q ? i6(Y) : !W && Q ? R6(Y) : Y;
}
function Gq($, X) {
    return globalThis.Object.getOwnPropertyNames(X).reduce((W, Q) => {
        return { ...W, [Q]: Mq($, X[Q]) };
    }, {});
}
function $W($, X) {
    return X.map((W) => c4($, W));
}
function c4($, X) {
    return v4(X)
        ? tH($, X)
        : f4(X)
          ? aH($, X)
          : o$(X)
            ? sH($, X)
            : D$(X)
              ? eH($, X)
              : G4(X)
                ? $q($, X)
                : T4(X)
                  ? Xq($, X)
                  : A0(X)
                    ? Wq($, X)
                    : S0(X)
                      ? Yq($, X)
                      : j0(X)
                        ? Qq($, X)
                        : Q6(X)
                          ? Jq($, X)
                          : L0(X)
                            ? Uq($, X)
                            : dQ(X)
                              ? Nq($, X)
                              : X;
}
function g2($, X) {
    return c4(X, p0($));
}
function T2($) {
    return F({ [S]: 'Integer', type: 'integer' }, $);
}
function zq($, X, W) {
    return { [$]: u4(Z$($), X, m$(W)) };
}
function Zq($, X, W) {
    return $.reduce((Y, J) => {
        return { ...Y, ...zq(J, X, W) };
    }, {});
}
function wq($, X, W) {
    return Zq($.keys, X, W);
}
function k2($, X, W) {
    let Q = wq($, X, W);
    return O$(Q);
}
function Dq($) {
    let [X, W] = [$.slice(0, 1), $.slice(1)];
    return [X.toLowerCase(), W].join('');
}
function Bq($) {
    let [X, W] = [$.slice(0, 1), $.slice(1)];
    return [X.toUpperCase(), W].join('');
}
function Oq($) {
    return $.toUpperCase();
}
function Hq($) {
    return $.toLowerCase();
}
function qq($, X, W) {
    let Q = XX($.pattern);
    if (!K0(Q)) return { ...$, pattern: v2($.pattern, X) };
    let U = [...tX(Q)].map((G) => Z$(G)),
        N = f2(U, X),
        M = S$(N);
    return KY([M], W);
}
function v2($, X) {
    return typeof $ === 'string'
        ? X === 'Uncapitalize'
            ? Dq($)
            : X === 'Capitalize'
              ? Bq($)
              : X === 'Uppercase'
                ? Oq($)
                : X === 'Lowercase'
                  ? Hq($)
                  : $
        : $.toString();
}
function f2($, X) {
    return $.map((W) => u4(W, X));
}
function u4($, X, W = {}) {
    return N4($)
        ? k2($, X, W)
        : M4($)
          ? qq($, X, W)
          : D$($)
            ? S$(f2($.anyOf, X), W)
            : U4($)
              ? Z$(v2($.const, X), W)
              : F($, W);
}
function y2($, X = {}) {
    return u4($, 'Capitalize', X);
}
function h2($, X = {}) {
    return u4($, 'Lowercase', X);
}
function m2($, X = {}) {
    return u4($, 'Uncapitalize', X);
}
function c2($, X = {}) {
    return u4($, 'Uppercase', X);
}
function Aq($, X, W) {
    let Q = {};
    for (let Y of globalThis.Object.getOwnPropertyNames($))
        Q[Y] = $0($[Y], X, m$(W));
    return Q;
}
function Pq($, X, W) {
    return Aq($.properties, X, W);
}
function u2($, X, W) {
    let Q = Pq($, X, W);
    return O$(Q);
}
function Sq($, X) {
    return $.map((W) => UJ(W, X));
}
function jq($, X) {
    return $.map((W) => UJ(W, X));
}
function Lq($, X) {
    let { [X]: W, ...Q } = $;
    return Q;
}
function Kq($, X) {
    return X.reduce((W, Q) => Lq(W, Q), $);
}
function _q($, X) {
    let W = r$($, [R$, '$id', 'required', 'properties']),
        Q = Kq($.properties, X);
    return j$(Q, W);
}
function Fq($) {
    let X = $.reduce((W, Q) => (AY(Q) ? [...W, Z$(Q)] : W), []);
    return S$(X);
}
function UJ($, X) {
    return o$($)
        ? V6(Sq($.allOf, X))
        : D$($)
          ? S$(jq($.anyOf, X))
          : Q6($)
            ? _q($, X)
            : j$({});
}
function $0($, X, W) {
    let Q = X6(X) ? Fq(X) : X,
        Y = n$(X) ? d6(X) : X,
        J = e$($),
        U = e$(X);
    return u$($)
        ? u2($, Y, W)
        : N4(X)
          ? d2($, X, W)
          : J && U
            ? v$('Omit', [$, Q], W)
            : !J && U
              ? v$('Omit', [$, Q], W)
              : J && !U
                ? v$('Omit', [$, Q], W)
                : F({ ...UJ($, Y), ...W });
}
function Iq($, X, W) {
    return { [X]: $0($, [X], m$(W)) };
}
function Cq($, X, W) {
    return X.reduce((Q, Y) => {
        return { ...Q, ...Iq($, Y, W) };
    }, {});
}
function Rq($, X, W) {
    return Cq($, X.keys, W);
}
function d2($, X, W) {
    let Q = Rq($, X, W);
    return O$(Q);
}
function Vq($, X, W) {
    let Q = {};
    for (let Y of globalThis.Object.getOwnPropertyNames($))
        Q[Y] = X0($[Y], X, m$(W));
    return Q;
}
function Eq($, X, W) {
    return Vq($.properties, X, W);
}
function i2($, X, W) {
    let Q = Eq($, X, W);
    return O$(Q);
}
function xq($, X) {
    return $.map((W) => NJ(W, X));
}
function bq($, X) {
    return $.map((W) => NJ(W, X));
}
function gq($, X) {
    let W = {};
    for (let Q of X) if (Q in $) W[Q] = $[Q];
    return W;
}
function Tq($, X) {
    let W = r$($, [R$, '$id', 'required', 'properties']),
        Q = gq($.properties, X);
    return j$(Q, W);
}
function kq($) {
    let X = $.reduce((W, Q) => (AY(Q) ? [...W, Z$(Q)] : W), []);
    return S$(X);
}
function NJ($, X) {
    return o$($)
        ? V6(xq($.allOf, X))
        : D$($)
          ? S$(bq($.anyOf, X))
          : Q6($)
            ? Tq($, X)
            : j$({});
}
function X0($, X, W) {
    let Q = X6(X) ? kq(X) : X,
        Y = n$(X) ? d6(X) : X,
        J = e$($),
        U = e$(X);
    return u$($)
        ? i2($, Y, W)
        : N4(X)
          ? n2($, X, W)
          : J && U
            ? v$('Pick', [$, Q], W)
            : !J && U
              ? v$('Pick', [$, Q], W)
              : J && !U
                ? v$('Pick', [$, Q], W)
                : F({ ...NJ($, Y), ...W });
}
function vq($, X, W) {
    return { [X]: X0($, [X], m$(W)) };
}
function fq($, X, W) {
    return X.reduce((Q, Y) => {
        return { ...Q, ...vq($, Y, W) };
    }, {});
}
function yq($, X, W) {
    return fq($, X.keys, W);
}
function n2($, X, W) {
    let Q = yq($, X, W);
    return O$(Q);
}
function hq($, X) {
    return v$('Partial', [v$($, X)]);
}
function mq($) {
    return v$('Partial', [_4($)]);
}
function cq($) {
    let X = {};
    for (let W of globalThis.Object.getOwnPropertyNames($)) X[W] = R6($[W]);
    return X;
}
function uq($) {
    let X = r$($, [R$, '$id', 'required', 'properties']),
        W = cq($.properties);
    return j$(W, X);
}
function p2($) {
    return $.map((X) => l2(X));
}
function l2($) {
    return k4($)
        ? hq($.target, $.parameters)
        : e$($)
          ? mq($.$ref)
          : o$($)
            ? V6(p2($.allOf))
            : D$($)
              ? S$(p2($.anyOf))
              : Q6($)
                ? uq($)
                : P0($)
                  ? $
                  : A1($)
                    ? $
                    : y4($)
                      ? $
                      : U4($)
                        ? $
                        : iX($)
                          ? $
                          : h4($)
                            ? $
                            : P1($)
                              ? $
                              : nX($)
                                ? $
                                : S1($)
                                  ? $
                                  : j$({});
}
function ZX($, X) {
    if (u$($)) return o2($, X);
    else return F({ ...l2($), ...X });
}
function dq($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($))
        W[Q] = ZX($[Q], m$(X));
    return W;
}
function iq($, X) {
    return dq($.properties, X);
}
function o2($, X) {
    let W = iq($, X);
    return O$(W);
}
function nq($, X) {
    return v$('Required', [v$($, X)]);
}
function pq($) {
    return v$('Required', [_4($)]);
}
function lq($) {
    let X = {};
    for (let W of globalThis.Object.getOwnPropertyNames($))
        X[W] = r$($[W], [Y6]);
    return X;
}
function oq($) {
    let X = r$($, [R$, '$id', 'required', 'properties']),
        W = lq($.properties);
    return j$(W, X);
}
function r2($) {
    return $.map((X) => t2(X));
}
function t2($) {
    return k4($)
        ? nq($.target, $.parameters)
        : e$($)
          ? pq($.$ref)
          : o$($)
            ? V6(r2($.allOf))
            : D$($)
              ? S$(r2($.anyOf))
              : Q6($)
                ? oq($)
                : P0($)
                  ? $
                  : A1($)
                    ? $
                    : y4($)
                      ? $
                      : U4($)
                        ? $
                        : iX($)
                          ? $
                          : h4($)
                            ? $
                            : P1($)
                              ? $
                              : nX($)
                                ? $
                                : S1($)
                                  ? $
                                  : j$({});
}
function wX($, X) {
    if (u$($)) return a2($, X);
    else return F({ ...t2($), ...X });
}
function rq($, X) {
    let W = {};
    for (let Q of globalThis.Object.getOwnPropertyNames($)) W[Q] = wX($[Q], X);
    return W;
}
function tq($, X) {
    return rq($.properties, X);
}
function a2($, X) {
    let W = tq($, X);
    return O$(W);
}
function aq($, X) {
    return X.map((W) => {
        return e$(W) ? MJ($, W.$ref) : z4($, W);
    });
}
function MJ($, X) {
    return X in $ ? (e$($[X]) ? MJ($, $[X].$ref) : z4($, $[X])) : Y$();
}
function sq($) {
    return JX($[0]);
}
function eq($) {
    return s1($[0], $[1]);
}
function $A($) {
    return UX($[0]);
}
function XA($) {
    return ZX($[0]);
}
function WA($) {
    return $0($[0], $[1]);
}
function YA($) {
    return X0($[0], $[1]);
}
function QA($) {
    return wX($[0]);
}
function JA($, X, W) {
    let Q = aq($, W);
    return X === 'Awaited'
        ? sq(Q)
        : X === 'Index'
          ? eq(Q)
          : X === 'KeyOf'
            ? $A(Q)
            : X === 'Partial'
              ? XA(Q)
              : X === 'Omit'
                ? WA(Q)
                : X === 'Pick'
                  ? YA(Q)
                  : X === 'Required'
                    ? QA(Q)
                    : Y$();
}
function UA($, X) {
    return a0(z4($, X));
}
function NA($, X) {
    return s0(z4($, X));
}
function MA($, X, W) {
    return e0(XW($, X), z4($, W));
}
function GA($, X, W) {
    return X1(XW($, X), z4($, W));
}
function zA($, X) {
    return V6(XW($, X));
}
function ZA($, X) {
    return QX(z4($, X));
}
function wA($, X) {
    return j$(
        globalThis.Object.keys(X).reduce((W, Q) => {
            return { ...W, [Q]: z4($, X[Q]) };
        }, {}),
    );
}
function DA($, X) {
    let [W, Q] = [z4($, yY(X)), fY(X)],
        Y = p0(X);
    return (Y.patternProperties[Q] = W), Y;
}
function BA($, X) {
    return e$(X) ? { ...MJ($, X.$ref), [R$]: X[R$] } : X;
}
function OA($, X) {
    return L4(XW($, X));
}
function HA($, X) {
    return S$(XW($, X));
}
function XW($, X) {
    return X.map((W) => z4($, W));
}
function z4($, X) {
    return u6(X)
        ? F(z4($, r$(X, [Y6])), X)
        : o0(X)
          ? F(z4($, r$(X, [g4])), X)
          : P$(X)
            ? F(BA($, X), X)
            : T4(X)
              ? F(UA($, X.items), X)
              : A0(X)
                ? F(NA($, X.items), X)
                : k4(X)
                  ? F(JA($, X.target, X.parameters))
                  : v4(X)
                    ? F(MA($, X.parameters, X.returns), X)
                    : f4(X)
                      ? F(GA($, X.parameters, X.returns), X)
                      : o$(X)
                        ? F(zA($, X.allOf), X)
                        : S0(X)
                          ? F(ZA($, X.items), X)
                          : Q6(X)
                            ? F(wA($, X.properties), X)
                            : L0(X)
                              ? F(DA($, X))
                              : G4(X)
                                ? F(OA($, X.items || []), X)
                                : D$(X)
                                  ? F(HA($, X.anyOf), X)
                                  : X;
}
function qA($, X) {
    return X in $ ? z4($, $[X]) : Y$();
}
function s2($) {
    return globalThis.Object.getOwnPropertyNames($).reduce((X, W) => {
        return { ...X, [W]: qA($, W) };
    }, {});
}
class e2 {
    constructor($) {
        let X = s2($),
            W = this.WithIdentifiers(X);
        this.$defs = W;
    }
    Import($, X) {
        let W = { ...this.$defs, [$]: F(this.$defs[$], X) };
        return F({ [S]: 'Import', $defs: W, $ref: $ });
    }
    WithIdentifiers($) {
        return globalThis.Object.getOwnPropertyNames($).reduce((X, W) => {
            return { ...X, [W]: { ...$[W], $id: W } };
        }, {});
    }
}
function $G($) {
    return new e2($);
}
function XG($, X) {
    return F({ [S]: 'Not', not: $ }, X);
}
function WG($, X) {
    return f4($) ? L4($.parameters, X) : Y$();
}
var AA = 0;
function YG($, X = {}) {
    if (W6(X.$id)) X.$id = `T${AA++}`;
    let W = p0($({ [S]: 'This', $ref: `${X.$id}` }));
    return (W.$id = X.$id), F({ [S4]: 'Recursive', ...W }, X);
}
function QG($, X) {
    let W = x$($) ? new globalThis.RegExp($) : $;
    return F(
        { [S]: 'RegExp', type: 'RegExp', source: W.source, flags: W.flags },
        X,
    );
}
function PA($) {
    return o$($) ? $.allOf : D$($) ? $.anyOf : G4($) ? ($.items ?? []) : [];
}
function JG($) {
    return PA($);
}
function UG($, X) {
    return f4($) ? F($.returns, X) : Y$(X);
}
class NG {
    constructor($) {
        this.schema = $;
    }
    Decode($) {
        return new MG(this.schema, $);
    }
}
class MG {
    constructor($, X) {
        (this.schema = $), (this.decode = X);
    }
    EncodeTransform($, X) {
        let Y = {
            Encode: (J) => X[R$].Encode($(J)),
            Decode: (J) => this.decode(X[R$].Decode(J)),
        };
        return { ...X, [R$]: Y };
    }
    EncodeSchema($, X) {
        let W = { Decode: this.decode, Encode: $ };
        return { ...X, [R$]: W };
    }
    Encode($) {
        return P$(this.schema)
            ? this.EncodeTransform($, this.schema)
            : this.EncodeSchema($, this.schema);
    }
}
function GG($) {
    return new NG($);
}
function hY($ = {}) {
    return F({ [S]: $[S] ?? 'Unsafe' }, $);
}
function zG($) {
    return F({ [S]: 'Void', type: 'void' }, $);
}
var GJ = {};
k6(GJ, {
    Void: () => zG,
    Uppercase: () => c2,
    Unsafe: () => hY,
    Unknown: () => m4,
    Union: () => S$,
    Undefined: () => EY,
    Uncapitalize: () => m2,
    Uint8Array: () => xY,
    Tuple: () => L4,
    Transform: () => GG,
    TemplateLiteral: () => KY,
    Symbol: () => VY,
    String: () => f6,
    ReturnType: () => UG,
    Rest: () => JG,
    Required: () => wX,
    RegExp: () => QG,
    Ref: () => _4,
    Recursive: () => YG,
    Record: () => vY,
    ReadonlyOptional: () => kY,
    Readonly: () => i6,
    Promise: () => FY,
    Pick: () => X0,
    Partial: () => ZX,
    Parameters: () => WG,
    Optional: () => R6,
    Omit: () => $0,
    Object: () => j$,
    Number: () => j4,
    Null: () => RY,
    Not: () => XG,
    Never: () => Y$,
    Module: () => $G,
    Mapped: () => Y2,
    Lowercase: () => h2,
    Literal: () => Z$,
    KeyOf: () => UX,
    Iterator: () => QX,
    Intersect: () => V6,
    Integer: () => T2,
    Instantiate: () => g2,
    InstanceType: () => x2,
    Index: () => s1,
    Function: () => X1,
    Extract: () => zX,
    Extends: () => MX,
    Exclude: () => GX,
    Enum: () => w2,
    Date: () => CY,
    ConstructorParameters: () => Z2,
    Constructor: () => e0,
    Const: () => z2,
    Composite: () => G2,
    Capitalize: () => y2,
    Boolean: () => LY,
    BigInt: () => YX,
    Awaited: () => JX,
    AsyncIterator: () => s0,
    Array: () => a0,
    Argument: () => cM,
    Any: () => a1,
});
var F1 = GJ;
function SA($) {
    switch ($.errorType) {
        case _.ArrayContains:
            return 'Expected array to contain at least one matching value';
        case _.ArrayMaxContains:
            return `Expected array to contain no more than ${$.schema.maxContains} matching values`;
        case _.ArrayMinContains:
            return `Expected array to contain at least ${$.schema.minContains} matching values`;
        case _.ArrayMaxItems:
            return `Expected array length to be less or equal to ${$.schema.maxItems}`;
        case _.ArrayMinItems:
            return `Expected array length to be greater or equal to ${$.schema.minItems}`;
        case _.ArrayUniqueItems:
            return 'Expected array elements to be unique';
        case _.Array:
            return 'Expected array';
        case _.AsyncIterator:
            return 'Expected AsyncIterator';
        case _.BigIntExclusiveMaximum:
            return `Expected bigint to be less than ${$.schema.exclusiveMaximum}`;
        case _.BigIntExclusiveMinimum:
            return `Expected bigint to be greater than ${$.schema.exclusiveMinimum}`;
        case _.BigIntMaximum:
            return `Expected bigint to be less or equal to ${$.schema.maximum}`;
        case _.BigIntMinimum:
            return `Expected bigint to be greater or equal to ${$.schema.minimum}`;
        case _.BigIntMultipleOf:
            return `Expected bigint to be a multiple of ${$.schema.multipleOf}`;
        case _.BigInt:
            return 'Expected bigint';
        case _.Boolean:
            return 'Expected boolean';
        case _.DateExclusiveMinimumTimestamp:
            return `Expected Date timestamp to be greater than ${$.schema.exclusiveMinimumTimestamp}`;
        case _.DateExclusiveMaximumTimestamp:
            return `Expected Date timestamp to be less than ${$.schema.exclusiveMaximumTimestamp}`;
        case _.DateMinimumTimestamp:
            return `Expected Date timestamp to be greater or equal to ${$.schema.minimumTimestamp}`;
        case _.DateMaximumTimestamp:
            return `Expected Date timestamp to be less or equal to ${$.schema.maximumTimestamp}`;
        case _.DateMultipleOfTimestamp:
            return `Expected Date timestamp to be a multiple of ${$.schema.multipleOfTimestamp}`;
        case _.Date:
            return 'Expected Date';
        case _.Function:
            return 'Expected function';
        case _.IntegerExclusiveMaximum:
            return `Expected integer to be less than ${$.schema.exclusiveMaximum}`;
        case _.IntegerExclusiveMinimum:
            return `Expected integer to be greater than ${$.schema.exclusiveMinimum}`;
        case _.IntegerMaximum:
            return `Expected integer to be less or equal to ${$.schema.maximum}`;
        case _.IntegerMinimum:
            return `Expected integer to be greater or equal to ${$.schema.minimum}`;
        case _.IntegerMultipleOf:
            return `Expected integer to be a multiple of ${$.schema.multipleOf}`;
        case _.Integer:
            return 'Expected integer';
        case _.IntersectUnevaluatedProperties:
            return 'Unexpected property';
        case _.Intersect:
            return 'Expected all values to match';
        case _.Iterator:
            return 'Expected Iterator';
        case _.Literal:
            return `Expected ${typeof $.schema.const === 'string' ? `'${$.schema.const}'` : $.schema.const}`;
        case _.Never:
            return 'Never';
        case _.Not:
            return 'Value should not match';
        case _.Null:
            return 'Expected null';
        case _.NumberExclusiveMaximum:
            return `Expected number to be less than ${$.schema.exclusiveMaximum}`;
        case _.NumberExclusiveMinimum:
            return `Expected number to be greater than ${$.schema.exclusiveMinimum}`;
        case _.NumberMaximum:
            return `Expected number to be less or equal to ${$.schema.maximum}`;
        case _.NumberMinimum:
            return `Expected number to be greater or equal to ${$.schema.minimum}`;
        case _.NumberMultipleOf:
            return `Expected number to be a multiple of ${$.schema.multipleOf}`;
        case _.Number:
            return 'Expected number';
        case _.Object:
            return 'Expected object';
        case _.ObjectAdditionalProperties:
            return 'Unexpected property';
        case _.ObjectMaxProperties:
            return `Expected object to have no more than ${$.schema.maxProperties} properties`;
        case _.ObjectMinProperties:
            return `Expected object to have at least ${$.schema.minProperties} properties`;
        case _.ObjectRequiredProperty:
            return 'Expected required property';
        case _.Promise:
            return 'Expected Promise';
        case _.RegExp:
            return 'Expected string to match regular expression';
        case _.StringFormatUnknown:
            return `Unknown format '${$.schema.format}'`;
        case _.StringFormat:
            return `Expected string to match '${$.schema.format}' format`;
        case _.StringMaxLength:
            return `Expected string length less or equal to ${$.schema.maxLength}`;
        case _.StringMinLength:
            return `Expected string length greater or equal to ${$.schema.minLength}`;
        case _.StringPattern:
            return `Expected string to match '${$.schema.pattern}'`;
        case _.String:
            return 'Expected string';
        case _.Symbol:
            return 'Expected symbol';
        case _.TupleLength:
            return `Expected tuple to have ${$.schema.maxItems || 0} elements`;
        case _.Tuple:
            return 'Expected tuple';
        case _.Uint8ArrayMaxByteLength:
            return `Expected byte length less or equal to ${$.schema.maxByteLength}`;
        case _.Uint8ArrayMinByteLength:
            return `Expected byte length greater or equal to ${$.schema.minByteLength}`;
        case _.Uint8Array:
            return 'Expected Uint8Array';
        case _.Undefined:
            return 'Expected undefined';
        case _.Union:
            return 'Expected union value';
        case _.Void:
            return 'Expected void';
        case _.Kind:
            return `Expected kind '${$.schema[S]}'`;
        default:
            return 'Unknown error type';
    }
}
var jA = SA;
function ZG() {
    return jA;
}
class wG extends r {
    constructor($) {
        super(`Unable to dereference schema with $id '${$.$ref}'`);
        this.schema = $;
    }
}
function LA($, X) {
    let W = X.find((Q) => Q.$id === $.$ref);
    if (W === void 0) throw new wG($);
    return B$(W, X);
}
function O6($, X) {
    if (!w$($.$id) || X.some((W) => W.$id === $.$id)) return X;
    return X.push($), X;
}
function B$($, X) {
    return $[S] === 'This' || $[S] === 'Ref' ? LA($, X) : $;
}
class DG extends r {
    constructor($) {
        super('Unable to hash value');
        this.value = $;
    }
}
var Z4;
(function ($) {
    ($[($.Undefined = 0)] = 'Undefined'),
        ($[($.Null = 1)] = 'Null'),
        ($[($.Boolean = 2)] = 'Boolean'),
        ($[($.Number = 3)] = 'Number'),
        ($[($.String = 4)] = 'String'),
        ($[($.Object = 5)] = 'Object'),
        ($[($.Array = 6)] = 'Array'),
        ($[($.Date = 7)] = 'Date'),
        ($[($.Uint8Array = 8)] = 'Uint8Array'),
        ($[($.Symbol = 9)] = 'Symbol'),
        ($[($.BigInt = 10)] = 'BigInt');
})(Z4 || (Z4 = {}));
var DX = BigInt('14695981039346656037'),
    [KA, _A] = [BigInt('1099511628211'), BigInt('18446744073709551616')],
    FA = Array.from({ length: 256 }).map(($, X) => BigInt(X)),
    BG = new Float64Array(1),
    OG = new DataView(BG.buffer),
    HG = new Uint8Array(BG.buffer);
function* IA($) {
    let X = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0; W < X; W++) yield ($ >> (8 * (X - 1 - W))) & 255;
}
function CA($) {
    x6(Z4.Array);
    for (let X of $) BX(X);
}
function RA($) {
    x6(Z4.Boolean), x6($ ? 1 : 0);
}
function VA($) {
    x6(Z4.BigInt), OG.setBigInt64(0, $);
    for (let X of HG) x6(X);
}
function EA($) {
    x6(Z4.Date), BX($.getTime());
}
function xA($) {
    x6(Z4.Null);
}
function bA($) {
    x6(Z4.Number), OG.setFloat64(0, $);
    for (let X of HG) x6(X);
}
function gA($) {
    x6(Z4.Object);
    for (let X of globalThis.Object.getOwnPropertyNames($).sort())
        BX(X), BX($[X]);
}
function TA($) {
    x6(Z4.String);
    for (let X = 0; X < $.length; X++) for (let W of IA($.charCodeAt(X))) x6(W);
}
function kA($) {
    x6(Z4.Symbol), BX($.description);
}
function vA($) {
    x6(Z4.Uint8Array);
    for (let X = 0; X < $.length; X++) x6($[X]);
}
function fA($) {
    return x6(Z4.Undefined);
}
function BX($) {
    if (a($)) return CA($);
    if ($1($)) return RA($);
    if (K6($)) return VA($);
    if (v6($)) return EA($);
    if (H1($)) return xA($);
    if (l($)) return bA($);
    if (X$($)) return gA($);
    if (w$($)) return TA($);
    if (q1($)) return kA($);
    if (l0($)) return vA($);
    if (c$($)) return fA($);
    throw new DG($);
}
function x6($) {
    (DX = DX ^ FA[$]), (DX = (DX * KA) % _A);
}
function W0($) {
    return (DX = BigInt('14695981039346656037')), BX($), DX;
}
class qG extends r {
    constructor($) {
        super('Unknown type');
        this.schema = $;
    }
}
function yA($) {
    return $[S] === 'Any' || $[S] === 'Unknown';
}
function N$($) {
    return $ !== void 0;
}
function hA($, X, W) {
    return !0;
}
function mA($, X, W) {
    return !0;
}
function cA($, X, W) {
    if (!a(W)) return !1;
    if (N$($.minItems) && !(W.length >= $.minItems)) return !1;
    if (N$($.maxItems) && !(W.length <= $.maxItems)) return !1;
    if (!W.every((J) => H6($.items, X, J))) return !1;
    if (
        $.uniqueItems === !0 &&
        !(function () {
            let J = new Set();
            for (let U of W) {
                let N = W0(U);
                if (J.has(N)) return !1;
                else J.add(N);
            }
            return !0;
        })()
    )
        return !1;
    if (!(N$($.contains) || l($.minContains) || l($.maxContains))) return !0;
    let Q = N$($.contains) ? $.contains : Y$(),
        Y = W.reduce((J, U) => (H6(Q, X, U) ? J + 1 : J), 0);
    if (Y === 0) return !1;
    if (l($.minContains) && Y < $.minContains) return !1;
    if (l($.maxContains) && Y > $.maxContains) return !1;
    return !0;
}
function uA($, X, W) {
    return BY(W);
}
function dA($, X, W) {
    if (!K6(W)) return !1;
    if (N$($.exclusiveMaximum) && !(W < $.exclusiveMaximum)) return !1;
    if (N$($.exclusiveMinimum) && !(W > $.exclusiveMinimum)) return !1;
    if (N$($.maximum) && !(W <= $.maximum)) return !1;
    if (N$($.minimum) && !(W >= $.minimum)) return !1;
    if (N$($.multipleOf) && W % $.multipleOf !== BigInt(0)) return !1;
    return !0;
}
function iA($, X, W) {
    return $1(W);
}
function nA($, X, W) {
    return H6($.returns, X, W.prototype);
}
function pA($, X, W) {
    if (!v6(W)) return !1;
    if (
        N$($.exclusiveMaximumTimestamp) &&
        !(W.getTime() < $.exclusiveMaximumTimestamp)
    )
        return !1;
    if (
        N$($.exclusiveMinimumTimestamp) &&
        !(W.getTime() > $.exclusiveMinimumTimestamp)
    )
        return !1;
    if (N$($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
        return !1;
    if (N$($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
        return !1;
    if (N$($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
        return !1;
    return !0;
}
function lA($, X, W) {
    return p1(W);
}
function oA($, X, W) {
    let Q = globalThis.Object.values($.$defs),
        Y = $.$defs[$.$ref];
    return H6(Y, [...X, ...Q], W);
}
function rA($, X, W) {
    if (!qY(W)) return !1;
    if (N$($.exclusiveMaximum) && !(W < $.exclusiveMaximum)) return !1;
    if (N$($.exclusiveMinimum) && !(W > $.exclusiveMinimum)) return !1;
    if (N$($.maximum) && !(W <= $.maximum)) return !1;
    if (N$($.minimum) && !(W >= $.minimum)) return !1;
    if (N$($.multipleOf) && W % $.multipleOf !== 0) return !1;
    return !0;
}
function tA($, X, W) {
    let Q = $.allOf.every((Y) => H6(Y, X, W));
    if ($.unevaluatedProperties === !1) {
        let Y = new RegExp(K1($)),
            J = Object.getOwnPropertyNames(W).every((U) => Y.test(U));
        return Q && J;
    } else if (n$($.unevaluatedProperties)) {
        let Y = new RegExp(K1($)),
            J = Object.getOwnPropertyNames(W).every(
                (U) => Y.test(U) || H6($.unevaluatedProperties, X, W[U]),
            );
        return Q && J;
    } else return Q;
}
function aA($, X, W) {
    return OY(W);
}
function sA($, X, W) {
    return W === $.const;
}
function eA($, X, W) {
    return !1;
}
function $P($, X, W) {
    return !H6($.not, X, W);
}
function XP($, X, W) {
    return H1(W);
}
function WP($, X, W) {
    if (!k$.IsNumberLike(W)) return !1;
    if (N$($.exclusiveMaximum) && !(W < $.exclusiveMaximum)) return !1;
    if (N$($.exclusiveMinimum) && !(W > $.exclusiveMinimum)) return !1;
    if (N$($.minimum) && !(W >= $.minimum)) return !1;
    if (N$($.maximum) && !(W <= $.maximum)) return !1;
    if (N$($.multipleOf) && W % $.multipleOf !== 0) return !1;
    return !0;
}
function YP($, X, W) {
    if (!k$.IsObjectLike(W)) return !1;
    if (
        N$($.minProperties) &&
        !(Object.getOwnPropertyNames(W).length >= $.minProperties)
    )
        return !1;
    if (
        N$($.maxProperties) &&
        !(Object.getOwnPropertyNames(W).length <= $.maxProperties)
    )
        return !1;
    let Q = Object.getOwnPropertyNames($.properties);
    for (let Y of Q) {
        let J = $.properties[Y];
        if ($.required && $.required.includes(Y)) {
            if (!H6(J, X, W[Y])) return !1;
            if ((_1(J) || yA(J)) && !(Y in W)) return !1;
        } else if (k$.IsExactOptionalProperty(W, Y) && !H6(J, X, W[Y]))
            return !1;
    }
    if ($.additionalProperties === !1) {
        let Y = Object.getOwnPropertyNames(W);
        if (
            $.required &&
            $.required.length === Q.length &&
            Y.length === Q.length
        )
            return !0;
        else return Y.every((J) => Q.includes(J));
    } else if (typeof $.additionalProperties === 'object')
        return Object.getOwnPropertyNames(W).every(
            (J) => Q.includes(J) || H6($.additionalProperties, X, W[J]),
        );
    else return !0;
}
function QP($, X, W) {
    return HY(W);
}
function JP($, X, W) {
    if (!k$.IsRecordLike(W)) return !1;
    if (
        N$($.minProperties) &&
        !(Object.getOwnPropertyNames(W).length >= $.minProperties)
    )
        return !1;
    if (
        N$($.maxProperties) &&
        !(Object.getOwnPropertyNames(W).length <= $.maxProperties)
    )
        return !1;
    let [Q, Y] = Object.entries($.patternProperties)[0],
        J = new RegExp(Q),
        U = Object.entries(W).every(([G, Z]) => {
            return J.test(G) ? H6(Y, X, Z) : !0;
        }),
        N =
            typeof $.additionalProperties === 'object'
                ? Object.entries(W).every(([G, Z]) => {
                      return !J.test(G) ? H6($.additionalProperties, X, Z) : !0;
                  })
                : !0,
        M =
            $.additionalProperties === !1
                ? Object.getOwnPropertyNames(W).every((G) => {
                      return J.test(G);
                  })
                : !0;
    return U && N && M;
}
function UP($, X, W) {
    return H6(B$($, X), X, W);
}
function NP($, X, W) {
    let Q = new RegExp($.source, $.flags);
    if (N$($.minLength)) {
        if (!(W.length >= $.minLength)) return !1;
    }
    if (N$($.maxLength)) {
        if (!(W.length <= $.maxLength)) return !1;
    }
    return Q.test(W);
}
function MP($, X, W) {
    if (!w$(W)) return !1;
    if (N$($.minLength)) {
        if (!(W.length >= $.minLength)) return !1;
    }
    if (N$($.maxLength)) {
        if (!(W.length <= $.maxLength)) return !1;
    }
    if (N$($.pattern)) {
        if (!new RegExp($.pattern).test(W)) return !1;
    }
    if (N$($.format)) {
        if (!_$.Has($.format)) return !1;
        return _$.Get($.format)(W);
    }
    return !0;
}
function GP($, X, W) {
    return q1(W);
}
function zP($, X, W) {
    return w$(W) && new RegExp($.pattern).test(W);
}
function ZP($, X, W) {
    return H6(B$($, X), X, W);
}
function wP($, X, W) {
    if (!a(W)) return !1;
    if ($.items === void 0 && W.length !== 0) return !1;
    if (W.length !== $.maxItems) return !1;
    if (!$.items) return !0;
    for (let Q = 0; Q < $.items.length; Q++)
        if (!H6($.items[Q], X, W[Q])) return !1;
    return !0;
}
function DP($, X, W) {
    return c$(W);
}
function BP($, X, W) {
    return $.anyOf.some((Q) => H6(Q, X, W));
}
function OP($, X, W) {
    if (!l0(W)) return !1;
    if (N$($.maxByteLength) && !(W.length <= $.maxByteLength)) return !1;
    if (N$($.minByteLength) && !(W.length >= $.minByteLength)) return !1;
    return !0;
}
function HP($, X, W) {
    return !0;
}
function qP($, X, W) {
    return k$.IsVoidLike(W);
}
function AP($, X, W) {
    if (!Z6.Has($[S])) return !1;
    return Z6.Get($[S])($, W);
}
function H6($, X, W) {
    let Q = N$($.$id) ? O6($, X) : X,
        Y = $;
    switch (Y[S]) {
        case 'Any':
            return hA(Y, Q, W);
        case 'Argument':
            return mA(Y, Q, W);
        case 'Array':
            return cA(Y, Q, W);
        case 'AsyncIterator':
            return uA(Y, Q, W);
        case 'BigInt':
            return dA(Y, Q, W);
        case 'Boolean':
            return iA(Y, Q, W);
        case 'Constructor':
            return nA(Y, Q, W);
        case 'Date':
            return pA(Y, Q, W);
        case 'Function':
            return lA(Y, Q, W);
        case 'Import':
            return oA(Y, Q, W);
        case 'Integer':
            return rA(Y, Q, W);
        case 'Intersect':
            return tA(Y, Q, W);
        case 'Iterator':
            return aA(Y, Q, W);
        case 'Literal':
            return sA(Y, Q, W);
        case 'Never':
            return eA(Y, Q, W);
        case 'Not':
            return $P(Y, Q, W);
        case 'Null':
            return XP(Y, Q, W);
        case 'Number':
            return WP(Y, Q, W);
        case 'Object':
            return YP(Y, Q, W);
        case 'Promise':
            return QP(Y, Q, W);
        case 'Record':
            return JP(Y, Q, W);
        case 'Ref':
            return UP(Y, Q, W);
        case 'RegExp':
            return NP(Y, Q, W);
        case 'String':
            return MP(Y, Q, W);
        case 'Symbol':
            return GP(Y, Q, W);
        case 'TemplateLiteral':
            return zP(Y, Q, W);
        case 'This':
            return ZP(Y, Q, W);
        case 'Tuple':
            return wP(Y, Q, W);
        case 'Undefined':
            return DP(Y, Q, W);
        case 'Union':
            return BP(Y, Q, W);
        case 'Uint8Array':
            return OP(Y, Q, W);
        case 'Unknown':
            return HP(Y, Q, W);
        case 'Void':
            return qP(Y, Q, W);
        default:
            if (!Z6.Has(Y[S])) throw new qG(Y);
            return AP(Y, Q, W);
    }
}
function Q$(...$) {
    return $.length === 3 ? H6($[0], $[1], $[2]) : H6($[0], [], $[1]);
}
var _;
(function ($) {
    ($[($.ArrayContains = 0)] = 'ArrayContains'),
        ($[($.ArrayMaxContains = 1)] = 'ArrayMaxContains'),
        ($[($.ArrayMaxItems = 2)] = 'ArrayMaxItems'),
        ($[($.ArrayMinContains = 3)] = 'ArrayMinContains'),
        ($[($.ArrayMinItems = 4)] = 'ArrayMinItems'),
        ($[($.ArrayUniqueItems = 5)] = 'ArrayUniqueItems'),
        ($[($.Array = 6)] = 'Array'),
        ($[($.AsyncIterator = 7)] = 'AsyncIterator'),
        ($[($.BigIntExclusiveMaximum = 8)] = 'BigIntExclusiveMaximum'),
        ($[($.BigIntExclusiveMinimum = 9)] = 'BigIntExclusiveMinimum'),
        ($[($.BigIntMaximum = 10)] = 'BigIntMaximum'),
        ($[($.BigIntMinimum = 11)] = 'BigIntMinimum'),
        ($[($.BigIntMultipleOf = 12)] = 'BigIntMultipleOf'),
        ($[($.BigInt = 13)] = 'BigInt'),
        ($[($.Boolean = 14)] = 'Boolean'),
        ($[($.DateExclusiveMaximumTimestamp = 15)] =
            'DateExclusiveMaximumTimestamp'),
        ($[($.DateExclusiveMinimumTimestamp = 16)] =
            'DateExclusiveMinimumTimestamp'),
        ($[($.DateMaximumTimestamp = 17)] = 'DateMaximumTimestamp'),
        ($[($.DateMinimumTimestamp = 18)] = 'DateMinimumTimestamp'),
        ($[($.DateMultipleOfTimestamp = 19)] = 'DateMultipleOfTimestamp'),
        ($[($.Date = 20)] = 'Date'),
        ($[($.Function = 21)] = 'Function'),
        ($[($.IntegerExclusiveMaximum = 22)] = 'IntegerExclusiveMaximum'),
        ($[($.IntegerExclusiveMinimum = 23)] = 'IntegerExclusiveMinimum'),
        ($[($.IntegerMaximum = 24)] = 'IntegerMaximum'),
        ($[($.IntegerMinimum = 25)] = 'IntegerMinimum'),
        ($[($.IntegerMultipleOf = 26)] = 'IntegerMultipleOf'),
        ($[($.Integer = 27)] = 'Integer'),
        ($[($.IntersectUnevaluatedProperties = 28)] =
            'IntersectUnevaluatedProperties'),
        ($[($.Intersect = 29)] = 'Intersect'),
        ($[($.Iterator = 30)] = 'Iterator'),
        ($[($.Kind = 31)] = 'Kind'),
        ($[($.Literal = 32)] = 'Literal'),
        ($[($.Never = 33)] = 'Never'),
        ($[($.Not = 34)] = 'Not'),
        ($[($.Null = 35)] = 'Null'),
        ($[($.NumberExclusiveMaximum = 36)] = 'NumberExclusiveMaximum'),
        ($[($.NumberExclusiveMinimum = 37)] = 'NumberExclusiveMinimum'),
        ($[($.NumberMaximum = 38)] = 'NumberMaximum'),
        ($[($.NumberMinimum = 39)] = 'NumberMinimum'),
        ($[($.NumberMultipleOf = 40)] = 'NumberMultipleOf'),
        ($[($.Number = 41)] = 'Number'),
        ($[($.ObjectAdditionalProperties = 42)] = 'ObjectAdditionalProperties'),
        ($[($.ObjectMaxProperties = 43)] = 'ObjectMaxProperties'),
        ($[($.ObjectMinProperties = 44)] = 'ObjectMinProperties'),
        ($[($.ObjectRequiredProperty = 45)] = 'ObjectRequiredProperty'),
        ($[($.Object = 46)] = 'Object'),
        ($[($.Promise = 47)] = 'Promise'),
        ($[($.RegExp = 48)] = 'RegExp'),
        ($[($.StringFormatUnknown = 49)] = 'StringFormatUnknown'),
        ($[($.StringFormat = 50)] = 'StringFormat'),
        ($[($.StringMaxLength = 51)] = 'StringMaxLength'),
        ($[($.StringMinLength = 52)] = 'StringMinLength'),
        ($[($.StringPattern = 53)] = 'StringPattern'),
        ($[($.String = 54)] = 'String'),
        ($[($.Symbol = 55)] = 'Symbol'),
        ($[($.TupleLength = 56)] = 'TupleLength'),
        ($[($.Tuple = 57)] = 'Tuple'),
        ($[($.Uint8ArrayMaxByteLength = 58)] = 'Uint8ArrayMaxByteLength'),
        ($[($.Uint8ArrayMinByteLength = 59)] = 'Uint8ArrayMinByteLength'),
        ($[($.Uint8Array = 60)] = 'Uint8Array'),
        ($[($.Undefined = 61)] = 'Undefined'),
        ($[($.Union = 62)] = 'Union'),
        ($[($.Void = 63)] = 'Void');
})(_ || (_ = {}));
class AG extends r {
    constructor($) {
        super('Unknown type');
        this.schema = $;
    }
}
function I1($) {
    return $.replace(/~/g, '~0').replace(/\//g, '~1');
}
function M$($) {
    return $ !== void 0;
}
class I0 {
    constructor($) {
        this.iterator = $;
    }
    [Symbol.iterator]() {
        return this.iterator;
    }
    First() {
        let $ = this.iterator.next();
        return $.done ? void 0 : $.value;
    }
}
function d($, X, W, Q, Y = []) {
    return {
        type: $,
        schema: X,
        path: W,
        value: Q,
        message: ZG()({
            errorType: $,
            path: W,
            schema: X,
            value: Q,
            errors: Y,
        }),
        errors: Y,
    };
}
function* PP($, X, W, Q) {}
function* SP($, X, W, Q) {}
function* jP($, X, W, Q) {
    if (!a(Q)) return yield d(_.Array, $, W, Q);
    if (M$($.minItems) && !(Q.length >= $.minItems))
        yield d(_.ArrayMinItems, $, W, Q);
    if (M$($.maxItems) && !(Q.length <= $.maxItems))
        yield d(_.ArrayMaxItems, $, W, Q);
    for (let U = 0; U < Q.length; U++) yield* q6($.items, X, `${W}/${U}`, Q[U]);
    if (
        $.uniqueItems === !0 &&
        !(function () {
            let U = new Set();
            for (let N of Q) {
                let M = W0(N);
                if (U.has(M)) return !1;
                else U.add(M);
            }
            return !0;
        })()
    )
        yield d(_.ArrayUniqueItems, $, W, Q);
    if (!(M$($.contains) || M$($.minContains) || M$($.maxContains))) return;
    let Y = M$($.contains) ? $.contains : Y$(),
        J = Q.reduce(
            (U, N, M) =>
                q6(Y, X, `${W}${M}`, N).next().done === !0 ? U + 1 : U,
            0,
        );
    if (J === 0) yield d(_.ArrayContains, $, W, Q);
    if (l($.minContains) && J < $.minContains)
        yield d(_.ArrayMinContains, $, W, Q);
    if (l($.maxContains) && J > $.maxContains)
        yield d(_.ArrayMaxContains, $, W, Q);
}
function* LP($, X, W, Q) {
    if (!BY(Q)) yield d(_.AsyncIterator, $, W, Q);
}
function* KP($, X, W, Q) {
    if (!K6(Q)) return yield d(_.BigInt, $, W, Q);
    if (M$($.exclusiveMaximum) && !(Q < $.exclusiveMaximum))
        yield d(_.BigIntExclusiveMaximum, $, W, Q);
    if (M$($.exclusiveMinimum) && !(Q > $.exclusiveMinimum))
        yield d(_.BigIntExclusiveMinimum, $, W, Q);
    if (M$($.maximum) && !(Q <= $.maximum)) yield d(_.BigIntMaximum, $, W, Q);
    if (M$($.minimum) && !(Q >= $.minimum)) yield d(_.BigIntMinimum, $, W, Q);
    if (M$($.multipleOf) && Q % $.multipleOf !== BigInt(0))
        yield d(_.BigIntMultipleOf, $, W, Q);
}
function* _P($, X, W, Q) {
    if (!$1(Q)) yield d(_.Boolean, $, W, Q);
}
function* FP($, X, W, Q) {
    yield* q6($.returns, X, W, Q.prototype);
}
function* IP($, X, W, Q) {
    if (!v6(Q)) return yield d(_.Date, $, W, Q);
    if (
        M$($.exclusiveMaximumTimestamp) &&
        !(Q.getTime() < $.exclusiveMaximumTimestamp)
    )
        yield d(_.DateExclusiveMaximumTimestamp, $, W, Q);
    if (
        M$($.exclusiveMinimumTimestamp) &&
        !(Q.getTime() > $.exclusiveMinimumTimestamp)
    )
        yield d(_.DateExclusiveMinimumTimestamp, $, W, Q);
    if (M$($.maximumTimestamp) && !(Q.getTime() <= $.maximumTimestamp))
        yield d(_.DateMaximumTimestamp, $, W, Q);
    if (M$($.minimumTimestamp) && !(Q.getTime() >= $.minimumTimestamp))
        yield d(_.DateMinimumTimestamp, $, W, Q);
    if (M$($.multipleOfTimestamp) && Q.getTime() % $.multipleOfTimestamp !== 0)
        yield d(_.DateMultipleOfTimestamp, $, W, Q);
}
function* CP($, X, W, Q) {
    if (!p1(Q)) yield d(_.Function, $, W, Q);
}
function* RP($, X, W, Q) {
    let Y = globalThis.Object.values($.$defs),
        J = $.$defs[$.$ref];
    yield* q6(J, [...X, ...Y], W, Q);
}
function* VP($, X, W, Q) {
    if (!qY(Q)) return yield d(_.Integer, $, W, Q);
    if (M$($.exclusiveMaximum) && !(Q < $.exclusiveMaximum))
        yield d(_.IntegerExclusiveMaximum, $, W, Q);
    if (M$($.exclusiveMinimum) && !(Q > $.exclusiveMinimum))
        yield d(_.IntegerExclusiveMinimum, $, W, Q);
    if (M$($.maximum) && !(Q <= $.maximum)) yield d(_.IntegerMaximum, $, W, Q);
    if (M$($.minimum) && !(Q >= $.minimum)) yield d(_.IntegerMinimum, $, W, Q);
    if (M$($.multipleOf) && Q % $.multipleOf !== 0)
        yield d(_.IntegerMultipleOf, $, W, Q);
}
function* EP($, X, W, Q) {
    let Y = !1;
    for (let J of $.allOf) for (let U of q6(J, X, W, Q)) (Y = !0), yield U;
    if (Y) return yield d(_.Intersect, $, W, Q);
    if ($.unevaluatedProperties === !1) {
        let J = new RegExp(K1($));
        for (let U of Object.getOwnPropertyNames(Q))
            if (!J.test(U))
                yield d(_.IntersectUnevaluatedProperties, $, `${W}/${U}`, Q);
    }
    if (typeof $.unevaluatedProperties === 'object') {
        let J = new RegExp(K1($));
        for (let U of Object.getOwnPropertyNames(Q))
            if (!J.test(U)) {
                let N = q6(
                    $.unevaluatedProperties,
                    X,
                    `${W}/${U}`,
                    Q[U],
                ).next();
                if (!N.done) yield N.value;
            }
    }
}
function* xP($, X, W, Q) {
    if (!OY(Q)) yield d(_.Iterator, $, W, Q);
}
function* bP($, X, W, Q) {
    if (Q !== $.const) yield d(_.Literal, $, W, Q);
}
function* gP($, X, W, Q) {
    yield d(_.Never, $, W, Q);
}
function* TP($, X, W, Q) {
    if (q6($.not, X, W, Q).next().done === !0) yield d(_.Not, $, W, Q);
}
function* kP($, X, W, Q) {
    if (!H1(Q)) yield d(_.Null, $, W, Q);
}
function* vP($, X, W, Q) {
    if (!k$.IsNumberLike(Q)) return yield d(_.Number, $, W, Q);
    if (M$($.exclusiveMaximum) && !(Q < $.exclusiveMaximum))
        yield d(_.NumberExclusiveMaximum, $, W, Q);
    if (M$($.exclusiveMinimum) && !(Q > $.exclusiveMinimum))
        yield d(_.NumberExclusiveMinimum, $, W, Q);
    if (M$($.maximum) && !(Q <= $.maximum)) yield d(_.NumberMaximum, $, W, Q);
    if (M$($.minimum) && !(Q >= $.minimum)) yield d(_.NumberMinimum, $, W, Q);
    if (M$($.multipleOf) && Q % $.multipleOf !== 0)
        yield d(_.NumberMultipleOf, $, W, Q);
}
function* fP($, X, W, Q) {
    if (!k$.IsObjectLike(Q)) return yield d(_.Object, $, W, Q);
    if (
        M$($.minProperties) &&
        !(Object.getOwnPropertyNames(Q).length >= $.minProperties)
    )
        yield d(_.ObjectMinProperties, $, W, Q);
    if (
        M$($.maxProperties) &&
        !(Object.getOwnPropertyNames(Q).length <= $.maxProperties)
    )
        yield d(_.ObjectMaxProperties, $, W, Q);
    let Y = Array.isArray($.required) ? $.required : [],
        J = Object.getOwnPropertyNames($.properties),
        U = Object.getOwnPropertyNames(Q);
    for (let N of Y) {
        if (U.includes(N)) continue;
        yield d(
            _.ObjectRequiredProperty,
            $.properties[N],
            `${W}/${I1(N)}`,
            void 0,
        );
    }
    if ($.additionalProperties === !1) {
        for (let N of U)
            if (!J.includes(N))
                yield d(_.ObjectAdditionalProperties, $, `${W}/${I1(N)}`, Q[N]);
    }
    if (typeof $.additionalProperties === 'object')
        for (let N of U) {
            if (J.includes(N)) continue;
            yield* q6($.additionalProperties, X, `${W}/${I1(N)}`, Q[N]);
        }
    for (let N of J) {
        let M = $.properties[N];
        if ($.required && $.required.includes(N)) {
            if ((yield* q6(M, X, `${W}/${I1(N)}`, Q[N]), _1($) && !(N in Q)))
                yield d(_.ObjectRequiredProperty, M, `${W}/${I1(N)}`, void 0);
        } else if (k$.IsExactOptionalProperty(Q, N))
            yield* q6(M, X, `${W}/${I1(N)}`, Q[N]);
    }
}
function* yP($, X, W, Q) {
    if (!HY(Q)) yield d(_.Promise, $, W, Q);
}
function* hP($, X, W, Q) {
    if (!k$.IsRecordLike(Q)) return yield d(_.Object, $, W, Q);
    if (
        M$($.minProperties) &&
        !(Object.getOwnPropertyNames(Q).length >= $.minProperties)
    )
        yield d(_.ObjectMinProperties, $, W, Q);
    if (
        M$($.maxProperties) &&
        !(Object.getOwnPropertyNames(Q).length <= $.maxProperties)
    )
        yield d(_.ObjectMaxProperties, $, W, Q);
    let [Y, J] = Object.entries($.patternProperties)[0],
        U = new RegExp(Y);
    for (let [N, M] of Object.entries(Q))
        if (U.test(N)) yield* q6(J, X, `${W}/${I1(N)}`, M);
    if (typeof $.additionalProperties === 'object') {
        for (let [N, M] of Object.entries(Q))
            if (!U.test(N))
                yield* q6($.additionalProperties, X, `${W}/${I1(N)}`, M);
    }
    if ($.additionalProperties === !1)
        for (let [N, M] of Object.entries(Q)) {
            if (U.test(N)) continue;
            return yield d(_.ObjectAdditionalProperties, $, `${W}/${I1(N)}`, M);
        }
}
function* mP($, X, W, Q) {
    yield* q6(B$($, X), X, W, Q);
}
function* cP($, X, W, Q) {
    if (!w$(Q)) return yield d(_.String, $, W, Q);
    if (M$($.minLength) && !(Q.length >= $.minLength))
        yield d(_.StringMinLength, $, W, Q);
    if (M$($.maxLength) && !(Q.length <= $.maxLength))
        yield d(_.StringMaxLength, $, W, Q);
    if (!new RegExp($.source, $.flags).test(Q))
        return yield d(_.RegExp, $, W, Q);
}
function* uP($, X, W, Q) {
    if (!w$(Q)) return yield d(_.String, $, W, Q);
    if (M$($.minLength) && !(Q.length >= $.minLength))
        yield d(_.StringMinLength, $, W, Q);
    if (M$($.maxLength) && !(Q.length <= $.maxLength))
        yield d(_.StringMaxLength, $, W, Q);
    if (w$($.pattern)) {
        if (!new RegExp($.pattern).test(Q)) yield d(_.StringPattern, $, W, Q);
    }
    if (w$($.format)) {
        if (!_$.Has($.format)) yield d(_.StringFormatUnknown, $, W, Q);
        else if (!_$.Get($.format)(Q)) yield d(_.StringFormat, $, W, Q);
    }
}
function* dP($, X, W, Q) {
    if (!q1(Q)) yield d(_.Symbol, $, W, Q);
}
function* iP($, X, W, Q) {
    if (!w$(Q)) return yield d(_.String, $, W, Q);
    if (!new RegExp($.pattern).test(Q)) yield d(_.StringPattern, $, W, Q);
}
function* nP($, X, W, Q) {
    yield* q6(B$($, X), X, W, Q);
}
function* pP($, X, W, Q) {
    if (!a(Q)) return yield d(_.Tuple, $, W, Q);
    if ($.items === void 0 && Q.length !== 0)
        return yield d(_.TupleLength, $, W, Q);
    if (Q.length !== $.maxItems) return yield d(_.TupleLength, $, W, Q);
    if (!$.items) return;
    for (let Y = 0; Y < $.items.length; Y++)
        yield* q6($.items[Y], X, `${W}/${Y}`, Q[Y]);
}
function* lP($, X, W, Q) {
    if (!c$(Q)) yield d(_.Undefined, $, W, Q);
}
function* oP($, X, W, Q) {
    if (Q$($, X, Q)) return;
    let Y = $.anyOf.map((J) => new I0(q6(J, X, W, Q)));
    yield d(_.Union, $, W, Q, Y);
}
function* rP($, X, W, Q) {
    if (!l0(Q)) return yield d(_.Uint8Array, $, W, Q);
    if (M$($.maxByteLength) && !(Q.length <= $.maxByteLength))
        yield d(_.Uint8ArrayMaxByteLength, $, W, Q);
    if (M$($.minByteLength) && !(Q.length >= $.minByteLength))
        yield d(_.Uint8ArrayMinByteLength, $, W, Q);
}
function* tP($, X, W, Q) {}
function* aP($, X, W, Q) {
    if (!k$.IsVoidLike(Q)) yield d(_.Void, $, W, Q);
}
function* sP($, X, W, Q) {
    if (!Z6.Get($[S])($, Q)) yield d(_.Kind, $, W, Q);
}
function* q6($, X, W, Q) {
    let Y = M$($.$id) ? [...X, $] : X,
        J = $;
    switch (J[S]) {
        case 'Any':
            return yield* PP(J, Y, W, Q);
        case 'Argument':
            return yield* SP(J, Y, W, Q);
        case 'Array':
            return yield* jP(J, Y, W, Q);
        case 'AsyncIterator':
            return yield* LP(J, Y, W, Q);
        case 'BigInt':
            return yield* KP(J, Y, W, Q);
        case 'Boolean':
            return yield* _P(J, Y, W, Q);
        case 'Constructor':
            return yield* FP(J, Y, W, Q);
        case 'Date':
            return yield* IP(J, Y, W, Q);
        case 'Function':
            return yield* CP(J, Y, W, Q);
        case 'Import':
            return yield* RP(J, Y, W, Q);
        case 'Integer':
            return yield* VP(J, Y, W, Q);
        case 'Intersect':
            return yield* EP(J, Y, W, Q);
        case 'Iterator':
            return yield* xP(J, Y, W, Q);
        case 'Literal':
            return yield* bP(J, Y, W, Q);
        case 'Never':
            return yield* gP(J, Y, W, Q);
        case 'Not':
            return yield* TP(J, Y, W, Q);
        case 'Null':
            return yield* kP(J, Y, W, Q);
        case 'Number':
            return yield* vP(J, Y, W, Q);
        case 'Object':
            return yield* fP(J, Y, W, Q);
        case 'Promise':
            return yield* yP(J, Y, W, Q);
        case 'Record':
            return yield* hP(J, Y, W, Q);
        case 'Ref':
            return yield* mP(J, Y, W, Q);
        case 'RegExp':
            return yield* cP(J, Y, W, Q);
        case 'String':
            return yield* uP(J, Y, W, Q);
        case 'Symbol':
            return yield* dP(J, Y, W, Q);
        case 'TemplateLiteral':
            return yield* iP(J, Y, W, Q);
        case 'This':
            return yield* nP(J, Y, W, Q);
        case 'Tuple':
            return yield* pP(J, Y, W, Q);
        case 'Undefined':
            return yield* lP(J, Y, W, Q);
        case 'Union':
            return yield* oP(J, Y, W, Q);
        case 'Uint8Array':
            return yield* rP(J, Y, W, Q);
        case 'Unknown':
            return yield* tP(J, Y, W, Q);
        case 'Void':
            return yield* aP(J, Y, W, Q);
        default:
            if (!Z6.Has(J[S])) throw new AG($);
            return yield* sP(J, Y, W, Q);
    }
}
function Y1(...$) {
    let X = $.length === 3 ? q6($[0], $[1], '', $[2]) : q6($[0], [], '', $[1]);
    return new I0(X);
}
var eP = function ($, X, W, Q, Y) {
        if (Q === 'm') throw new TypeError('Private method is not writable');
        if (Q === 'a' && !Y)
            throw new TypeError(
                'Private accessor was defined without a setter',
            );
        if (typeof X === 'function' ? $ !== X || !Y : !X.has($))
            throw new TypeError(
                'Cannot write private member to an object whose class did not declare it',
            );
        return Q === 'a' ? Y.call($, W) : Y ? (Y.value = W) : X.set($, W), W;
    },
    SG = function ($, X, W, Q) {
        if (W === 'a' && !Q)
            throw new TypeError(
                'Private accessor was defined without a getter',
            );
        if (typeof X === 'function' ? $ !== X || !Q : !X.has($))
            throw new TypeError(
                'Cannot read private member from an object whose class did not declare it',
            );
        return W === 'm' ? Q : W === 'a' ? Q.call($) : Q ? Q.value : X.get($);
    },
    zJ,
    mY,
    jG;
class LG extends r {
    constructor($) {
        let X = $.First();
        super(X === void 0 ? 'Invalid Value' : X.message);
        zJ.add(this),
            mY.set(this, void 0),
            eP(this, mY, $, 'f'),
            (this.error = X);
    }
    Errors() {
        return new I0(SG(this, zJ, 'm', jG).call(this));
    }
}
(mY = new WeakMap()),
    (zJ = new WeakSet()),
    (jG = function* $() {
        if (this.error) yield this.error;
        yield* SG(this, mY, 'f');
    });
function PG($, X, W) {
    if (Q$($, X, W)) return;
    throw new LG(Y1($, X, W));
}
function cY(...$) {
    return $.length === 3 ? PG($[0], $[1], $[2]) : PG($[0], [], $[1]);
}
function $S($) {
    let X = {};
    for (let W of Object.getOwnPropertyNames($)) X[W] = H$($[W]);
    for (let W of Object.getOwnPropertySymbols($)) X[W] = H$($[W]);
    return X;
}
function XS($) {
    return $.map((X) => H$(X));
}
function WS($) {
    return $.slice();
}
function YS($) {
    return new Map(H$([...$.entries()]));
}
function QS($) {
    return new Set(H$([...$.entries()]));
}
function JS($) {
    return new Date($.toISOString());
}
function US($) {
    return $;
}
function H$($) {
    if (a($)) return XS($);
    if (v6($)) return JS($);
    if (P4($)) return WS($);
    if (d9($)) return YS($);
    if (i9($)) return QS($);
    if (X$($)) return $S($);
    if (J4($)) return US($);
    throw new Error('ValueClone: Unable to clone value');
}
class C4 extends r {
    constructor($, X) {
        super(X);
        this.schema = $;
    }
}
function q$($) {
    return p1($) ? $() : H$($);
}
function NS($, X) {
    if (t($, 'default')) return q$($.default);
    else return {};
}
function MS($, X) {
    return {};
}
function GS($, X) {
    if ($.uniqueItems === !0 && !t($, 'default'))
        throw new C4(
            $,
            'Array with the uniqueItems constraint requires a default value',
        );
    else if ('contains' in $ && !t($, 'default'))
        throw new C4(
            $,
            'Array with the contains constraint requires a default value',
        );
    else if ('default' in $) return q$($.default);
    else if ($.minItems !== void 0)
        return Array.from({ length: $.minItems }).map((W) => {
            return w4($.items, X);
        });
    else return [];
}
function zS($, X) {
    if (t($, 'default')) return q$($.default);
    else return (async function* () {})();
}
function ZS($, X) {
    if (t($, 'default')) return q$($.default);
    else return BigInt(0);
}
function wS($, X) {
    if (t($, 'default')) return q$($.default);
    else return !1;
}
function DS($, X) {
    if (t($, 'default')) return q$($.default);
    else {
        let W = w4($.returns, X);
        if (typeof W === 'object' && !Array.isArray(W))
            return class {
                constructor() {
                    for (let [Q, Y] of Object.entries(W)) {
                        let J = this;
                        J[Q] = Y;
                    }
                }
            };
        else return class {};
    }
}
function BS($, X) {
    if (t($, 'default')) return q$($.default);
    else if ($.minimumTimestamp !== void 0) return new Date($.minimumTimestamp);
    else return new Date();
}
function OS($, X) {
    if (t($, 'default')) return q$($.default);
    else return () => w4($.returns, X);
}
function HS($, X) {
    let W = globalThis.Object.values($.$defs),
        Q = $.$defs[$.$ref];
    return w4(Q, [...X, ...W]);
}
function qS($, X) {
    if (t($, 'default')) return q$($.default);
    else if ($.minimum !== void 0) return $.minimum;
    else return 0;
}
function AS($, X) {
    if (t($, 'default')) return q$($.default);
    else {
        let W = $.allOf.reduce((Q, Y) => {
            let J = w4(Y, X);
            return typeof J === 'object' ? { ...Q, ...J } : J;
        }, {});
        if (!Q$($, X, W))
            throw new C4(
                $,
                'Intersect produced invalid value. Consider using a default value.',
            );
        return W;
    }
}
function PS($, X) {
    if (t($, 'default')) return q$($.default);
    else return (function* () {})();
}
function SS($, X) {
    if (t($, 'default')) return q$($.default);
    else return $.const;
}
function jS($, X) {
    if (t($, 'default')) return q$($.default);
    else
        throw new C4(
            $,
            'Never types cannot be created. Consider using a default value.',
        );
}
function LS($, X) {
    if (t($, 'default')) return q$($.default);
    else throw new C4($, 'Not types must have a default value');
}
function KS($, X) {
    if (t($, 'default')) return q$($.default);
    else return null;
}
function _S($, X) {
    if (t($, 'default')) return q$($.default);
    else if ($.minimum !== void 0) return $.minimum;
    else return 0;
}
function FS($, X) {
    if (t($, 'default')) return q$($.default);
    else {
        let W = new Set($.required),
            Q = {};
        for (let [Y, J] of Object.entries($.properties)) {
            if (!W.has(Y)) continue;
            Q[Y] = w4(J, X);
        }
        return Q;
    }
}
function IS($, X) {
    if (t($, 'default')) return q$($.default);
    else return Promise.resolve(w4($.item, X));
}
function CS($, X) {
    if (t($, 'default')) return q$($.default);
    else return {};
}
function RS($, X) {
    if (t($, 'default')) return q$($.default);
    else return w4(B$($, X), X);
}
function VS($, X) {
    if (t($, 'default')) return q$($.default);
    else
        throw new C4(
            $,
            'RegExp types cannot be created. Consider using a default value.',
        );
}
function ES($, X) {
    if ($.pattern !== void 0)
        if (!t($, 'default'))
            throw new C4(
                $,
                'String types with patterns must specify a default value',
            );
        else return q$($.default);
    else if ($.format !== void 0)
        if (!t($, 'default'))
            throw new C4(
                $,
                'String types with formats must specify a default value',
            );
        else return q$($.default);
    else if (t($, 'default')) return q$($.default);
    else if ($.minLength !== void 0)
        return Array.from({ length: $.minLength })
            .map(() => ' ')
            .join('');
    else return '';
}
function xS($, X) {
    if (t($, 'default')) return q$($.default);
    else if ('value' in $) return Symbol.for($.value);
    else return Symbol();
}
function bS($, X) {
    if (t($, 'default')) return q$($.default);
    if (!jY($))
        throw new C4(
            $,
            'Can only create template literals that produce a finite variants. Consider using a default value.',
        );
    return WX($)[0];
}
function gS($, X) {
    if (KG++ > cS)
        throw new C4(
            $,
            'Cannot create recursive type as it appears possibly infinite. Consider using a default.',
        );
    if (t($, 'default')) return q$($.default);
    else return w4(B$($, X), X);
}
function TS($, X) {
    if (t($, 'default')) return q$($.default);
    if ($.items === void 0) return [];
    else
        return Array.from({ length: $.minItems }).map((W, Q) =>
            w4($.items[Q], X),
        );
}
function kS($, X) {
    if (t($, 'default')) return q$($.default);
    else return;
}
function vS($, X) {
    if (t($, 'default')) return q$($.default);
    else if ($.anyOf.length === 0)
        throw new Error(
            'ValueCreate.Union: Cannot create Union with zero variants',
        );
    else return w4($.anyOf[0], X);
}
function fS($, X) {
    if (t($, 'default')) return q$($.default);
    else if ($.minByteLength !== void 0) return new Uint8Array($.minByteLength);
    else return new Uint8Array(0);
}
function yS($, X) {
    if (t($, 'default')) return q$($.default);
    else return {};
}
function hS($, X) {
    if (t($, 'default')) return q$($.default);
    else return;
}
function mS($, X) {
    if (t($, 'default')) return q$($.default);
    else throw new Error('User defined types must specify a default value');
}
function w4($, X) {
    let W = O6($, X),
        Q = $;
    switch (Q[S]) {
        case 'Any':
            return NS(Q, W);
        case 'Argument':
            return MS(Q, W);
        case 'Array':
            return GS(Q, W);
        case 'AsyncIterator':
            return zS(Q, W);
        case 'BigInt':
            return ZS(Q, W);
        case 'Boolean':
            return wS(Q, W);
        case 'Constructor':
            return DS(Q, W);
        case 'Date':
            return BS(Q, W);
        case 'Function':
            return OS(Q, W);
        case 'Import':
            return HS(Q, W);
        case 'Integer':
            return qS(Q, W);
        case 'Intersect':
            return AS(Q, W);
        case 'Iterator':
            return PS(Q, W);
        case 'Literal':
            return SS(Q, W);
        case 'Never':
            return jS(Q, W);
        case 'Not':
            return LS(Q, W);
        case 'Null':
            return KS(Q, W);
        case 'Number':
            return _S(Q, W);
        case 'Object':
            return FS(Q, W);
        case 'Promise':
            return IS(Q, W);
        case 'Record':
            return CS(Q, W);
        case 'Ref':
            return RS(Q, W);
        case 'RegExp':
            return VS(Q, W);
        case 'String':
            return ES(Q, W);
        case 'Symbol':
            return xS(Q, W);
        case 'TemplateLiteral':
            return bS(Q, W);
        case 'This':
            return gS(Q, W);
        case 'Tuple':
            return TS(Q, W);
        case 'Undefined':
            return kS(Q, W);
        case 'Union':
            return vS(Q, W);
        case 'Uint8Array':
            return fS(Q, W);
        case 'Unknown':
            return yS(Q, W);
        case 'Void':
            return hS(Q, W);
        default:
            if (!Z6.Has(Q[S])) throw new C4(Q, 'Unknown type');
            return mS(Q, W);
    }
}
var cS = 512,
    KG = 0;
function d4(...$) {
    return (KG = 0), $.length === 2 ? w4($[0], $[1]) : w4($[0], []);
}
class ZJ extends r {
    constructor($, X) {
        super(X);
        this.schema = $;
    }
}
function _G($, X, W) {
    if ($[S] === 'Object' && typeof W === 'object' && !H1(W)) {
        let Q = $,
            Y = Object.getOwnPropertyNames(W),
            J = Object.entries(Q.properties),
            [U, N] = [1 / J.length, J.length];
        return J.reduce((M, [G, Z]) => {
            let B = Z[S] === 'Literal' && Z.const === W[G] ? N : 0,
                O = Q$(Z, X, W[G]) ? U : 0,
                w = Y.includes(G) ? U : 0;
            return M + (B + O + w);
        }, 0);
    } else if ($[S] === 'Union') {
        let Y = $.anyOf.map((J) => B$(J, X)).map((J) => _G(J, X, W));
        return Math.max(...Y);
    } else return Q$($, X, W) ? 1 : 0;
}
function uS($, X, W) {
    let Q = $.anyOf.map((U) => B$(U, X)),
        [Y, J] = [Q[0], 0];
    for (let U of Q) {
        let N = _G(U, X, W);
        if (N > J) (Y = U), (J = N);
    }
    return Y;
}
function dS($, X, W) {
    if ('default' in $)
        return typeof W === 'function' ? $.default : H$($.default);
    else {
        let Q = uS($, X, W);
        return WW(Q, X, W);
    }
}
function iS($, X, W) {
    return Q$($, X, W) ? H$(W) : d4($, X);
}
function nS($, X, W) {
    return Q$($, X, W) ? W : d4($, X);
}
function pS($, X, W) {
    if (Q$($, X, W)) return H$(W);
    let Q = a(W) ? H$(W) : d4($, X),
        Y =
            l($.minItems) && Q.length < $.minItems
                ? [
                      ...Q,
                      ...Array.from(
                          { length: $.minItems - Q.length },
                          () => null,
                      ),
                  ]
                : Q,
        U = (
            l($.maxItems) && Y.length > $.maxItems ? Y.slice(0, $.maxItems) : Y
        ).map((M) => i4($.items, X, M));
    if ($.uniqueItems !== !0) return U;
    let N = [...new Set(U)];
    if (!Q$($, X, N))
        throw new ZJ(
            $,
            'Array cast produced invalid data due to uniqueItems constraint',
        );
    return N;
}
function lS($, X, W) {
    if (Q$($, X, W)) return d4($, X);
    let Q = new Set($.returns.required || []),
        Y = function () {};
    for (let [J, U] of Object.entries($.returns.properties)) {
        if (!Q.has(J) && W.prototype[J] === void 0) continue;
        Y.prototype[J] = i4(U, X, W.prototype[J]);
    }
    return Y;
}
function oS($, X, W) {
    let Q = globalThis.Object.values($.$defs),
        Y = $.$defs[$.$ref];
    return i4(Y, [...X, ...Q], W);
}
function FG($, X) {
    if ((X$($) && !X$(X)) || (!X$($) && X$(X))) return $;
    if (!X$($) || !X$(X)) return X;
    return globalThis.Object.getOwnPropertyNames($).reduce((W, Q) => {
        let Y = Q in X ? FG($[Q], X[Q]) : $[Q];
        return { ...W, [Q]: Y };
    }, {});
}
function rS($, X, W) {
    if (Q$($, X, W)) return W;
    let Q = d4($, X),
        Y = FG(Q, W);
    return Q$($, X, Y) ? Y : Q;
}
function tS($, X, W) {
    throw new ZJ($, 'Never types cannot be cast');
}
function aS($, X, W) {
    if (Q$($, X, W)) return W;
    if (W === null || typeof W !== 'object') return d4($, X);
    let Q = new Set($.required || []),
        Y = {};
    for (let [J, U] of Object.entries($.properties)) {
        if (!Q.has(J) && W[J] === void 0) continue;
        Y[J] = i4(U, X, W[J]);
    }
    if (typeof $.additionalProperties === 'object') {
        let J = Object.getOwnPropertyNames($.properties);
        for (let U of Object.getOwnPropertyNames(W)) {
            if (J.includes(U)) continue;
            Y[U] = i4($.additionalProperties, X, W[U]);
        }
    }
    return Y;
}
function sS($, X, W) {
    if (Q$($, X, W)) return H$(W);
    if (
        W === null ||
        typeof W !== 'object' ||
        Array.isArray(W) ||
        W instanceof Date
    )
        return d4($, X);
    let Q = Object.getOwnPropertyNames($.patternProperties)[0],
        Y = $.patternProperties[Q],
        J = {};
    for (let [U, N] of Object.entries(W)) J[U] = i4(Y, X, N);
    return J;
}
function eS($, X, W) {
    return i4(B$($, X), X, W);
}
function $j($, X, W) {
    return i4(B$($, X), X, W);
}
function Xj($, X, W) {
    if (Q$($, X, W)) return H$(W);
    if (!a(W)) return d4($, X);
    if ($.items === void 0) return [];
    return $.items.map((Q, Y) => i4(Q, X, W[Y]));
}
function Wj($, X, W) {
    return Q$($, X, W) ? H$(W) : dS($, X, W);
}
function i4($, X, W) {
    let Q = w$($.$id) ? O6($, X) : X,
        Y = $;
    switch ($[S]) {
        case 'Array':
            return pS(Y, Q, W);
        case 'Constructor':
            return lS(Y, Q, W);
        case 'Import':
            return oS(Y, Q, W);
        case 'Intersect':
            return rS(Y, Q, W);
        case 'Never':
            return tS(Y, Q, W);
        case 'Object':
            return aS(Y, Q, W);
        case 'Record':
            return sS(Y, Q, W);
        case 'Ref':
            return eS(Y, Q, W);
        case 'This':
            return $j(Y, Q, W);
        case 'Tuple':
            return Xj(Y, Q, W);
        case 'Union':
            return Wj(Y, Q, W);
        case 'Date':
        case 'Symbol':
        case 'Uint8Array':
            return iS($, X, W);
        default:
            return nS(Y, Q, W);
    }
}
function WW(...$) {
    return $.length === 3 ? i4($[0], $[1], $[2]) : i4($[0], [], $[1]);
}
function Yj($) {
    return o1($) && $[S] !== 'Unsafe';
}
function Qj($, X, W) {
    if (!a(W)) return W;
    return W.map((Q) => l6($.items, X, Q));
}
function Jj($, X, W) {
    let Q = globalThis.Object.values($.$defs),
        Y = $.$defs[$.$ref];
    return l6(Y, [...X, ...Q], W);
}
function Uj($, X, W) {
    let Q = $.unevaluatedProperties,
        J = $.allOf
            .map((N) => l6(N, X, H$(W)))
            .reduce((N, M) => (X$(M) ? { ...N, ...M } : M), {});
    if (!X$(W) || !X$(J) || !o1(Q)) return J;
    let U = n6($);
    for (let N of Object.getOwnPropertyNames(W)) {
        if (U.includes(N)) continue;
        if (Q$(Q, X, W[N])) J[N] = l6(Q, X, W[N]);
    }
    return J;
}
function Nj($, X, W) {
    if (!X$(W) || a(W)) return W;
    let Q = $.additionalProperties;
    for (let Y of Object.getOwnPropertyNames(W)) {
        if (t($.properties, Y)) {
            W[Y] = l6($.properties[Y], X, W[Y]);
            continue;
        }
        if (o1(Q) && Q$(Q, X, W[Y])) {
            W[Y] = l6(Q, X, W[Y]);
            continue;
        }
        delete W[Y];
    }
    return W;
}
function Mj($, X, W) {
    if (!X$(W)) return W;
    let Q = $.additionalProperties,
        Y = Object.getOwnPropertyNames(W),
        [J, U] = Object.entries($.patternProperties)[0],
        N = new RegExp(J);
    for (let M of Y) {
        if (N.test(M)) {
            W[M] = l6(U, X, W[M]);
            continue;
        }
        if (o1(Q) && Q$(Q, X, W[M])) {
            W[M] = l6(Q, X, W[M]);
            continue;
        }
        delete W[M];
    }
    return W;
}
function Gj($, X, W) {
    return l6(B$($, X), X, W);
}
function zj($, X, W) {
    return l6(B$($, X), X, W);
}
function Zj($, X, W) {
    if (!a(W)) return W;
    if (c$($.items)) return [];
    let Q = Math.min(W.length, $.items.length);
    for (let Y = 0; Y < Q; Y++) W[Y] = l6($.items[Y], X, W[Y]);
    return W.length > Q ? W.slice(0, Q) : W;
}
function wj($, X, W) {
    for (let Q of $.anyOf) if (Yj(Q) && Q$(Q, X, W)) return l6(Q, X, W);
    return W;
}
function l6($, X, W) {
    let Q = w$($.$id) ? O6($, X) : X,
        Y = $;
    switch (Y[S]) {
        case 'Array':
            return Qj(Y, Q, W);
        case 'Import':
            return Jj(Y, Q, W);
        case 'Intersect':
            return Uj(Y, Q, W);
        case 'Object':
            return Nj(Y, Q, W);
        case 'Record':
            return Mj(Y, Q, W);
        case 'Ref':
            return Gj(Y, Q, W);
        case 'This':
            return zj(Y, Q, W);
        case 'Tuple':
            return Zj(Y, Q, W);
        case 'Union':
            return wj(Y, Q, W);
        default:
            return W;
    }
}
function uY(...$) {
    return $.length === 3 ? l6($[0], $[1], $[2]) : l6($[0], [], $[1]);
}
function dY($) {
    return w$($) && !isNaN($) && !isNaN(parseFloat($));
}
function Dj($) {
    return K6($) || $1($) || l($);
}
function YW($) {
    return (
        $ === !0 ||
        (l($) && $ === 1) ||
        (K6($) && $ === BigInt('1')) ||
        (w$($) && ($.toLowerCase() === 'true' || $ === '1'))
    );
}
function QW($) {
    return (
        $ === !1 ||
        (l($) && ($ === 0 || Object.is($, -0))) ||
        (K6($) && $ === BigInt('0')) ||
        (w$($) && ($.toLowerCase() === 'false' || $ === '0' || $ === '-0'))
    );
}
function Bj($) {
    return (
        w$($) &&
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
            $,
        )
    );
}
function Oj($) {
    return w$($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
}
function Hj($) {
    return (
        w$($) &&
        /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
            $,
        )
    );
}
function qj($) {
    return (
        w$($) &&
        /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(
            $,
        )
    );
}
function Aj($) {
    return w$($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
}
function Pj($, X) {
    let W = CG($);
    return W === X ? W : $;
}
function Sj($, X) {
    let W = RG($);
    return W === X ? W : $;
}
function jj($, X) {
    let W = IG($);
    return W === X ? W : $;
}
function Lj($, X) {
    return w$($.const)
        ? Pj(X, $.const)
        : l($.const)
          ? Sj(X, $.const)
          : $1($.const)
            ? jj(X, $.const)
            : X;
}
function IG($) {
    return YW($) ? !0 : QW($) ? !1 : $;
}
function Kj($) {
    let X = (W) => W.split('.')[0];
    return dY($)
        ? BigInt(X($))
        : l($)
          ? BigInt(Math.trunc($))
          : QW($)
            ? BigInt(0)
            : YW($)
              ? BigInt(1)
              : $;
}
function CG($) {
    return q1($) && $.description !== void 0
        ? $.description.toString()
        : Dj($)
          ? $.toString()
          : $;
}
function RG($) {
    return dY($) ? parseFloat($) : YW($) ? 1 : QW($) ? 0 : $;
}
function _j($) {
    return dY($)
        ? parseInt($)
        : l($)
          ? Math.trunc($)
          : YW($)
            ? 1
            : QW($)
              ? 0
              : $;
}
function Fj($) {
    return w$($) && $.toLowerCase() === 'null' ? null : $;
}
function Ij($) {
    return w$($) && $ === 'undefined' ? void 0 : $;
}
function Cj($) {
    return v6($)
        ? $
        : l($)
          ? new Date($)
          : YW($)
            ? new Date(1)
            : QW($)
              ? new Date(0)
              : dY($)
                ? new Date(parseInt($))
                : Oj($)
                  ? new Date(`1970-01-01T${$}.000Z`)
                  : Bj($)
                    ? new Date(`1970-01-01T${$}`)
                    : qj($)
                      ? new Date(`${$}.000Z`)
                      : Hj($)
                        ? new Date($)
                        : Aj($)
                          ? new Date(`${$}T00:00:00.000Z`)
                          : $;
}
function Rj($) {
    return $;
}
function Vj($, X, W) {
    return (a(W) ? W : [W]).map((Y) => n4($.items, X, Y));
}
function Ej($, X, W) {
    return Kj(W);
}
function xj($, X, W) {
    return IG(W);
}
function bj($, X, W) {
    return Cj(W);
}
function gj($, X, W) {
    let Q = globalThis.Object.values($.$defs),
        Y = $.$defs[$.$ref];
    return n4(Y, [...X, ...Q], W);
}
function Tj($, X, W) {
    return _j(W);
}
function kj($, X, W) {
    return $.allOf.reduce((Q, Y) => n4(Y, X, Q), W);
}
function vj($, X, W) {
    return Lj($, W);
}
function fj($, X, W) {
    return Fj(W);
}
function yj($, X, W) {
    return RG(W);
}
function hj($, X, W) {
    if (!X$(W)) return W;
    for (let Q of Object.getOwnPropertyNames($.properties)) {
        if (!t(W, Q)) continue;
        W[Q] = n4($.properties[Q], X, W[Q]);
    }
    return W;
}
function mj($, X, W) {
    if (!X$(W)) return W;
    let Y = Object.getOwnPropertyNames($.patternProperties)[0],
        J = $.patternProperties[Y];
    for (let [U, N] of Object.entries(W)) W[U] = n4(J, X, N);
    return W;
}
function cj($, X, W) {
    return n4(B$($, X), X, W);
}
function uj($, X, W) {
    return CG(W);
}
function dj($, X, W) {
    return w$(W) || l(W) ? Symbol(W) : W;
}
function ij($, X, W) {
    return n4(B$($, X), X, W);
}
function nj($, X, W) {
    if (!(a(W) && !c$($.items))) return W;
    return W.map((Y, J) => {
        return J < $.items.length ? n4($.items[J], X, Y) : Y;
    });
}
function pj($, X, W) {
    return Ij(W);
}
function lj($, X, W) {
    for (let Q of $.anyOf) {
        let Y = n4(Q, X, H$(W));
        if (!Q$(Q, X, Y)) continue;
        return Y;
    }
    return W;
}
function n4($, X, W) {
    let Q = O6($, X),
        Y = $;
    switch ($[S]) {
        case 'Array':
            return Vj(Y, Q, W);
        case 'BigInt':
            return Ej(Y, Q, W);
        case 'Boolean':
            return xj(Y, Q, W);
        case 'Date':
            return bj(Y, Q, W);
        case 'Import':
            return gj(Y, Q, W);
        case 'Integer':
            return Tj(Y, Q, W);
        case 'Intersect':
            return kj(Y, Q, W);
        case 'Literal':
            return vj(Y, Q, W);
        case 'Null':
            return fj(Y, Q, W);
        case 'Number':
            return yj(Y, Q, W);
        case 'Object':
            return hj(Y, Q, W);
        case 'Record':
            return mj(Y, Q, W);
        case 'Ref':
            return cj(Y, Q, W);
        case 'String':
            return uj(Y, Q, W);
        case 'Symbol':
            return dj(Y, Q, W);
        case 'This':
            return ij(Y, Q, W);
        case 'Tuple':
            return nj(Y, Q, W);
        case 'Undefined':
            return pj(Y, Q, W);
        case 'Union':
            return lj(Y, Q, W);
        default:
            return Rj(W);
    }
}
function iY(...$) {
    return $.length === 3 ? n4($[0], $[1], $[2]) : n4($[0], [], $[1]);
}
class JW extends r {
    constructor($, X, W) {
        super(
            'Unable to decode value as it does not match the expected schema',
        );
        (this.schema = $), (this.value = X), (this.error = W);
    }
}
class nY extends r {
    constructor($, X, W, Q) {
        super(Q instanceof Error ? Q.message : 'Unknown error');
        (this.schema = $), (this.path = X), (this.value = W), (this.error = Q);
    }
}
function p$($, X, W) {
    try {
        return P$($) ? $[R$].Decode(W) : W;
    } catch (Q) {
        throw new nY($, X, W, Q);
    }
}
function oj($, X, W, Q) {
    return a(Q)
        ? p$(
              $,
              W,
              Q.map((Y, J) => p4($.items, X, `${W}/${J}`, Y)),
          )
        : p$($, W, Q);
}
function rj($, X, W, Q) {
    if (!X$(Q) || J4(Q)) return p$($, W, Q);
    let Y = IY($),
        J = Y.map((Z) => Z[0]),
        U = { ...Q };
    for (let [Z, B] of Y) if (Z in U) U[Z] = p4(B, X, `${W}/${Z}`, U[Z]);
    if (!P$($.unevaluatedProperties)) return p$($, W, U);
    let N = Object.getOwnPropertyNames(U),
        M = $.unevaluatedProperties,
        G = { ...U };
    for (let Z of N) if (!J.includes(Z)) G[Z] = p$(M, `${W}/${Z}`, G[Z]);
    return p$($, W, G);
}
function tj($, X, W, Q) {
    let Y = globalThis.Object.values($.$defs),
        J = $.$defs[$.$ref],
        U = p4(J, [...X, ...Y], W, Q);
    return p$($, W, U);
}
function aj($, X, W, Q) {
    return p$($, W, p4($.not, X, W, Q));
}
function sj($, X, W, Q) {
    if (!X$(Q)) return p$($, W, Q);
    let Y = n6($),
        J = { ...Q };
    for (let G of Y) {
        if (!t(J, G)) continue;
        if (
            c$(J[G]) &&
            (!S1($.properties[G]) || k$.IsExactOptionalProperty(J, G))
        )
            continue;
        J[G] = p4($.properties[G], X, `${W}/${G}`, J[G]);
    }
    if (!n$($.additionalProperties)) return p$($, W, J);
    let U = Object.getOwnPropertyNames(J),
        N = $.additionalProperties,
        M = { ...J };
    for (let G of U) if (!Y.includes(G)) M[G] = p$(N, `${W}/${G}`, M[G]);
    return p$($, W, M);
}
function ej($, X, W, Q) {
    if (!X$(Q)) return p$($, W, Q);
    let Y = Object.getOwnPropertyNames($.patternProperties)[0],
        J = new RegExp(Y),
        U = { ...Q };
    for (let Z of Object.getOwnPropertyNames(Q))
        if (J.test(Z)) U[Z] = p4($.patternProperties[Y], X, `${W}/${Z}`, U[Z]);
    if (!n$($.additionalProperties)) return p$($, W, U);
    let N = Object.getOwnPropertyNames(U),
        M = $.additionalProperties,
        G = { ...U };
    for (let Z of N) if (!J.test(Z)) G[Z] = p$(M, `${W}/${Z}`, G[Z]);
    return p$($, W, G);
}
function $L($, X, W, Q) {
    let Y = B$($, X);
    return p$($, W, p4(Y, X, W, Q));
}
function XL($, X, W, Q) {
    let Y = B$($, X);
    return p$($, W, p4(Y, X, W, Q));
}
function WL($, X, W, Q) {
    return a(Q) && a($.items)
        ? p$(
              $,
              W,
              $.items.map((Y, J) => p4(Y, X, `${W}/${J}`, Q[J])),
          )
        : p$($, W, Q);
}
function YL($, X, W, Q) {
    for (let Y of $.anyOf) {
        if (!Q$(Y, X, Q)) continue;
        let J = p4(Y, X, W, Q);
        return p$($, W, J);
    }
    return p$($, W, Q);
}
function p4($, X, W, Q) {
    let Y = O6($, X),
        J = $;
    switch ($[S]) {
        case 'Array':
            return oj(J, Y, W, Q);
        case 'Import':
            return tj(J, Y, W, Q);
        case 'Intersect':
            return rj(J, Y, W, Q);
        case 'Not':
            return aj(J, Y, W, Q);
        case 'Object':
            return sj(J, Y, W, Q);
        case 'Record':
            return ej(J, Y, W, Q);
        case 'Ref':
            return $L(J, Y, W, Q);
        case 'Symbol':
            return p$(J, W, Q);
        case 'This':
            return XL(J, Y, W, Q);
        case 'Tuple':
            return WL(J, Y, W, Q);
        case 'Union':
            return YL(J, Y, W, Q);
        default:
            return p$(J, W, Q);
    }
}
function OX($, X, W) {
    return p4($, X, '', W);
}
class UW extends r {
    constructor($, X, W) {
        super('The encoded value does not match the expected schema');
        (this.schema = $), (this.value = X), (this.error = W);
    }
}
class VG extends r {
    constructor($, X, W, Q) {
        super(`${Q instanceof Error ? Q.message : 'Unknown error'}`);
        (this.schema = $), (this.path = X), (this.value = W), (this.error = Q);
    }
}
function _6($, X, W) {
    try {
        return P$($) ? $[R$].Encode(W) : W;
    } catch (Q) {
        throw new VG($, X, W, Q);
    }
}
function QL($, X, W, Q) {
    let Y = _6($, W, Q);
    return a(Y) ? Y.map((J, U) => l4($.items, X, `${W}/${U}`, J)) : Y;
}
function JL($, X, W, Q) {
    let Y = globalThis.Object.values($.$defs),
        J = $.$defs[$.$ref],
        U = _6($, W, Q);
    return l4(J, [...X, ...Y], W, U);
}
function UL($, X, W, Q) {
    let Y = _6($, W, Q);
    if (!X$(Q) || J4(Q)) return Y;
    let J = IY($),
        U = J.map((B) => B[0]),
        N = { ...Y };
    for (let [B, O] of J) if (B in N) N[B] = l4(O, X, `${W}/${B}`, N[B]);
    if (!P$($.unevaluatedProperties)) return N;
    let M = Object.getOwnPropertyNames(N),
        G = $.unevaluatedProperties,
        Z = { ...N };
    for (let B of M) if (!U.includes(B)) Z[B] = _6(G, `${W}/${B}`, Z[B]);
    return Z;
}
function NL($, X, W, Q) {
    return _6($.not, W, _6($, W, Q));
}
function ML($, X, W, Q) {
    let Y = _6($, W, Q);
    if (!X$(Y)) return Y;
    let J = n6($),
        U = { ...Y };
    for (let Z of J) {
        if (!t(U, Z)) continue;
        if (
            c$(U[Z]) &&
            (!S1($.properties[Z]) || k$.IsExactOptionalProperty(U, Z))
        )
            continue;
        U[Z] = l4($.properties[Z], X, `${W}/${Z}`, U[Z]);
    }
    if (!n$($.additionalProperties)) return U;
    let N = Object.getOwnPropertyNames(U),
        M = $.additionalProperties,
        G = { ...U };
    for (let Z of N) if (!J.includes(Z)) G[Z] = _6(M, `${W}/${Z}`, G[Z]);
    return G;
}
function GL($, X, W, Q) {
    let Y = _6($, W, Q);
    if (!X$(Q)) return Y;
    let J = Object.getOwnPropertyNames($.patternProperties)[0],
        U = new RegExp(J),
        N = { ...Y };
    for (let B of Object.getOwnPropertyNames(Q))
        if (U.test(B)) N[B] = l4($.patternProperties[J], X, `${W}/${B}`, N[B]);
    if (!n$($.additionalProperties)) return N;
    let M = Object.getOwnPropertyNames(N),
        G = $.additionalProperties,
        Z = { ...N };
    for (let B of M) if (!U.test(B)) Z[B] = _6(G, `${W}/${B}`, Z[B]);
    return Z;
}
function zL($, X, W, Q) {
    let Y = B$($, X),
        J = l4(Y, X, W, Q);
    return _6($, W, J);
}
function ZL($, X, W, Q) {
    let Y = B$($, X),
        J = l4(Y, X, W, Q);
    return _6($, W, J);
}
function wL($, X, W, Q) {
    let Y = _6($, W, Q);
    return a($.items) ? $.items.map((J, U) => l4(J, X, `${W}/${U}`, Y[U])) : [];
}
function DL($, X, W, Q) {
    for (let Y of $.anyOf) {
        if (!Q$(Y, X, Q)) continue;
        let J = l4(Y, X, W, Q);
        return _6($, W, J);
    }
    for (let Y of $.anyOf) {
        let J = l4(Y, X, W, Q);
        if (!Q$($, X, J)) continue;
        return _6($, W, J);
    }
    return _6($, W, Q);
}
function l4($, X, W, Q) {
    let Y = O6($, X),
        J = $;
    switch ($[S]) {
        case 'Array':
            return QL(J, Y, W, Q);
        case 'Import':
            return JL(J, Y, W, Q);
        case 'Intersect':
            return UL(J, Y, W, Q);
        case 'Not':
            return NL(J, Y, W, Q);
        case 'Object':
            return ML(J, Y, W, Q);
        case 'Record':
            return GL(J, Y, W, Q);
        case 'Ref':
            return zL(J, Y, W, Q);
        case 'This':
            return ZL(J, Y, W, Q);
        case 'Tuple':
            return wL(J, Y, W, Q);
        case 'Union':
            return DL(J, Y, W, Q);
        default:
            return _6(J, W, Q);
    }
}
function HX($, X, W) {
    return l4($, X, '', W);
}
function BL($, X) {
    return P$($) || w6($.items, X);
}
function OL($, X) {
    return P$($) || w6($.items, X);
}
function HL($, X) {
    return P$($) || w6($.returns, X) || $.parameters.some((W) => w6(W, X));
}
function qL($, X) {
    return P$($) || w6($.returns, X) || $.parameters.some((W) => w6(W, X));
}
function AL($, X) {
    return (
        P$($) || P$($.unevaluatedProperties) || $.allOf.some((W) => w6(W, X))
    );
}
function PL($, X) {
    let W = globalThis.Object.getOwnPropertyNames($.$defs).reduce(
            (Y, J) => [...Y, $.$defs[J]],
            [],
        ),
        Q = $.$defs[$.$ref];
    return P$($) || w6(Q, [...W, ...X]);
}
function SL($, X) {
    return P$($) || w6($.items, X);
}
function jL($, X) {
    return P$($) || w6($.not, X);
}
function LL($, X) {
    return (
        P$($) ||
        Object.values($.properties).some((W) => w6(W, X)) ||
        (n$($.additionalProperties) && w6($.additionalProperties, X))
    );
}
function KL($, X) {
    return P$($) || w6($.item, X);
}
function _L($, X) {
    let W = Object.getOwnPropertyNames($.patternProperties)[0],
        Q = $.patternProperties[W];
    return (
        P$($) ||
        w6(Q, X) ||
        (n$($.additionalProperties) && P$($.additionalProperties))
    );
}
function FL($, X) {
    if (P$($)) return !0;
    return w6(B$($, X), X);
}
function IL($, X) {
    if (P$($)) return !0;
    return w6(B$($, X), X);
}
function CL($, X) {
    return P$($) || (!c$($.items) && $.items.some((W) => w6(W, X)));
}
function RL($, X) {
    return P$($) || $.anyOf.some((W) => w6(W, X));
}
function w6($, X) {
    let W = O6($, X),
        Q = $;
    if ($.$id && wJ.has($.$id)) return !1;
    if ($.$id) wJ.add($.$id);
    switch ($[S]) {
        case 'Array':
            return BL(Q, W);
        case 'AsyncIterator':
            return OL(Q, W);
        case 'Constructor':
            return HL(Q, W);
        case 'Function':
            return qL(Q, W);
        case 'Import':
            return PL(Q, W);
        case 'Intersect':
            return AL(Q, W);
        case 'Iterator':
            return SL(Q, W);
        case 'Not':
            return jL(Q, W);
        case 'Object':
            return LL(Q, W);
        case 'Promise':
            return KL(Q, W);
        case 'Record':
            return _L(Q, W);
        case 'Ref':
            return FL(Q, W);
        case 'This':
            return IL(Q, W);
        case 'Tuple':
            return CL(Q, W);
        case 'Union':
            return RL(Q, W);
        default:
            return P$($);
    }
}
var wJ = new Set();
function C1($, X) {
    return wJ.clear(), w6($, X);
}
function EG(...$) {
    let [X, W, Q] = $.length === 3 ? [$[0], $[1], $[2]] : [$[0], [], $[1]];
    if (!Q$(X, W, Q)) throw new JW(X, Q, Y1(X, W, Q).First());
    return C1(X, W) ? OX(X, W, Q) : Q;
}
function R1($, X) {
    let W = t($, 'default') ? $.default : void 0,
        Q = p1(W) ? W() : H$(W);
    return c$(X) ? Q : X$(X) && X$(Q) ? Object.assign(Q, X) : X;
}
function DJ($) {
    return o1($) && 'default' in $;
}
function VL($, X, W) {
    if (a(W)) {
        for (let Y = 0; Y < W.length; Y++) W[Y] = y6($.items, X, W[Y]);
        return W;
    }
    let Q = R1($, W);
    if (!a(Q)) return Q;
    for (let Y = 0; Y < Q.length; Y++) Q[Y] = y6($.items, X, Q[Y]);
    return Q;
}
function EL($, X, W) {
    return v6(W) ? W : R1($, W);
}
function xL($, X, W) {
    let Q = globalThis.Object.values($.$defs),
        Y = $.$defs[$.$ref];
    return y6(Y, [...X, ...Q], W);
}
function bL($, X, W) {
    let Q = R1($, W);
    return $.allOf.reduce((Y, J) => {
        let U = y6(J, X, Q);
        return X$(U) ? { ...Y, ...U } : U;
    }, {});
}
function gL($, X, W) {
    let Q = R1($, W);
    if (!X$(Q)) return Q;
    let Y = Object.getOwnPropertyNames($.properties);
    for (let J of Y) {
        let U = y6($.properties[J], X, Q[J]);
        if (c$(U)) continue;
        Q[J] = y6($.properties[J], X, Q[J]);
    }
    if (!DJ($.additionalProperties)) return Q;
    for (let J of Object.getOwnPropertyNames(Q)) {
        if (Y.includes(J)) continue;
        Q[J] = y6($.additionalProperties, X, Q[J]);
    }
    return Q;
}
function TL($, X, W) {
    let Q = R1($, W);
    if (!X$(Q)) return Q;
    let Y = $.additionalProperties,
        [J, U] = Object.entries($.patternProperties)[0],
        N = new RegExp(J);
    for (let M of Object.getOwnPropertyNames(Q)) {
        if (!(N.test(M) && DJ(U))) continue;
        Q[M] = y6(U, X, Q[M]);
    }
    if (!DJ(Y)) return Q;
    for (let M of Object.getOwnPropertyNames(Q)) {
        if (N.test(M)) continue;
        Q[M] = y6(Y, X, Q[M]);
    }
    return Q;
}
function kL($, X, W) {
    return y6(B$($, X), X, R1($, W));
}
function vL($, X, W) {
    return y6(B$($, X), X, W);
}
function fL($, X, W) {
    let Q = R1($, W);
    if (!a(Q) || c$($.items)) return Q;
    let [Y, J] = [$.items, Math.max($.items.length, Q.length)];
    for (let U = 0; U < J; U++) if (U < Y.length) Q[U] = y6(Y[U], X, Q[U]);
    return Q;
}
function yL($, X, W) {
    let Q = R1($, W);
    for (let Y of $.anyOf) {
        let J = y6(Y, X, H$(Q));
        if (Q$(Y, X, J)) return J;
    }
    return Q;
}
function y6($, X, W) {
    let Q = O6($, X),
        Y = $;
    switch (Y[S]) {
        case 'Array':
            return VL(Y, Q, W);
        case 'Date':
            return EL(Y, Q, W);
        case 'Import':
            return xL(Y, Q, W);
        case 'Intersect':
            return bL(Y, Q, W);
        case 'Object':
            return gL(Y, Q, W);
        case 'Record':
            return TL(Y, Q, W);
        case 'Ref':
            return kL(Y, Q, W);
        case 'This':
            return vL(Y, Q, W);
        case 'Tuple':
            return fL(Y, Q, W);
        case 'Union':
            return yL(Y, Q, W);
        default:
            return R1(Y, W);
    }
}
function pY(...$) {
    return $.length === 3 ? y6($[0], $[1], $[2]) : y6($[0], [], $[1]);
}
var o4 = {};
k6(o4, {
    ValuePointerRootSetError: () => BJ,
    ValuePointerRootDeleteError: () => OJ,
    Set: () => hL,
    Has: () => cL,
    Get: () => uL,
    Format: () => NW,
    Delete: () => mL,
});
class BJ extends r {
    constructor($, X, W) {
        super('Cannot set root value');
        (this.value = $), (this.path = X), (this.update = W);
    }
}
class OJ extends r {
    constructor($, X) {
        super('Cannot delete root value');
        (this.value = $), (this.path = X);
    }
}
function xG($) {
    return $.indexOf('~') === -1
        ? $
        : $.replace(/~1/g, '/').replace(/~0/g, '~');
}
function* NW($) {
    if ($ === '') return;
    let [X, W] = [0, 0];
    for (let Q = 0; Q < $.length; Q++)
        if ($.charAt(Q) === '/')
            if (Q === 0) X = Q + 1;
            else (W = Q), yield xG($.slice(X, W)), (X = Q + 1);
        else W = Q;
    yield xG($.slice(X));
}
function hL($, X, W) {
    if (X === '') throw new BJ($, X, W);
    let [Q, Y, J] = [null, $, ''];
    for (let U of NW(X)) {
        if (Y[U] === void 0) Y[U] = {};
        (Q = Y), (Y = Y[U]), (J = U);
    }
    Q[J] = W;
}
function mL($, X) {
    if (X === '') throw new OJ($, X);
    let [W, Q, Y] = [null, $, ''];
    for (let J of NW(X)) {
        if (Q[J] === void 0 || Q[J] === null) return;
        (W = Q), (Q = Q[J]), (Y = J);
    }
    if (Array.isArray(W)) {
        let J = parseInt(Y);
        W.splice(J, 1);
    } else delete W[Y];
}
function cL($, X) {
    if (X === '') return !0;
    let [W, Q, Y] = [null, $, ''];
    for (let J of NW(X)) {
        if (Q[J] === void 0) return !1;
        (W = Q), (Q = Q[J]), (Y = J);
    }
    return Object.getOwnPropertyNames(W).includes(Y);
}
function uL($, X) {
    if (X === '') return $;
    let W = $;
    for (let Q of NW(X)) {
        if (W[Q] === void 0) return;
        W = W[Q];
    }
    return W;
}
function dL($, X) {
    if (!X$(X)) return !1;
    let W = [...Object.keys($), ...Object.getOwnPropertySymbols($)],
        Q = [...Object.keys(X), ...Object.getOwnPropertySymbols(X)];
    if (W.length !== Q.length) return !1;
    return W.every((Y) => C0($[Y], X[Y]));
}
function iL($, X) {
    return v6(X) && $.getTime() === X.getTime();
}
function nL($, X) {
    if (!a(X) || $.length !== X.length) return !1;
    return $.every((W, Q) => C0(W, X[Q]));
}
function pL($, X) {
    if (
        !P4(X) ||
        $.length !== X.length ||
        Object.getPrototypeOf($).constructor.name !==
            Object.getPrototypeOf(X).constructor.name
    )
        return !1;
    return $.every((W, Q) => C0(W, X[Q]));
}
function lL($, X) {
    return $ === X;
}
function C0($, X) {
    if (v6($)) return iL($, X);
    if (P4($)) return pL($, X);
    if (a($)) return nL($, X);
    if (X$($)) return dL($, X);
    if (J4($)) return lL($, X);
    throw new Error('ValueEquals: Unable to compare value');
}
var oL = j$({ type: Z$('insert'), path: f6(), value: m4() }),
    rL = j$({ type: Z$('update'), path: f6(), value: m4() }),
    tL = j$({ type: Z$('delete'), path: f6() }),
    gG = S$([oL, rL, tL]);
class HJ extends r {
    constructor($, X) {
        super(X);
        this.value = $;
    }
}
function lY($, X) {
    return { type: 'update', path: $, value: X };
}
function TG($, X) {
    return { type: 'insert', path: $, value: X };
}
function kG($) {
    return { type: 'delete', path: $ };
}
function bG($) {
    if (globalThis.Object.getOwnPropertySymbols($).length > 0)
        throw new HJ($, 'Cannot diff objects with symbols');
}
function* aL($, X, W) {
    if ((bG(X), bG(W), !cQ(W))) return yield lY($, W);
    let Q = globalThis.Object.getOwnPropertyNames(X),
        Y = globalThis.Object.getOwnPropertyNames(W);
    for (let J of Y) {
        if (t(X, J)) continue;
        yield TG(`${$}/${J}`, W[J]);
    }
    for (let J of Q) {
        if (!t(W, J)) continue;
        if (C0(X, W)) continue;
        yield* oY(`${$}/${J}`, X[J], W[J]);
    }
    for (let J of Q) {
        if (t(W, J)) continue;
        yield kG(`${$}/${J}`);
    }
}
function* sL($, X, W) {
    if (!a(W)) return yield lY($, W);
    for (let Q = 0; Q < Math.min(X.length, W.length); Q++)
        yield* oY(`${$}/${Q}`, X[Q], W[Q]);
    for (let Q = 0; Q < W.length; Q++) {
        if (Q < X.length) continue;
        yield TG(`${$}/${Q}`, W[Q]);
    }
    for (let Q = X.length - 1; Q >= 0; Q--) {
        if (Q < W.length) continue;
        yield kG(`${$}/${Q}`);
    }
}
function* eL($, X, W) {
    if (
        !P4(W) ||
        X.length !== W.length ||
        globalThis.Object.getPrototypeOf(X).constructor.name !==
            globalThis.Object.getPrototypeOf(W).constructor.name
    )
        return yield lY($, W);
    for (let Q = 0; Q < Math.min(X.length, W.length); Q++)
        yield* oY(`${$}/${Q}`, X[Q], W[Q]);
}
function* $K($, X, W) {
    if (X === W) return;
    yield lY($, W);
}
function* oY($, X, W) {
    if (cQ(X)) return yield* aL($, X, W);
    if (a(X)) return yield* sL($, X, W);
    if (P4(X)) return yield* eL($, X, W);
    if (J4(X)) return yield* $K($, X, W);
    throw new HJ(X, 'Unable to diff value');
}
function vG($, X) {
    return [...oY('', $, X)];
}
function XK($) {
    return $.length > 0 && $[0].path === '' && $[0].type === 'update';
}
function WK($) {
    return $.length === 0;
}
function fG($, X) {
    if (XK(X)) return H$(X[0].value);
    if (WK(X)) return H$($);
    let W = H$($);
    for (let Q of X)
        switch (Q.type) {
            case 'insert': {
                o4.Set(W, Q.path, Q.value);
                break;
            }
            case 'update': {
                o4.Set(W, Q.path, Q.value);
                break;
            }
            case 'delete': {
                o4.Delete(W, Q.path);
                break;
            }
        }
    return W;
}
function yG(...$) {
    let [X, W, Q] = $.length === 3 ? [$[0], $[1], $[2]] : [$[0], [], $[1]],
        Y = C1(X, W) ? HX(X, W, Q) : Q;
    if (!Q$(X, W, Y)) throw new UW(X, Y, Y1(X, W, Y).First());
    return Y;
}
function rY($) {
    return X$($) && !a($);
}
class qJ extends r {
    constructor($) {
        super($);
    }
}
function YK($, X, W, Q) {
    if (!rY(W)) o4.Set($, X, H$(Q));
    else {
        let Y = Object.getOwnPropertyNames(W),
            J = Object.getOwnPropertyNames(Q);
        for (let U of Y) if (!J.includes(U)) delete W[U];
        for (let U of J) if (!Y.includes(U)) W[U] = null;
        for (let U of J) AJ($, `${X}/${U}`, W[U], Q[U]);
    }
}
function QK($, X, W, Q) {
    if (!a(W)) o4.Set($, X, H$(Q));
    else {
        for (let Y = 0; Y < Q.length; Y++) AJ($, `${X}/${Y}`, W[Y], Q[Y]);
        W.splice(Q.length);
    }
}
function JK($, X, W, Q) {
    if (P4(W) && W.length === Q.length)
        for (let Y = 0; Y < W.length; Y++) W[Y] = Q[Y];
    else o4.Set($, X, H$(Q));
}
function UK($, X, W, Q) {
    if (W === Q) return;
    o4.Set($, X, Q);
}
function AJ($, X, W, Q) {
    if (a(Q)) return QK($, X, W, Q);
    if (P4(Q)) return JK($, X, W, Q);
    if (rY(Q)) return YK($, X, W, Q);
    if (J4(Q)) return UK($, X, W, Q);
}
function hG($) {
    return P4($) || J4($);
}
function NK($, X) {
    return (rY($) && a(X)) || (a($) && rY(X));
}
function mG($, X) {
    if (hG($) || hG(X))
        throw new qJ(
            'Only object and array types can be mutated at the root level',
        );
    if (NK($, X))
        throw new qJ('Cannot assign due type mismatch of assignable values');
    AJ($, '', $, X);
}
class SJ extends r {
    constructor($) {
        super($);
    }
}
var PJ;
(function ($) {
    let X = new Map([
        [
            'Assert',
            (J, U, N) => {
                return cY(J, U, N), N;
            },
        ],
        ['Cast', (J, U, N) => WW(J, U, N)],
        ['Clean', (J, U, N) => uY(J, U, N)],
        ['Clone', (J, U, N) => H$(N)],
        ['Convert', (J, U, N) => iY(J, U, N)],
        ['Decode', (J, U, N) => (C1(J, U) ? OX(J, U, N) : N)],
        ['Default', (J, U, N) => pY(J, U, N)],
        ['Encode', (J, U, N) => (C1(J, U) ? HX(J, U, N) : N)],
    ]);
    function W(J) {
        X.delete(J);
    }
    $.Delete = W;
    function Q(J, U) {
        X.set(J, U);
    }
    $.Set = Q;
    function Y(J) {
        return X.get(J);
    }
    $.Get = Y;
})(PJ || (PJ = {}));
var cG = ['Clone', 'Clean', 'Default', 'Convert', 'Assert', 'Decode'];
function MK($, X, W, Q) {
    return $.reduce((Y, J) => {
        let U = PJ.Get(J);
        if (c$(U)) throw new SJ(`Unable to find Parse operation '${J}'`);
        return U(X, W, Y);
    }, Q);
}
function uG(...$) {
    let [X, W, Q, Y] =
        $.length === 4
            ? [$[0], $[1], $[2], $[3]]
            : $.length === 3
              ? a($[0])
                  ? [$[0], $[1], [], $[2]]
                  : [cG, $[0], $[1], $[2]]
              : $.length === 2
                ? [cG, $[0], [], $[1]]
                : (() => {
                      throw new SJ('Invalid Arguments');
                  })();
    return MK(X, W, Q, Y);
}
var L$ = {};
k6(L$, {
    ValueErrorIterator: () => I0,
    Patch: () => fG,
    Parse: () => uG,
    Mutate: () => mG,
    Hash: () => W0,
    Errors: () => Y1,
    Equal: () => C0,
    Encode: () => yG,
    Edit: () => gG,
    Diff: () => vG,
    Default: () => pY,
    Decode: () => EG,
    Create: () => d4,
    Convert: () => iY,
    Clone: () => H$,
    Clean: () => uY,
    Check: () => Q$,
    Cast: () => WW,
    Assert: () => cY,
});
class dG {
    constructor($, X, W, Q) {
        (this.schema = $),
            (this.references = X),
            (this.checkFunc = W),
            (this.code = Q),
            (this.hasTransform = C1($, X));
    }
    Code() {
        return this.code;
    }
    Schema() {
        return this.schema;
    }
    References() {
        return this.references;
    }
    Errors($) {
        return Y1(this.schema, this.references, $);
    }
    Check($) {
        return this.checkFunc($);
    }
    Decode($) {
        if (!this.checkFunc($))
            throw new JW(this.schema, $, this.Errors($).First());
        return this.hasTransform ? OX(this.schema, this.references, $) : $;
    }
    Encode($) {
        let X = this.hasTransform ? HX(this.schema, this.references, $) : $;
        if (!this.checkFunc(X))
            throw new UW(this.schema, $, this.Errors($).First());
        return X;
    }
}
var V1;
(function ($) {
    function X(J) {
        return J === 36;
    }
    $.DollarSign = X;
    function W(J) {
        return J === 95;
    }
    $.IsUnderscore = W;
    function Q(J) {
        return (J >= 65 && J <= 90) || (J >= 97 && J <= 122);
    }
    $.IsAlpha = Q;
    function Y(J) {
        return J >= 48 && J <= 57;
    }
    $.IsNumeric = Y;
})(V1 || (V1 = {}));
var tY;
(function ($) {
    function X(J) {
        if (J.length === 0) return !1;
        return V1.IsNumeric(J.charCodeAt(0));
    }
    function W(J) {
        if (X(J)) return !1;
        for (let U = 0; U < J.length; U++) {
            let N = J.charCodeAt(U);
            if (
                !(
                    V1.IsAlpha(N) ||
                    V1.IsNumeric(N) ||
                    V1.DollarSign(N) ||
                    V1.IsUnderscore(N)
                )
            )
                return !1;
        }
        return !0;
    }
    function Q(J) {
        return J.replace(/'/g, "\\'");
    }
    function Y(J, U) {
        return W(U) ? `${J}.${U}` : `${J}['${Q(U)}']`;
    }
    $.Encode = Y;
})(tY || (tY = {}));
var jJ;
(function ($) {
    function X(W) {
        let Q = [];
        for (let Y = 0; Y < W.length; Y++) {
            let J = W.charCodeAt(Y);
            if (V1.IsNumeric(J) || V1.IsAlpha(J)) Q.push(W.charAt(Y));
            else Q.push(`_${J}_`);
        }
        return Q.join('').replace(/__/g, '_');
    }
    $.Encode = X;
})(jJ || (jJ = {}));
var LJ;
(function ($) {
    function X(W) {
        return W.replace(/'/g, "\\'");
    }
    $.Escape = X;
})(LJ || (LJ = {}));
class iG extends r {
    constructor($) {
        super('Unknown type');
        this.schema = $;
    }
}
class KJ extends r {
    constructor($) {
        super(
            'Preflight validation check failed to guard for the given schema',
        );
        this.schema = $;
    }
}
var R0;
(function ($) {
    function X(U, N, M) {
        return k$.ExactOptionalPropertyTypes
            ? `('${N}' in ${U} ? ${M} : true)`
            : `(${tY.Encode(U, N)} !== undefined ? ${M} : true)`;
    }
    $.IsExactOptionalProperty = X;
    function W(U) {
        return !k$.AllowArrayObject
            ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}))`
            : `(typeof ${U} === 'object' && ${U} !== null)`;
    }
    $.IsObjectLike = W;
    function Q(U) {
        return !k$.AllowArrayObject
            ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}) && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))`
            : `(typeof ${U} === 'object' && ${U} !== null && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))`;
    }
    $.IsRecordLike = Q;
    function Y(U) {
        return k$.AllowNaN
            ? `typeof ${U} === 'number'`
            : `Number.isFinite(${U})`;
    }
    $.IsNumberLike = Y;
    function J(U) {
        return k$.AllowNullVoid
            ? `(${U} === undefined || ${U} === null)`
            : `${U} === undefined`;
    }
    $.IsVoidLike = J;
})(R0 || (R0 = {}));
var Q1;
(function ($) {
    function X(D) {
        return D[S] === 'Any' || D[S] === 'Unknown';
    }
    function* W(D, K, q) {
        yield 'true';
    }
    function* Q(D, K, q) {
        yield 'true';
    }
    function* Y(D, K, q) {
        yield `Array.isArray(${q})`;
        let [g, x] = [A4('value', 'any'), A4('acc', 'number')];
        if (l(D.maxItems)) yield `${q}.length <= ${D.maxItems}`;
        if (l(D.minItems)) yield `${q}.length >= ${D.minItems}`;
        let f = U6(D.items, K, 'value');
        if (
            (yield `${q}.every((${g}) => ${f})`,
            d$(D.contains) || l(D.minContains) || l(D.maxContains))
        ) {
            let p = d$(D.contains) ? D.contains : Y$(),
                E$ = U6(p, K, 'value'),
                I6 = l(D.minContains) ? [`(count >= ${D.minContains})`] : [],
                L6 = l(D.maxContains) ? [`(count <= ${D.maxContains})`] : [],
                Y4 = `const count = value.reduce((${x}, ${g}) => ${E$} ? acc + 1 : acc, 0)`,
                D1 = ['(count > 0)', ...I6, ...L6].join(' && ');
            yield `((${g}) => { ${Y4}; return ${D1}})(${q})`;
        }
        if (D.uniqueItems === !0)
            yield `((${g}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${q})`;
    }
    function* J(D, K, q) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${q})`;
    }
    function* U(D, K, q) {
        if ((yield `(typeof ${q} === 'bigint')`, K6(D.exclusiveMaximum)))
            yield `${q} < BigInt(${D.exclusiveMaximum})`;
        if (K6(D.exclusiveMinimum))
            yield `${q} > BigInt(${D.exclusiveMinimum})`;
        if (K6(D.maximum)) yield `${q} <= BigInt(${D.maximum})`;
        if (K6(D.minimum)) yield `${q} >= BigInt(${D.minimum})`;
        if (K6(D.multipleOf)) yield `(${q} % BigInt(${D.multipleOf})) === 0`;
    }
    function* N(D, K, q) {
        yield `(typeof ${q} === 'boolean')`;
    }
    function* M(D, K, q) {
        yield* e4(D.returns, K, `${q}.prototype`);
    }
    function* G(D, K, q) {
        if (
            (yield `(${q} instanceof Date) && Number.isFinite(${q}.getTime())`,
            l(D.exclusiveMaximumTimestamp))
        )
            yield `${q}.getTime() < ${D.exclusiveMaximumTimestamp}`;
        if (l(D.exclusiveMinimumTimestamp))
            yield `${q}.getTime() > ${D.exclusiveMinimumTimestamp}`;
        if (l(D.maximumTimestamp))
            yield `${q}.getTime() <= ${D.maximumTimestamp}`;
        if (l(D.minimumTimestamp))
            yield `${q}.getTime() >= ${D.minimumTimestamp}`;
        if (l(D.multipleOfTimestamp))
            yield `(${q}.getTime() % ${D.multipleOfTimestamp}) === 0`;
    }
    function* Z(D, K, q) {
        yield `(typeof ${q} === 'function')`;
    }
    function* B(D, K, q) {
        let g = globalThis.Object.getOwnPropertyNames(D.$defs).reduce(
            (x, f) => {
                return [...x, D.$defs[f]];
            },
            [],
        );
        yield* e4(_4(D.$ref), [...K, ...g], q);
    }
    function* O(D, K, q) {
        if ((yield `Number.isInteger(${q})`, l(D.exclusiveMaximum)))
            yield `${q} < ${D.exclusiveMaximum}`;
        if (l(D.exclusiveMinimum)) yield `${q} > ${D.exclusiveMinimum}`;
        if (l(D.maximum)) yield `${q} <= ${D.maximum}`;
        if (l(D.minimum)) yield `${q} >= ${D.minimum}`;
        if (l(D.multipleOf)) yield `(${q} % ${D.multipleOf}) === 0`;
    }
    function* w(D, K, q) {
        let g = D.allOf.map((x) => U6(x, K, q)).join(' && ');
        if (D.unevaluatedProperties === !1) {
            let x = x4(`${new RegExp(K1(D))};`),
                f = `Object.getOwnPropertyNames(${q}).every(key => ${x}.test(key))`;
            yield `(${g} && ${f})`;
        } else if (d$(D.unevaluatedProperties)) {
            let x = x4(`${new RegExp(K1(D))};`),
                f = `Object.getOwnPropertyNames(${q}).every(key => ${x}.test(key) || ${U6(D.unevaluatedProperties, K, `${q}[key]`)})`;
            yield `(${g} && ${f})`;
        } else yield `(${g})`;
    }
    function* z(D, K, q) {
        yield `(typeof value === 'object' && Symbol.iterator in ${q})`;
    }
    function* H(D, K, q) {
        if (typeof D.const === 'number' || typeof D.const === 'boolean')
            yield `(${q} === ${D.const})`;
        else yield `(${q} === '${LJ.Escape(D.const)}')`;
    }
    function* P(D, K, q) {
        yield 'false';
    }
    function* E(D, K, q) {
        yield `(!${U6(D.not, K, q)})`;
    }
    function* j(D, K, q) {
        yield `(${q} === null)`;
    }
    function* V(D, K, q) {
        if ((yield R0.IsNumberLike(q), l(D.exclusiveMaximum)))
            yield `${q} < ${D.exclusiveMaximum}`;
        if (l(D.exclusiveMinimum)) yield `${q} > ${D.exclusiveMinimum}`;
        if (l(D.maximum)) yield `${q} <= ${D.maximum}`;
        if (l(D.minimum)) yield `${q} >= ${D.minimum}`;
        if (l(D.multipleOf)) yield `(${q} % ${D.multipleOf}) === 0`;
    }
    function* i(D, K, q) {
        if ((yield R0.IsObjectLike(q), l(D.minProperties)))
            yield `Object.getOwnPropertyNames(${q}).length >= ${D.minProperties}`;
        if (l(D.maxProperties))
            yield `Object.getOwnPropertyNames(${q}).length <= ${D.maxProperties}`;
        let g = Object.getOwnPropertyNames(D.properties);
        for (let x of g) {
            let f = tY.Encode(q, x),
                p = D.properties[x];
            if (D.required && D.required.includes(x)) {
                if ((yield* e4(p, K, f), _1(p) || X(p)))
                    yield `('${x}' in ${q})`;
            } else {
                let E$ = U6(p, K, f);
                yield R0.IsExactOptionalProperty(q, x, E$);
            }
        }
        if (D.additionalProperties === !1)
            if (D.required && D.required.length === g.length)
                yield `Object.getOwnPropertyNames(${q}).length === ${g.length}`;
            else {
                let x = `[${g.map((f) => `'${f}'`).join(', ')}]`;
                yield `Object.getOwnPropertyNames(${q}).every(key => ${x}.includes(key))`;
            }
        if (typeof D.additionalProperties === 'object') {
            let x = U6(D.additionalProperties, K, `${q}[key]`),
                f = `[${g.map((p) => `'${p}'`).join(', ')}]`;
            yield `(Object.getOwnPropertyNames(${q}).every(key => ${f}.includes(key) || ${x}))`;
        }
    }
    function* $$(D, K, q) {
        yield `${q} instanceof Promise`;
    }
    function* y(D, K, q) {
        if ((yield R0.IsRecordLike(q), l(D.minProperties)))
            yield `Object.getOwnPropertyNames(${q}).length >= ${D.minProperties}`;
        if (l(D.maxProperties))
            yield `Object.getOwnPropertyNames(${q}).length <= ${D.maxProperties}`;
        let [g, x] = Object.entries(D.patternProperties)[0],
            f = x4(`${new RegExp(g)}`),
            p = U6(x, K, 'value'),
            E$ = d$(D.additionalProperties)
                ? U6(D.additionalProperties, K, q)
                : D.additionalProperties === !1
                  ? 'false'
                  : 'true',
            I6 = `(${f}.test(key) ? ${p} : ${E$})`;
        yield `(Object.entries(${q}).every(([key, value]) => ${I6}))`;
    }
    function* n(D, K, q) {
        let g = B$(D, K);
        if (s$.functions.has(D.$ref)) return yield `${j6(D.$ref)}(${q})`;
        yield* e4(g, K, q);
    }
    function* k(D, K, q) {
        let g = x4(`${new RegExp(D.source, D.flags)};`);
        if ((yield `(typeof ${q} === 'string')`, l(D.maxLength)))
            yield `${q}.length <= ${D.maxLength}`;
        if (l(D.minLength)) yield `${q}.length >= ${D.minLength}`;
        yield `${g}.test(${q})`;
    }
    function* b(D, K, q) {
        if ((yield `(typeof ${q} === 'string')`, l(D.maxLength)))
            yield `${q}.length <= ${D.maxLength}`;
        if (l(D.minLength)) yield `${q}.length >= ${D.minLength}`;
        if (D.pattern !== void 0)
            yield `${x4(`${new RegExp(D.pattern)};`)}.test(${q})`;
        if (D.format !== void 0) yield `format('${D.format}', ${q})`;
    }
    function* T(D, K, q) {
        yield `(typeof ${q} === 'symbol')`;
    }
    function* o(D, K, q) {
        yield `(typeof ${q} === 'string')`,
            yield `${x4(`${new RegExp(D.pattern)};`)}.test(${q})`;
    }
    function* e(D, K, q) {
        yield `${j6(D.$ref)}(${q})`;
    }
    function* W$(D, K, q) {
        if ((yield `Array.isArray(${q})`, D.items === void 0))
            return yield `${q}.length === 0`;
        yield `(${q}.length === ${D.maxItems})`;
        for (let g = 0; g < D.items.length; g++)
            yield `${U6(D.items[g], K, `${q}[${g}]`)}`;
    }
    function* W4(D, K, q) {
        yield `${q} === undefined`;
    }
    function* A$(D, K, q) {
        yield `(${D.anyOf.map((x) => U6(x, K, q)).join(' || ')})`;
    }
    function* c6(D, K, q) {
        if ((yield `${q} instanceof Uint8Array`, l(D.maxByteLength)))
            yield `(${q}.length <= ${D.maxByteLength})`;
        if (l(D.minByteLength)) yield `(${q}.length >= ${D.minByteLength})`;
    }
    function* Z1(D, K, q) {
        yield 'true';
    }
    function* w1(D, K, q) {
        yield R0.IsVoidLike(q);
    }
    function* q4(D, K, q) {
        let g = s$.instances.size;
        s$.instances.set(g, D), yield `kind('${D[S]}', ${g}, ${q})`;
    }
    function* e4(D, K, q, g = !0) {
        let x = w$(D.$id) ? [...K, D] : K,
            f = D;
        if (g && w$(D.$id)) {
            let p = j6(D.$id);
            if (s$.functions.has(p)) return yield `${p}(${q})`;
            else {
                s$.functions.set(p, '<deferred>');
                let E$ = T6(p, D, K, 'value', !1);
                return s$.functions.set(p, E$), yield `${p}(${q})`;
            }
        }
        switch (f[S]) {
            case 'Any':
                return yield* W(f, x, q);
            case 'Argument':
                return yield* Q(f, x, q);
            case 'Array':
                return yield* Y(f, x, q);
            case 'AsyncIterator':
                return yield* J(f, x, q);
            case 'BigInt':
                return yield* U(f, x, q);
            case 'Boolean':
                return yield* N(f, x, q);
            case 'Constructor':
                return yield* M(f, x, q);
            case 'Date':
                return yield* G(f, x, q);
            case 'Function':
                return yield* Z(f, x, q);
            case 'Import':
                return yield* B(f, x, q);
            case 'Integer':
                return yield* O(f, x, q);
            case 'Intersect':
                return yield* w(f, x, q);
            case 'Iterator':
                return yield* z(f, x, q);
            case 'Literal':
                return yield* H(f, x, q);
            case 'Never':
                return yield* P(f, x, q);
            case 'Not':
                return yield* E(f, x, q);
            case 'Null':
                return yield* j(f, x, q);
            case 'Number':
                return yield* V(f, x, q);
            case 'Object':
                return yield* i(f, x, q);
            case 'Promise':
                return yield* $$(f, x, q);
            case 'Record':
                return yield* y(f, x, q);
            case 'Ref':
                return yield* n(f, x, q);
            case 'RegExp':
                return yield* k(f, x, q);
            case 'String':
                return yield* b(f, x, q);
            case 'Symbol':
                return yield* T(f, x, q);
            case 'TemplateLiteral':
                return yield* o(f, x, q);
            case 'This':
                return yield* e(f, x, q);
            case 'Tuple':
                return yield* W$(f, x, q);
            case 'Undefined':
                return yield* W4(f, x, q);
            case 'Union':
                return yield* A$(f, x, q);
            case 'Uint8Array':
                return yield* c6(f, x, q);
            case 'Unknown':
                return yield* Z1(f, x, q);
            case 'Void':
                return yield* w1(f, x, q);
            default:
                if (!Z6.Has(f[S])) throw new iG(D);
                return yield* q4(f, x, q);
        }
    }
    let s$ = {
        language: 'javascript',
        functions: new Map(),
        variables: new Map(),
        instances: new Map(),
    };
    function U6(D, K, q, g = !0) {
        return `(${[...e4(D, K, q, g)].join(' && ')})`;
    }
    function j6(D) {
        return `check_${jJ.Encode(D)}`;
    }
    function x4(D) {
        let K = `local_${s$.variables.size}`;
        return s$.variables.set(K, `const ${K} = ${D}`), K;
    }
    function T6(D, K, q, g, x = !0) {
        let [f, p] = [
                `
`,
                (Y4) => ''.padStart(Y4, ' '),
            ],
            E$ = A4('value', 'any'),
            I6 = n1('boolean'),
            L6 = [...e4(K, q, g, x)]
                .map((Y4) => `${p(4)}${Y4}`)
                .join(` &&${f}`);
        return `function ${D}(${E$})${I6} {${f}${p(2)}return (${f}${L6}${f}${p(2)})
}`;
    }
    function A4(D, K) {
        let q = s$.language === 'typescript' ? `: ${K}` : '';
        return `${D}${q}`;
    }
    function n1(D) {
        return s$.language === 'typescript' ? `: ${D}` : '';
    }
    function b4(D, K, q) {
        let g = T6('check', D, K, 'value'),
            x = A4('value', 'any'),
            f = n1('boolean'),
            p = [...s$.functions.values()],
            E$ = [...s$.variables.values()],
            I6 = w$(D.$id)
                ? `return function check(${x})${f} {
  return ${j6(D.$id)}(value)
}`
                : `return ${g}`;
        return [...E$, ...p, I6].join(`
`);
    }
    function u(...D) {
        let K = { language: 'javascript' },
            [q, g, x] =
                D.length === 2 && a(D[1])
                    ? [D[0], D[1], K]
                    : D.length === 2 && !a(D[1])
                      ? [D[0], [], D[1]]
                      : D.length === 3
                        ? [D[0], D[1], D[2]]
                        : D.length === 1
                          ? [D[0], [], K]
                          : [null, [], K];
        if (
            ((s$.language = x.language),
            s$.variables.clear(),
            s$.functions.clear(),
            s$.instances.clear(),
            !d$(q))
        )
            throw new KJ(q);
        for (let f of g) if (!d$(f)) throw new KJ(f);
        return b4(q, g, x);
    }
    $.Code = u;
    function R(D, K = []) {
        let q = u(D, K, { language: 'javascript' }),
            g = globalThis.Function('kind', 'format', 'hash', q),
            x = new Map(s$.instances);
        function f(L6, Y4, D1) {
            if (!Z6.Has(L6) || !x.has(Y4)) return !1;
            let KD = Z6.Get(L6),
                _D = x.get(Y4);
            return KD(_D, D1);
        }
        function p(L6, Y4) {
            if (!_$.Has(L6)) return !1;
            return _$.Get(L6)(Y4);
        }
        function E$(L6) {
            return W0(L6);
        }
        let I6 = g(f, p, E$);
        return new dG(D, K, I6, q);
    }
    $.Compile = R;
})(Q1 || (Q1 = {}));
var V_ = Object.create,
    {
        getPrototypeOf: E_,
        defineProperty: $Z,
        getOwnPropertyNames: x_,
    } = Object,
    b_ = Object.prototype.hasOwnProperty,
    I8 = ($, X, W) => {
        W = $ != null ? V_(E_($)) : {};
        let Q =
            X || !$ || !$.__esModule
                ? $Z(W, 'default', { value: $, enumerable: !0 })
                : W;
        for (let Y of x_($))
            if (!b_.call(Q, Y)) $Z(Q, Y, { get: () => $[Y], enumerable: !0 });
        return Q;
    },
    EZ = ($, X) => () => (X || $((X = { exports: {} }).exports, X), X.exports);
var g_ = EZ(($) => {
        Object.defineProperty($, '__esModule', { value: !0 }),
            ($.parse = N),
            ($.serialize = Z);
        var X = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
            W = /^[\u0021-\u003A\u003C-\u007E]*$/,
            Q =
                /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
            Y = /^[\u0020-\u003A\u003D-\u007E]*$/,
            J = Object.prototype.toString,
            U = (() => {
                let w = function () {};
                return (w.prototype = Object.create(null)), w;
            })();
        function N(w, z) {
            let H = new U(),
                P = w.length;
            if (P < 2) return H;
            let E = z?.decode || B,
                j = 0;
            do {
                let V = w.indexOf('=', j);
                if (V === -1) break;
                let i = w.indexOf(';', j),
                    $$ = i === -1 ? P : i;
                if (V > $$) {
                    j = w.lastIndexOf(';', V - 1) + 1;
                    continue;
                }
                let y = M(w, j, V),
                    n = G(w, V, y),
                    k = w.slice(y, n);
                if (H[k] === void 0) {
                    let b = M(w, V + 1, $$),
                        T = G(w, $$, b),
                        o = E(w.slice(b, T));
                    H[k] = o;
                }
                j = $$ + 1;
            } while (j < P);
            return H;
        }
        function M(w, z, H) {
            do {
                let P = w.charCodeAt(z);
                if (P !== 32 && P !== 9) return z;
            } while (++z < H);
            return H;
        }
        function G(w, z, H) {
            while (z > H) {
                let P = w.charCodeAt(--z);
                if (P !== 32 && P !== 9) return z + 1;
            }
            return H;
        }
        function Z(w, z, H) {
            let P = H?.encode || encodeURIComponent;
            if (!X.test(w))
                throw new TypeError(`argument name is invalid: ${w}`);
            let E = P(z);
            if (!W.test(E))
                throw new TypeError(`argument val is invalid: ${z}`);
            let j = w + '=' + E;
            if (!H) return j;
            if (H.maxAge !== void 0) {
                if (!Number.isInteger(H.maxAge))
                    throw new TypeError(
                        `option maxAge is invalid: ${H.maxAge}`,
                    );
                j += '; Max-Age=' + H.maxAge;
            }
            if (H.domain) {
                if (!Q.test(H.domain))
                    throw new TypeError(
                        `option domain is invalid: ${H.domain}`,
                    );
                j += '; Domain=' + H.domain;
            }
            if (H.path) {
                if (!Y.test(H.path))
                    throw new TypeError(`option path is invalid: ${H.path}`);
                j += '; Path=' + H.path;
            }
            if (H.expires) {
                if (!O(H.expires) || !Number.isFinite(H.expires.valueOf()))
                    throw new TypeError(
                        `option expires is invalid: ${H.expires}`,
                    );
                j += '; Expires=' + H.expires.toUTCString();
            }
            if (H.httpOnly) j += '; HttpOnly';
            if (H.secure) j += '; Secure';
            if (H.partitioned) j += '; Partitioned';
            if (H.priority)
                switch (
                    typeof H.priority === 'string'
                        ? H.priority.toLowerCase()
                        : void 0
                ) {
                    case 'low':
                        j += '; Priority=Low';
                        break;
                    case 'medium':
                        j += '; Priority=Medium';
                        break;
                    case 'high':
                        j += '; Priority=High';
                        break;
                    default:
                        throw new TypeError(
                            `option priority is invalid: ${H.priority}`,
                        );
                }
            if (H.sameSite)
                switch (
                    typeof H.sameSite === 'string'
                        ? H.sameSite.toLowerCase()
                        : H.sameSite
                ) {
                    case !0:
                    case 'strict':
                        j += '; SameSite=Strict';
                        break;
                    case 'lax':
                        j += '; SameSite=Lax';
                        break;
                    case 'none':
                        j += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError(
                            `option sameSite is invalid: ${H.sameSite}`,
                        );
                }
            return j;
        }
        function B(w) {
            if (w.indexOf('%') === -1) return w;
            try {
                return decodeURIComponent(w);
            } catch (z) {
                return w;
            }
        }
        function O(w) {
            return J.call(w) === '[object Date]';
        }
    }),
    NU = EZ(($, X) => {
        var W = 12,
            Q = 0,
            Y = [
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7,
                7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0,
                24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48,
                48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31,
                15, 15, 15, 7, 7, 7,
            ];
        function J(M) {
            var G = M.indexOf('%');
            if (G === -1) return M;
            var Z = M.length,
                B = '',
                O = 0,
                w = 0,
                z = G,
                H = W;
            while (G > -1 && G < Z) {
                var P = N(M[G + 1], 4),
                    E = N(M[G + 2], 0),
                    j = P | E,
                    V = Y[j];
                if (
                    ((H = Y[256 + H + V]),
                    (w = (w << 6) | (j & Y[364 + V])),
                    H === W)
                )
                    (B += M.slice(O, z)),
                        (B +=
                            w <= 65535
                                ? String.fromCharCode(w)
                                : String.fromCharCode(
                                      55232 + (w >> 10),
                                      56320 + (w & 1023),
                                  )),
                        (w = 0),
                        (O = G + 3),
                        (G = z = M.indexOf('%', O));
                else if (H === Q) return null;
                else {
                    if (((G += 3), G < Z && M.charCodeAt(G) === 37)) continue;
                    return null;
                }
            }
            return B + M.slice(O);
        }
        var U = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15,
        };
        function N(M, G) {
            var Z = U[M];
            return Z === void 0 ? 255 : Z << G;
        }
        X.exports = J;
    }),
    _X = ($, X) => {
        let W = X?.length ? {} : null;
        if (W) for (let Q of X) W[Q.part.charCodeAt(0)] = Q;
        return {
            part: $,
            store: null,
            inert: W,
            params: null,
            wildcardStore: null,
        };
    },
    XZ = ($, X) => ({ ...$, part: X }),
    WZ = ($) => ({ name: $, store: null, inert: null });
class RX {
    config;
    root = {};
    history = [];
    deferred = [];
    constructor($ = {}) {
        if (((this.config = $), $.lazy)) this.find = this.lazyFind;
    }
    static regex = {
        static: /:.+?(?=\/|$)/,
        params: /:.+?(?=\/|$)/g,
        optionalParams: /(\/:\w+\?)/g,
    };
    lazyFind = ($, X) => {
        if (!this.config.lazy) return this.find;
        return this.build(), this.find($, X);
    };
    build() {
        if (!this.config.lazy) return;
        for (let [$, X, W] of this.deferred)
            this.add($, X, W, { lazy: !1, ignoreHistory: !0 });
        (this.deferred = []),
            (this.find = ($, X) => {
                let W = this.root[$];
                if (!W) return null;
                return B8(X, X.length, W, 0);
            });
    }
    add(
        $,
        X,
        W,
        {
            ignoreError: Q = !1,
            ignoreHistory: Y = !1,
            lazy: J = this.config.lazy,
        } = {},
    ) {
        if (J)
            return (
                (this.find = this.lazyFind), this.deferred.push([$, X, W]), W
            );
        if (typeof X !== 'string')
            throw new TypeError('Route path must be a string');
        if (X === '') X = '/';
        else if (X[0] !== '/') X = `/${X}`;
        let U = X[X.length - 1] === '*',
            N = X.match(RX.regex.optionalParams);
        if (N) {
            let O = X.replaceAll('?', '');
            this.add($, O, W, { ignoreError: Q, ignoreHistory: Y, lazy: J });
            for (let w = 0; w < N.length; w++) {
                let z = X.replace(N[w], '');
                this.add($, z, W, {
                    ignoreError: !0,
                    ignoreHistory: Y,
                    lazy: J,
                });
            }
            return W;
        }
        if (N) X = X.replaceAll('?', '');
        if (this.history.find(([O, w, z]) => O === $ && w === X)) return W;
        if (U || (N && X.charCodeAt(X.length - 1) === 63)) X = X.slice(0, -1);
        if (!Y) this.history.push([$, X, W]);
        let M = X.split(RX.regex.static),
            G = X.match(RX.regex.params) || [];
        if (M[M.length - 1] === '') M.pop();
        let Z;
        if (!this.root[$]) Z = this.root[$] = _X('/');
        else Z = this.root[$];
        let B = 0;
        for (let O = 0; O < M.length; ++O) {
            let w = M[O];
            if (O > 0) {
                let z = G[B++].slice(1);
                if (Z.params === null) Z.params = WZ(z);
                else if (Z.params.name !== z)
                    if (Q) return W;
                    else
                        throw new Error(
                            `Cannot create route "${X}" with parameter "${z}" because a route already exists with a different parameter name ("${Z.params.name}") in the same location`,
                        );
                let H = Z.params;
                if (H.inert === null) {
                    Z = H.inert = _X(w);
                    continue;
                }
                Z = H.inert;
            }
            for (let z = 0; ; ) {
                if (z === w.length) {
                    if (z < Z.part.length) {
                        let H = XZ(Z, Z.part.slice(z));
                        Object.assign(Z, _X(w, [H]));
                    }
                    break;
                }
                if (z === Z.part.length) {
                    if (Z.inert === null) Z.inert = {};
                    let H = Z.inert[w.charCodeAt(z)];
                    if (H) {
                        (Z = H), (w = w.slice(z)), (z = 0);
                        continue;
                    }
                    let P = _X(w.slice(z));
                    (Z.inert[w.charCodeAt(z)] = P), (Z = P);
                    break;
                }
                if (w[z] !== Z.part[z]) {
                    let H = XZ(Z, Z.part.slice(z)),
                        P = _X(w.slice(z));
                    Object.assign(Z, _X(Z.part.slice(0, z), [H, P])), (Z = P);
                    break;
                }
                ++z;
            }
        }
        if (B < G.length) {
            let O = G[B].slice(1);
            if (Z.params === null) Z.params = WZ(O);
            else if (Z.params.name !== O)
                if (Q) return W;
                else
                    throw new Error(
                        `Cannot create route "${X}" with parameter "${O}" because a route already exists with a different parameter name ("${Z.params.name}") in the same location`,
                    );
            if (Z.params.store === null) Z.params.store = W;
            return Z.params.store;
        }
        if (U) {
            if (Z.wildcardStore === null) Z.wildcardStore = W;
            return Z.wildcardStore;
        }
        if (Z.store === null) Z.store = W;
        return Z.store;
    }
    find($, X) {
        let W = this.root[$];
        if (!W) return null;
        return B8(X, X.length, W, 0);
    }
}
var B8 = ($, X, W, Q) => {
        let Y = W.part,
            J = Y.length,
            U = Q + J;
        if (J > 1) {
            if (U > X) return null;
            if (J < 15) {
                for (let N = 1, M = Q + 1; N < J; ++N, ++M)
                    if (Y.charCodeAt(N) !== $.charCodeAt(M)) return null;
            } else if ($.slice(Q, U) !== Y) return null;
        }
        if (U === X) {
            if (W.store !== null) return { store: W.store, params: {} };
            if (W.wildcardStore !== null)
                return { store: W.wildcardStore, params: { '*': '' } };
            return null;
        }
        if (W.inert !== null) {
            let N = W.inert[$.charCodeAt(U)];
            if (N !== void 0) {
                let M = B8($, X, N, U);
                if (M !== null) return M;
            }
        }
        if (W.params !== null) {
            let { store: N, name: M, inert: G } = W.params,
                Z = $.indexOf('/', U);
            if (Z !== U) {
                if (Z === -1 || Z >= X) {
                    if (N !== null) {
                        let B = {};
                        return (
                            (B[M] = $.substring(U, X)), { store: N, params: B }
                        );
                    }
                } else if (G !== null) {
                    let B = B8($, X, G, Z);
                    if (B !== null) return (B.params[M] = $.substring(U, Z)), B;
                }
            }
        }
        if (W.wildcardStore !== null)
            return {
                store: W.wildcardStore,
                params: { '*': $.substring(U, X) },
            };
        return null;
    },
    MU = {
        date: xZ,
        time: $U(!0),
        'date-time': YZ(!0),
        'iso-time': $U(!1),
        'iso-date-time': YZ(!1),
        duration:
            /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: c_,
        'uri-reference':
            /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        'uri-template':
            /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname:
            /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: o_,
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        'json-pointer': /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        'json-pointer-uri-fragment':
            /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        'relative-json-pointer':
            /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        byte: u_,
        int32: { type: 'number', validate: n_ },
        int64: { type: 'number', validate: p_ },
        float: { type: 'number', validate: JZ },
        double: { type: 'number', validate: JZ },
        password: !0,
        binary: !0,
    };
function T_($) {
    return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
var k_ = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    v_ = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function xZ($) {
    let X = k_.exec($);
    if (!X) return !1;
    let W = +X[1],
        Q = +X[2],
        Y = +X[3];
    return Q >= 1 && Q <= 12 && Y >= 1 && Y <= (Q === 2 && T_(W) ? 29 : v_[Q]);
}
var f_ = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function $U($) {
    return function X(W) {
        let Q = f_.exec(W);
        if (!Q) return !1;
        let Y = +Q[1],
            J = +Q[2],
            U = +Q[3],
            N = Q[4],
            M = Q[5] === '-' ? -1 : 1,
            G = +(Q[6] || 0),
            Z = +(Q[7] || 0);
        if (G > 23 || Z > 59 || ($ && !N)) return !1;
        if (Y <= 23 && J <= 59 && U < 60) return !0;
        let B = J - Z * M,
            O = Y - G * M - (B < 0 ? 1 : 0);
        return (O === 23 || O === -1) && (B === 59 || B === -1) && U < 61;
    };
}
var bZ = ($) => {
        if ($.charCodeAt($.length - 6) === 32)
            return $.slice(0, -6) + '+' + $.slice(-5);
        return $;
    },
    y_ = /t|\s/i;
function YZ($) {
    let X = $U($);
    return function W(Q) {
        let Y = Q.split(y_);
        return Y.length === 2 && xZ(Y[0]) && X(Y[1]);
    };
}
var h_ = /\/|:/,
    m_ =
        /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function c_($) {
    return h_.test($) && m_.test($);
}
var QZ = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function u_($) {
    return (QZ.lastIndex = 0), QZ.test($);
}
var d_ = -2147483648,
    i_ = 2147483647;
function n_($) {
    return Number.isInteger($) && $ <= i_ && $ >= d_;
}
function p_($) {
    return Number.isInteger($);
}
function JZ() {
    return !0;
}
var l_ = /[^\\]\\Z/;
function o_($) {
    if (l_.test($)) return !1;
    try {
        return new RegExp($), !0;
    } catch (X) {
        return !1;
    }
}
var gZ =
        /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,
    TZ =
        /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/,
    kZ =
        /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/,
    r_ = MU.date,
    t_ = MU['date-time'];
if (!_$.Has('date'))
    _$.Set('date', ($) => {
        let X = bZ($).replace(/"/g, '');
        if (gZ.test(X) || TZ.test(X) || kZ.test(X) || r_(X)) {
            let W = new Date(X);
            if (!Number.isNaN(W.getTime())) return !0;
        }
        return !1;
    });
if (!_$.Has('date-time'))
    _$.Set('date-time', ($) => {
        let X = $.replace(/"/g, '');
        if (gZ.test(X) || TZ.test(X) || kZ.test(X) || t_(X)) {
            let W = new Date(X);
            if (!Number.isNaN(W.getTime())) return !0;
        }
        return !1;
    });
Object.entries(MU).forEach(($) => {
    let [X, W] = $;
    if (!_$.Has(X)) {
        if (W instanceof RegExp) _$.Set(X, (Q) => W.test(Q));
        else if (typeof W === 'function') _$.Set(X, W);
    }
});
if (!_$.Has('numeric')) _$.Set('numeric', ($) => !!$ && !isNaN(+$));
if (!_$.Has('integer')) _$.Set('integer', ($) => !!$ && Number.isInteger(+$));
if (!_$.Has('boolean')) _$.Set('boolean', ($) => $ === 'true' || $ === 'false');
if (!_$.Has('ObjectString'))
    _$.Set('ObjectString', ($) => {
        let X = $.charCodeAt(0);
        if (X === 9 || X === 10 || X === 32) X = $.trimStart().charCodeAt(0);
        if (X !== 123 && X !== 91) return !1;
        try {
            return JSON.parse($), !0;
        } catch {
            return !1;
        }
    });
if (!_$.Has('ArrayString'))
    _$.Set('ArrayString', ($) => {
        let X = $.charCodeAt(0);
        if (X === 9 || X === 10 || X === 32) X = $.trimStart().charCodeAt(0);
        if (X !== 123 && X !== 91) return !1;
        try {
            return JSON.parse($), !0;
        } catch {
            return !1;
        }
    });
var VX = typeof Bun !== 'undefined',
    a_ = {
        aac: 'audio/aac',
        abw: 'application/x-abiword',
        ai: 'application/postscript',
        arc: 'application/octet-stream',
        avi: 'video/x-msvideo',
        azw: 'application/vnd.amazon.ebook',
        bin: 'application/octet-stream',
        bz: 'application/x-bzip',
        bz2: 'application/x-bzip2',
        csh: 'application/x-csh',
        css: 'text/css',
        csv: 'text/csv',
        doc: 'application/msword',
        dll: 'application/octet-stream',
        eot: 'application/vnd.ms-fontobject',
        epub: 'application/epub+zip',
        gif: 'image/gif',
        htm: 'text/html',
        html: 'text/html',
        ico: 'image/x-icon',
        ics: 'text/calendar',
        jar: 'application/java-archive',
        jpeg: 'image/jpeg',
        jpg: 'image/jpeg',
        js: 'application/javascript',
        json: 'application/json',
        mid: 'audio/midi',
        midi: 'audio/midi',
        mp2: 'audio/mpeg',
        mp3: 'audio/mpeg',
        mp4: 'video/mp4',
        mpa: 'video/mpeg',
        mpe: 'video/mpeg',
        mpeg: 'video/mpeg',
        mpkg: 'application/vnd.apple.installer+xml',
        odp: 'application/vnd.oasis.opendocument.presentation',
        ods: 'application/vnd.oasis.opendocument.spreadsheet',
        odt: 'application/vnd.oasis.opendocument.text',
        oga: 'audio/ogg',
        ogv: 'video/ogg',
        ogx: 'application/ogg',
        otf: 'font/otf',
        png: 'image/png',
        pdf: 'application/pdf',
        ppt: 'application/vnd.ms-powerpoint',
        rar: 'application/x-rar-compressed',
        rtf: 'application/rtf',
        sh: 'application/x-sh',
        svg: 'image/svg+xml',
        swf: 'application/x-shockwave-flash',
        tar: 'application/x-tar',
        tif: 'image/tiff',
        tiff: 'image/tiff',
        ts: 'application/typescript',
        ttf: 'font/ttf',
        txt: 'text/plain',
        vsd: 'application/vnd.visio',
        wav: 'audio/x-wav',
        weba: 'audio/webm',
        webm: 'video/webm',
        webp: 'image/webp',
        woff: 'font/woff',
        woff2: 'font/woff2',
        xhtml: 'application/xhtml+xml',
        xls: 'application/vnd.ms-excel',
        xlsx: 'application/vnd.ms-excel',
        xlsx_OLD:
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        xml: 'application/xml',
        xul: 'application/vnd.mozilla.xul+xml',
        zip: 'application/zip',
        '3gp': 'video/3gpp',
        '3gp_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp',
        '3gp2': 'video/3gpp2',
        '3gp2_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp2',
        '7z': 'application/x-7z-compressed',
    },
    s_ = ($) => {
        let X = $.lastIndexOf('.');
        if (X === -1) return '';
        return $.slice(X + 1);
    };
var nJ, pJ;
class O8 {
    path;
    value;
    stats;
    constructor($) {
        if (((this.path = $), VX)) this.value = Bun.file($);
        else if (typeof window !== 'undefined')
            console.warn('Browser environment does not support file');
        else if (!nJ || !pJ)
            try {
                (this.value = import('fs').then((X) => {
                    return (nJ = X.createReadStream), X.createReadStream($);
                })),
                    (this.stats = import('fs/promises').then((X) => {
                        return (pJ = X.stat), X.stat($);
                    }));
            } catch {}
        else (this.value = nJ($)), (this.stats = pJ($));
    }
    get type() {
        return a_[s_(this.path)] || 'application/octet-stream';
    }
    get length() {
        if (VX) return this.value.size;
        return this.stats?.then(($) => $.size) ?? 0;
    }
}
var H8 = 'toJSON' in new Headers(),
    UZ = ($, X) => {
        let W = new URL($);
        return (W.pathname = X), W.toString();
    },
    e_ = ($) =>
        (typeof $ === 'function' && /^\s*class\s+/.test($.toString())) ||
        ($.toString &&
            $.toString().startsWith('[object ') &&
            $.toString() !== '[object Object]') ||
        f$(Object.getPrototypeOf($)),
    lJ = ($) => $ && typeof $ === 'object' && !Array.isArray($),
    t6 = ($, X, W) => {
        let Q = W?.skipKeys,
            Y = W?.override ?? !0;
        if (!lJ($) || !lJ(X)) return $;
        for (let [J, U] of Object.entries(X)) {
            if (Q?.includes(J)) continue;
            if (!lJ(U) || !(J in $) || e_(U)) {
                if (Y || !(J in $)) $[J] = U;
                continue;
            }
            $[J] = t6($[J], U, { skipKeys: Q, override: Y });
        }
        return $;
    },
    vZ = ($, X) => {
        let W = t6(Object.assign({}, $), X, { skipKeys: ['properties'] });
        if (W.properties) delete W.properties;
        return W;
    },
    t$ = ($, X) => {
        if (!X) return $;
        let W = [],
            Q = [];
        if ($) {
            if (!Array.isArray($)) $ = [$];
            for (let Y of $) if ((W.push(Y), Y.checksum)) Q.push(Y.checksum);
        }
        if (X) {
            if (!Array.isArray(X)) X = [X];
            for (let Y of X) if (!Q.includes(Y.checksum)) W.push(Y);
        }
        return W;
    },
    $F = [
        'start',
        'request',
        'parse',
        'transform',
        'resolve',
        'beforeHandle',
        'afterHandle',
        'mapResponse',
        'afterResponse',
        'trace',
        'error',
        'stop',
        'body',
        'headers',
        'params',
        'query',
        'response',
        'type',
        'detail',
    ],
    XF = $F.reduce(($, X) => (($[X] = !0), $), {}),
    fZ = ($, X) => {
        let W = (Q) => typeof Q === 'object' && Object.keys(Q).every(GU);
        if (W($) && W(X)) return Object.assign($, X);
        else if ($ && !W($) && W(X)) return Object.assign({ 200: $ }, X);
        return X ?? $;
    },
    qW = ($, X) => {
        if (!$ && !X)
            return {
                body: void 0,
                headers: void 0,
                params: void 0,
                query: void 0,
                cookie: void 0,
                response: void 0,
            };
        return {
            body: X?.body ?? $?.body,
            headers: X?.headers ?? $?.headers,
            params: X?.params ?? $?.params,
            query: X?.query ?? $?.query,
            cookie: X?.cookie ?? $?.cookie,
            response: fZ($?.response, X?.response),
        };
    },
    x1 = ($, X) => {
        if (!Object.values(X).find((Q) => Q !== void 0 && Q !== null))
            return { ...$ };
        let W = {
            ...$,
            ...X,
            body: X?.body ?? $?.body,
            headers: X?.headers ?? $?.headers,
            params: X?.params ?? $?.params,
            query: X?.query ?? $?.query,
            cookie: X?.cookie ?? $?.cookie,
            response: fZ($?.response, X?.response),
            type: $?.type || X?.type,
            detail: t6(X?.detail ?? {}, $?.detail ?? {}),
            parse: t$($?.parse, X?.parse),
            transform: t$($?.transform, X?.transform),
            beforeHandle: t$(
                t$(D6($?.resolve, 'resolve'), $?.beforeHandle),
                t$(D6(X.resolve, 'resolve'), X?.beforeHandle),
            ),
            afterHandle: t$($?.afterHandle, X?.afterHandle),
            mapResponse: t$($?.mapResponse, X?.mapResponse),
            afterResponse: t$($?.afterResponse, X?.afterResponse),
            trace: t$($?.trace, X?.trace),
            error: t$($?.error, X?.error),
        };
        if (W.resolve) delete W.resolve;
        return W;
    },
    WF = ($) => {
        if ($.parse && !Array.isArray($.parse)) $.parse = [$.parse];
        if ($.transform && !Array.isArray($.transform))
            $.transform = [$.transform];
        if ($.afterHandle && !Array.isArray($.afterHandle))
            $.afterHandle = [$.afterHandle];
        if ($.mapResponse && !Array.isArray($.mapResponse))
            $.mapResponse = [$.mapResponse];
        if ($.afterResponse && !Array.isArray($.afterResponse))
            $.afterResponse = [$.afterResponse];
        if ($.trace && !Array.isArray($.trace)) $.trace = [$.trace];
        if ($.error && !Array.isArray($.error)) $.error = [$.error];
        let X = [];
        if ($.resolve)
            (X = D6(
                Array.isArray($.resolve) ? $.resolve : [$.resolve],
                'resolve',
            )),
                delete $.resolve;
        if ($.beforeHandle)
            if (X.length)
                X = X.concat(
                    Array.isArray($.beforeHandle)
                        ? $.beforeHandle
                        : [$.beforeHandle],
                );
            else
                X = Array.isArray($.beforeHandle)
                    ? $.beforeHandle
                    : [$.beforeHandle];
        if (X.length) $.beforeHandle = X;
        return $;
    },
    YF = typeof Bun !== 'undefined',
    dd = YF && typeof Bun.hash === 'function',
    IX = ($) => {
        let X = 9;
        for (let W = 0; W < $.length; )
            X = Math.imul(X ^ $.charCodeAt(W++), 387420489);
        return (X = X ^ (X >>> 9));
    },
    t4 = ($, X) => {
        if (!X) return;
        if (!Array.isArray(X)) {
            let Q = X;
            if ($ && !Q.checksum) Q.checksum = $;
            if (Q.scope === 'scoped') Q.scope = 'local';
            return Q;
        }
        let W = [...X];
        for (let Q of W) {
            if ($ && !Q.checksum) Q.checksum = $;
            if (Q.scope === 'scoped') Q.scope = 'local';
        }
        return W;
    },
    NZ = ($, X, W) => {
        return {
            start: t$($.start, t4(W, X?.start)),
            request: t$($.request, t4(W, X?.request)),
            parse: t$($.parse, t4(W, X?.parse)),
            transform: t$($.transform, t4(W, X?.transform)),
            beforeHandle: t$(
                t$(D6($.resolve, 'resolve'), $.beforeHandle),
                t4(W, t$(D6(X?.resolve, 'resolve'), X?.beforeHandle)),
            ),
            afterHandle: t$($.afterHandle, t4(W, X?.afterHandle)),
            mapResponse: t$($.mapResponse, t4(W, X?.mapResponse)),
            afterResponse: t$($.afterResponse, t4(W, X?.afterResponse)),
            trace: t$($.trace, t4(W, X?.trace)),
            error: t$($.error, t4(W, X?.error)),
            stop: t$($.stop, t4(W, X?.stop)),
        };
    },
    QF = ($, X, { skipIfHasType: W = !1 }) => {
        if (!$) return $;
        if (!Array.isArray($)) {
            if (W) $.scope ??= X;
            else $.scope = X;
            return $;
        }
        for (let Q of $)
            if (W) Q.scope ??= X;
            else Q.scope = X;
        return $;
    },
    J0 = ($) => {
        if (!$) return $;
        if (!Array.isArray($))
            switch ($.scope) {
                case 'global':
                case 'scoped':
                    return { ...$ };
                default:
                    return { fn: $ };
            }
        let X = [];
        for (let W of $)
            switch (W.scope) {
                case 'global':
                case 'scoped':
                    X.push({ ...W });
                    break;
            }
        return X;
    },
    MZ = ($) => {
        return {
            ...$,
            type: $?.type,
            detail: $?.detail,
            parse: J0($?.parse),
            transform: J0($?.transform),
            beforeHandle: J0($?.beforeHandle),
            afterHandle: J0($?.afterHandle),
            mapResponse: J0($?.mapResponse),
            afterResponse: J0($?.afterResponse),
            error: J0($?.error),
            trace: J0($?.trace),
        };
    },
    C8 = {
        Continue: 100,
        'Switching Protocols': 101,
        Processing: 102,
        'Early Hints': 103,
        OK: 200,
        Created: 201,
        Accepted: 202,
        'Non-Authoritative Information': 203,
        'No Content': 204,
        'Reset Content': 205,
        'Partial Content': 206,
        'Multi-Status': 207,
        'Already Reported': 208,
        'Multiple Choices': 300,
        'Moved Permanently': 301,
        Found: 302,
        'See Other': 303,
        'Not Modified': 304,
        'Temporary Redirect': 307,
        'Permanent Redirect': 308,
        'Bad Request': 400,
        Unauthorized: 401,
        'Payment Required': 402,
        Forbidden: 403,
        'Not Found': 404,
        'Method Not Allowed': 405,
        'Not Acceptable': 406,
        'Proxy Authentication Required': 407,
        'Request Timeout': 408,
        Conflict: 409,
        Gone: 410,
        'Length Required': 411,
        'Precondition Failed': 412,
        'Payload Too Large': 413,
        'URI Too Long': 414,
        'Unsupported Media Type': 415,
        'Range Not Satisfiable': 416,
        'Expectation Failed': 417,
        "I'm a teapot": 418,
        'Misdirected Request': 421,
        'Unprocessable Content': 422,
        Locked: 423,
        'Failed Dependency': 424,
        'Too Early': 425,
        'Upgrade Required': 426,
        'Precondition Required': 428,
        'Too Many Requests': 429,
        'Request Header Fields Too Large': 431,
        'Unavailable For Legal Reasons': 451,
        'Internal Server Error': 500,
        'Not Implemented': 501,
        'Bad Gateway': 502,
        'Service Unavailable': 503,
        'Gateway Timeout': 504,
        'HTTP Version Not Supported': 505,
        'Variant Also Negotiates': 506,
        'Insufficient Storage': 507,
        'Loop Detected': 508,
        'Not Extended': 510,
        'Network Authentication Required': 511,
    },
    GZ = Object.fromEntries(Object.entries(C8).map(([$, X]) => [X, $]));
function JF($) {
    let X = $;
    while (X.endsWith('=')) X = X.slice(0, -1);
    return X;
}
var zZ = new TextEncoder(),
    q8 = async ($, X) => {
        if (typeof $ !== 'string')
            throw new TypeError('Cookie value must be provided as a string.');
        if (X === null) throw new TypeError('Secret key must be provided.');
        let W = await crypto.subtle.importKey(
                'raw',
                zZ.encode(X),
                { name: 'HMAC', hash: 'SHA-256' },
                !1,
                ['sign'],
            ),
            Q = await crypto.subtle.sign('HMAC', W, zZ.encode($));
        return $ + '.' + JF(Buffer.from(Q).toString('base64'));
    },
    ZZ = async ($, X) => {
        if (typeof $ !== 'string')
            throw new TypeError('Signed cookie string must be provided.');
        if (X === null) throw new TypeError('Secret key must be provided.');
        let W = $.slice(0, $.lastIndexOf('.'));
        return (await q8(W, X)) === $ ? W : !1;
    },
    UF = ($, X, W) => {
        if (!$ || typeof $ !== 'object' || !X) return;
        for (let [Q, Y] of Object.entries(X)) {
            if (XF[Q] || !(Q in $)) continue;
            let J = $[Q];
            if (typeof J === 'function') {
                let U = J(Y);
                if (typeof U === 'object')
                    for (let [N, M] of Object.entries(U)) W(N)({ fn: M });
            }
            delete X[Q];
        }
    },
    NF =
        ({ globalHook: $, localHook: X }) =>
        (W) =>
        (Q, Y) => {
            if (typeof Q === 'function') Q = { fn: Q };
            if (W === 'resolve') Q = { ...Q, subType: 'resolve' };
            if (!X[W]) X[W] = [];
            if (typeof X[W] === 'function') X[W] = [X[W]];
            if (!Array.isArray(X[W])) X[W] = [X[W]];
            if ('fn' in Q || Array.isArray(Q)) {
                if (Array.isArray(Q)) X[W] = X[W].concat(Q);
                else X[W].push(Q);
                return;
            }
            let { insert: J = 'after', stack: U = 'local' } = Q;
            if (typeof Y === 'function') Y = { fn: Y };
            if (U === 'global')
                if (!Array.isArray(Y))
                    if (J === 'before') $[W].unshift(Y);
                    else $[W].push(Y);
                else if (J === 'before') $[W] = Y.concat($[W]);
                else $[W] = $[W].concat(Y);
            else if (!Array.isArray(Y))
                if (J === 'before') X[W].unshift(Y);
                else X[W].push(Y);
            else if (J === 'before') X[W] = Y.concat(X[W]);
            else X[W] = X[W].concat(Y);
        },
    MF = ($) => {
        if (typeof $ === 'number') return $;
        if ($.length < 16) {
            if ($.trim().length === 0) return null;
            let X = Number($);
            if (Number.isNaN(X)) return null;
            return X;
        }
        if ($.length === 16) {
            if ($.trim().length === 0) return null;
            let X = Number($);
            if (Number.isNaN(X) || X.toString() !== $) return null;
            return X;
        }
        return null;
    },
    GU = ($) => MF($) !== null;
class yZ {
    onError;
    onFinally;
    root = null;
    promises = [];
    constructor($ = console.error, X = () => {}) {
        (this.onError = $), (this.onFinally = X);
    }
    get size() {
        return this.promises.length;
    }
    add($) {
        if (
            (this.promises.push($),
            (this.root ||= this.drain()),
            this.promises.length === 1)
        )
            this.then(this.onFinally);
        return $;
    }
    async drain() {
        while (this.promises.length > 0) {
            try {
                await this.promises[0];
            } catch ($) {
                this.onError($);
            }
            this.promises.shift();
        }
        this.root = null;
    }
    then($, X) {
        return (this.root ?? Promise.resolve()).then($, X);
    }
}
var D6 = ($, X) => {
        if (!$) return $;
        if (!Array.isArray($)) {
            if (typeof $ === 'function' || typeof $ === 'string')
                return X ? { fn: $, subType: X } : { fn: $ };
            else if ('fn' in $) return $;
        }
        let W = [];
        for (let Q of $)
            if (typeof Q === 'function' || typeof Q === 'string')
                W.push(X ? { fn: Q, subType: X } : { fn: Q });
            else if ('fn' in Q) W.push(Q);
        return W;
    },
    wZ = ($) => {
        if ($.start) $.start = D6($.start);
        if ($.request) $.request = D6($.request);
        if ($.parse) $.parse = D6($.parse);
        if ($.transform) $.transform = D6($.transform);
        if ($.beforeHandle) $.beforeHandle = D6($.beforeHandle);
        if ($.afterHandle) $.afterHandle = D6($.afterHandle);
        if ($.mapResponse) $.mapResponse = D6($.mapResponse);
        if ($.afterResponse) $.afterResponse = D6($.afterResponse);
        if ($.trace) $.trace = D6($.trace);
        if ($.error) $.error = D6($.error);
        if ($.stop) $.stop = D6($.stop);
        return $;
    },
    DZ = ($) => {
        if ($.start?.map) $.start = $.start.map((X) => X.fn);
        if ($.request?.map) $.request = $.request.map((X) => X.fn);
        if ($.parse?.map) $.parse = $.parse.map((X) => X.fn);
        if ($.transform?.map) $.transform = $.transform.map((X) => X.fn);
        if ($.beforeHandle?.map)
            $.beforeHandle = $.beforeHandle.map((X) => X.fn);
        if ($.afterHandle?.map) $.afterHandle = $.afterHandle.map((X) => X.fn);
        if ($.mapResponse?.map) $.mapResponse = $.mapResponse.map((X) => X.fn);
        if ($.afterResponse?.map)
            $.afterResponse = $.afterResponse.map((X) => X.fn);
        if ($.trace?.map) $.trace = $.trace.map((X) => X.fn);
        else $.trace = [];
        if ($.error?.map) $.error = $.error.map((X) => X.fn);
        if ($.stop?.map) $.stop = $.stop.map((X) => X.fn);
        return $;
    },
    BZ = ($) => ({
        body: $.body,
        cookie: $.cookie,
        headers: $.headers,
        query: $.query,
        set: $.set,
        server: $.server,
        path: $.path,
        route: $.route,
        url: $.url,
    }),
    zU = ($, X = 302) => Response.redirect($, X),
    v0 = Symbol('ElysiaFormData'),
    RW = Symbol('ElysiaRequestId'),
    GF = ($) => {
        let X = new FormData();
        if (((X[v0] = {}), $))
            for (let [W, Q] of Object.entries($)) {
                if (Array.isArray(Q)) {
                    X[v0][W] = [];
                    for (let Y of Q) {
                        if (Q instanceof File) X.append(W, Q, Q.name);
                        else if (Q instanceof O8)
                            X.append(W, Q.value, Q.value?.name);
                        else X.append(W, Q);
                        X[v0][W].push(Q);
                    }
                    continue;
                }
                if (Q instanceof File) X.append(W, Q, Q.name);
                else if (Q instanceof O8) X.append(W, Q.value, Q.value?.name);
                else X.append(W, Q);
                X[v0][W] = Q;
            }
        return X;
    },
    R8 = () => {
        let $ = crypto.randomUUID();
        return $.slice(0, 8) + $.slice(24, 32);
    },
    OZ = ($) => {
        if (!$.length) return [];
        let X = [];
        for (let W = 0; W < $.length; W++) {
            let Q = $[W];
            if (Q.checksum) {
                if (X.includes(Q.checksum)) $.splice(W, 1), W--;
                X.push(Q.checksum);
            }
        }
        return $;
    },
    U0 = ($, X = 'scoped') => {
        if (!$) return;
        if (X === 'scoped') {
            for (let W of $)
                if ('scope' in W && W.scope === 'local') W.scope = 'scoped';
            return;
        }
        for (let W of $) if ('scope' in W) W.scope = 'global';
    },
    PW = ($) => {
        if ($.charCodeAt($.length - 1) === 47) return $.slice(0, $.length - 1);
        return $ + '/';
    },
    f$ = ($) => {
        if (!$) return !1;
        for (let X in $) return !0;
        return !1;
    },
    SW = ($, { dynamic: X = !1 } = {}) => {
        let W = encodeURIComponent($).replace(/%2F/g, '/');
        if (X) W = W.replace(/%3A/g, ':').replace(/%3F/g, '?');
        return W;
    },
    hZ = (() => {
        if (typeof Bun === 'undefined') return !0;
        let $ = Bun.version.split('.');
        if (+$[0] < 1 || +$[1] < 2 || +$[2] < 14) return !1;
        return !0;
    })();
var HZ =
        typeof Bun !== 'undefined'
            ? Bun.env
            : typeof process !== 'undefined'
              ? process?.env
              : void 0,
    A8 = Symbol('ElysiaErrorCode'),
    IW = (HZ?.NODE_ENV ?? HZ?.ENV) === 'production';
class g6 {
    code;
    response;
    constructor($, X) {
        let W = X ?? ($ in GZ ? GZ[$] : $);
        (this.code = C8[$] ?? $), (this.response = W);
    }
}
var P8 = ($, X) => new g6($, X);
class ZU extends Error {
    code = 'NOT_FOUND';
    status = 404;
    constructor($) {
        super($ ?? 'NOT_FOUND');
    }
}
class mZ extends Error {
    code = 'PARSE';
    status = 400;
    constructor($) {
        super('Bad Request', { cause: $ });
    }
}
class XU extends Error {
    key;
    code = 'INVALID_COOKIE_SIGNATURE';
    status = 400;
    constructor($, X) {
        super(X ?? `"${$}" has invalid cookie signature`);
        this.key = $;
    }
}
var s4 = ($) => {
    if (!$) return { summary: void 0 };
    let { message: X, path: W, value: Q, type: Y } = $,
        J = W.slice(1).replaceAll('/', '.'),
        U = W === '';
    switch (Y) {
        case 42:
            return {
                ...$,
                summary: U
                    ? 'Value should not be provided'
                    : `Property '${J}' should not be provided`,
            };
        case 45:
            return {
                ...$,
                summary: U ? 'Value is missing' : `Property '${J}' is missing`,
            };
        case 50:
            let N = X.indexOf("'"),
                M = X.slice(N + 1, X.indexOf("'", N + 1));
            return {
                ...$,
                summary: U
                    ? 'Value should be an email'
                    : `Property '${J}' should be ${M}`,
            };
        case 54:
            return {
                ...$,
                summary: `${X.slice(0, 9).trim()} property '${J}' to be ${X.slice(8).trim()} but found: ${Q}`,
            };
        case 62:
            let G = $.schema.anyOf
                .map((Z) => `'${Z?.format ?? Z.type}'`)
                .join(', ');
            return {
                ...$,
                summary: U
                    ? `Value should be one of ${G}`
                    : `Property '${J}' should be one of: ${G}`,
            };
        default:
            return { summary: X, ...$ };
    }
};
class KW extends Error {
    property;
    expected;
    message;
    code = 'INVALID_FILE_TYPE';
    status = 422;
    constructor($, X, W = `"${$}" has invalid file type`) {
        super(W);
        (this.property = $),
            (this.expected = X),
            (this.message = W),
            Object.setPrototypeOf(this, KW.prototype);
    }
    toResponse($) {
        if (IW)
            return new Response(
                JSON.stringify({ type: 'validation', on: 'body' }),
                {
                    status: 422,
                    headers: { ...$, 'content-type': 'application/json' },
                },
            );
        return new Response(
            JSON.stringify({
                type: 'validation',
                on: 'body',
                summary: 'Invalid file type',
                message: this.message,
                property: this.property,
                expected: this.expected,
            }),
            {
                status: 422,
                headers: { ...$, 'content-type': 'application/json' },
            },
        );
    }
}
class V$ extends Error {
    type;
    validator;
    value;
    code = 'VALIDATION';
    status = 422;
    constructor($, X, W, Q) {
        if (W && typeof W === 'object' && W instanceof g6) W = W.response;
        let Y =
                Q?.First() ||
                (IW
                    ? void 0
                    : 'Errors' in X
                      ? X.Errors(W).First()
                      : L$.Errors(X, W).First()),
            J =
                Y?.schema?.message || Y?.schema?.error !== void 0
                    ? typeof Y.schema.error === 'function'
                        ? Y.schema.error({
                              type: $,
                              validator: X,
                              value: W,
                              get errors() {
                                  return [...X.Errors(W)].map(s4);
                              },
                          })
                        : Y.schema.error
                    : void 0,
            U = Y?.path || 'root',
            N = '';
        if (J !== void 0)
            N = typeof J === 'object' ? JSON.stringify(J) : J + '';
        else if (IW)
            N = JSON.stringify({
                type: 'validation',
                on: $,
                summary: s4(Y).summary,
                message: Y?.message,
                found: W,
            });
        else {
            let M = X?.schema ?? X,
                G =
                    'Errors' in X
                        ? [...X.Errors(W)].map(s4)
                        : [...L$.Errors(X, W)].map(s4),
                Z;
            try {
                Z = L$.Create(M);
            } catch (B) {
                Z = {
                    type: 'Could not create expected value',
                    message: B?.message,
                    error: B,
                };
            }
            N = JSON.stringify(
                {
                    type: 'validation',
                    on: $,
                    summary: s4(Y).summary,
                    property: U,
                    message: Y?.message,
                    expected: Z,
                    found: W,
                    errors: G,
                },
                null,
                2,
            );
        }
        super(N);
        (this.type = $),
            (this.validator = X),
            (this.value = W),
            Object.setPrototypeOf(this, V$.prototype);
    }
    get all() {
        return 'Errors' in this.validator
            ? [...this.validator.Errors(this.value)].map(s4)
            : [...L$.Errors(this.validator, this.value)].map(s4);
    }
    static simplifyModel($) {
        let X = 'schema' in $ ? $.schema : $;
        try {
            return L$.Create(X);
        } catch {
            return X;
        }
    }
    get model() {
        return V$.simplifyModel(this.validator);
    }
    toResponse($) {
        return new Response(this.message, {
            status: 400,
            headers: { ...$, 'content-type': 'application/json' },
        });
    }
}
var M8 = ($, X) => {
    try {
        return JSON.parse($);
    } catch {
        throw new V$('property', X, $);
    }
};
function V8($, X) {
    if (!Z6.Has($)) Z6.Set($, X);
    return (W = {}) => hY({ ...W, [S]: $ });
}
var T0 = ($) => {
        try {
            let X = Q1.Compile($);
            return (
                (X.Create = () => L$.Create($)),
                (X.Error = (W) => new V$('property', $, W, X.Errors(W))),
                X
            );
        } catch {
            return {
                Check: (X) => L$.Check($, X),
                CheckThrow: (X) => {
                    if (!L$.Check($, X))
                        throw new V$('property', $, X, L$.Errors($, X));
                },
                Decode: (X) => L$.Decode($, X),
                Create: () => L$.Create($),
                Error: (X) => new V$('property', $, X, L$.Errors($, X)),
            };
        }
    },
    qZ = ($) => {
        if (typeof $ === 'string')
            switch ($.slice(-1)) {
                case 'k':
                    return +$.slice(0, $.length - 1) * 1024;
                case 'm':
                    return +$.slice(0, $.length - 1) * 1048576;
                default:
                    return +$;
            }
        return $;
    },
    S8 = ($, X) => {
        if ($.startsWith(X)) return !0;
        return (
            X.charCodeAt(X.length - 1) === 42 &&
            X.charCodeAt(X.length - 2) === 47 &&
            $.startsWith(X.slice(0, -1))
        );
    },
    AZ = !1,
    zF = () => {
        if (!AZ)
            console.warn(
                "[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension.",
            ),
                (AZ = !0);
    },
    wU = async () =>
        Promise.resolve()
            .then(() => (ez(), sz))
            .then(($) => {
                return (j8 = $.fileTypeFromBlob), j8;
            })
            .catch(zF),
    j8,
    ZF = ($) => {
        if (j8) return j8($);
        return wU().then((X) => {
            if (X) return X($);
        });
    },
    cZ = async ($, X, W = $?.name ?? '') => {
        if (Array.isArray($))
            return await Promise.all($.map((Y) => cZ(Y, X, W))), !0;
        if (!$) return !1;
        let Q = await ZF($);
        if (!Q) throw new KW(W, X);
        if (typeof X === 'string') {
            if (!S8(Q.mime, X)) throw new KW(W, X);
        }
        for (let Y = 0; Y < X.length; Y++) if (S8(Q.mime, X[Y])) return !0;
        throw new KW(W, X);
    },
    WU = ($, X) => {
        if (X instanceof O8) return !0;
        if (!(X instanceof Blob)) return !1;
        if ($.minSize && X.size < qZ($.minSize)) return !1;
        if ($.maxSize && X.size > qZ($.maxSize)) return !1;
        if ($.extension) {
            if (typeof $.extension === 'string') return S8(X.type, $.extension);
            for (let W = 0; W < $.extension.length; W++)
                if (S8(X.type, $.extension[W])) return !0;
            return !1;
        }
        return !0;
    },
    c = Object.assign({}, F1);
V8(
    'UnionEnum',
    ($, X) =>
        (typeof X === 'number' || typeof X === 'string' || X === null) &&
        $.enum.includes(X),
);
var wF = V8('Files', ($, X) => {
        if (!Array.isArray(X)) return WU($, X);
        if ($.minItems && X.length < $.minItems) return !1;
        if ($.maxItems && X.length > $.maxItems) return !1;
        for (let W = 0; W < X.length; W++) if (!WU($, X[W])) return !1;
        return !0;
    }),
    DF = V8('ElysiaForm', ({ compiler: $, ...X }, W) => {
        if (!(W instanceof FormData)) return !1;
        if ($) {
            if (!(v0 in W)) throw new V$('property', X, W);
            if (!$.Check(W[v0])) throw $.Error(W[v0]);
        }
        return !0;
    }),
    e6 = {
        String: ($) => F1.String($),
        Numeric: ($) => {
            let X = F1.Number($),
                W = T0(X);
            return c
                .Transform(
                    c.Union(
                        [
                            c.String({ format: 'numeric', default: 0 }),
                            c.Number($),
                        ],
                        $,
                    ),
                )
                .Decode((Q) => {
                    let Y = +Q;
                    if (isNaN(Y)) return Q;
                    if ($ && !W.Check(Y)) throw W.Error(Q);
                    return Y;
                })
                .Encode((Q) => Q);
        },
        Integer: ($) => {
            let X = F1.Integer($),
                W = T0(X);
            return c
                .Transform(
                    c.Union(
                        [
                            c.String({ format: 'integer', default: 0 }),
                            F1.Integer($),
                        ],
                        $,
                    ),
                )
                .Decode((Q) => {
                    let Y = +Q;
                    if (!W.Check(Y)) throw W.Error(Y);
                    return Y;
                })
                .Encode((Q) => Q);
        },
        Date: ($) => {
            let X = F1.Date($),
                W = T0(X),
                Q = $?.default ? new Date($.default) : void 0;
            return c
                .Transform(
                    c.Union(
                        [
                            F1.Date($),
                            c.String({
                                format: 'date-time',
                                default: Q?.toISOString(),
                            }),
                            c.String({
                                format: 'date',
                                default: Q?.toISOString(),
                            }),
                            c.Number({ default: Q?.getTime() }),
                        ],
                        $,
                    ),
                )
                .Decode((Y) => {
                    if (typeof Y === 'number') {
                        let U = new Date(Y);
                        if (!W.Check(U)) throw W.Error(U);
                        return U;
                    }
                    if (Y instanceof Date) return Y;
                    let J = new Date(bZ(Y));
                    if (!J || isNaN(J.getTime()))
                        throw new V$('property', X, J);
                    if (!W.Check(J)) throw W.Error(J);
                    return J;
                })
                .Encode((Y) => Y.toISOString());
        },
        BooleanString: ($) => {
            let X = F1.Boolean($),
                W = T0(X);
            return c
                .Transform(
                    c.Union(
                        [
                            c.Boolean($),
                            c.String({ format: 'boolean', default: !1 }),
                        ],
                        $,
                    ),
                )
                .Decode((Q) => {
                    if (typeof Q === 'string') return Q === 'true';
                    if (Q !== void 0 && !W.Check(Q)) throw W.Error(Q);
                    return Q;
                })
                .Encode((Q) => Q);
        },
        ObjectString: ($, X) => {
            let W = c.Object($, X),
                Q = T0(W),
                Y = JSON.stringify(Q.Create());
            return c
                .Transform(
                    c.Union([
                        c.String({ format: 'ObjectString', default: Y }),
                        W,
                    ]),
                )
                .Decode((J) => {
                    if (typeof J === 'string') {
                        if (J.charCodeAt(0) !== 123)
                            throw new V$('property', W, J);
                        if (!Q.Check((J = M8(J, W)))) throw Q.Error(J);
                        return Q.Decode(J);
                    }
                    return J;
                })
                .Encode((J) => {
                    let U;
                    if (typeof J === 'string') J = M8((U = J), W);
                    if (!Q.Check(J)) throw Q.Error(J);
                    return U ?? JSON.stringify(J);
                });
        },
        ArrayString: ($ = c.String(), X) => {
            let W = c.Array($, X),
                Q = T0(W),
                Y = (J, U = !1) => {
                    if (J.charCodeAt(0) === 91) {
                        if (!Q.Check((J = M8(J, W)))) throw Q.Error(J);
                        return Q.Decode(J);
                    }
                    if (J.indexOf(',') !== -1) {
                        if (!Q.Check(J)) throw Q.Error(J);
                        return Q.Decode(J);
                    }
                    if (U) return J;
                    throw new V$('property', W, J);
                };
            return c
                .Transform(
                    c.Union([
                        c.String({
                            format: 'ArrayString',
                            default: X?.default,
                        }),
                        W,
                    ]),
                )
                .Decode((J) => {
                    if (Array.isArray(J)) {
                        let U = [];
                        for (let N = 0; N < J.length; N++) {
                            let M = J[N];
                            if (typeof M === 'string') {
                                let G = Y(M, !0);
                                if (Array.isArray(G)) U = U.concat(G);
                                else U.push(G);
                                continue;
                            }
                            U.push(M);
                        }
                        return U;
                    }
                    if (typeof J === 'string') return Y(J);
                    return J;
                })
                .Encode((J) => {
                    let U;
                    if (typeof J === 'string') J = M8((U = J), W);
                    if (!Q.Check(J)) throw new V$('property', W, J);
                    return U ?? JSON.stringify(J);
                });
        },
        File: V8('File', WU),
        Files: ($ = {}) =>
            c
                .Transform(wF($))
                .Decode((X) => {
                    if (Array.isArray(X)) return X;
                    return [X];
                })
                .Encode((X) => X),
        Nullable: ($, X) => c.Union([$, c.Null()], X),
        MaybeEmpty: ($, X) => c.Union([$, c.Null(), c.Undefined()], X),
        Cookie: (
            $,
            {
                domain: X,
                expires: W,
                httpOnly: Q,
                maxAge: Y,
                path: J,
                priority: U,
                sameSite: N,
                secure: M,
                secrets: G,
                sign: Z,
                ...B
            } = {},
        ) => {
            let O = c.Object($, B);
            return (
                (O.config = {
                    domain: X,
                    expires: W,
                    httpOnly: Q,
                    maxAge: Y,
                    path: J,
                    priority: U,
                    sameSite: N,
                    secure: M,
                    secrets: G,
                    sign: Z,
                }),
                O
            );
        },
        UnionEnum: ($, X = {}) => {
            let W = $.every((Q) => typeof Q === 'string')
                ? { type: 'string' }
                : $.every((Q) => typeof Q === 'number')
                  ? { type: 'number' }
                  : $.every((Q) => Q === null)
                    ? { type: 'null' }
                    : {};
            if ($.some((Q) => typeof Q === 'object' && Q !== null))
                throw new Error('This type does not support objects or arrays');
            return { default: $[0], ...X, [S]: 'UnionEnum', ...W, enum: $ };
        },
        NoValidate: ($, X = !0) => {
            return ($.noValidate = X), $;
        },
        Form: ($, X = {}) => {
            let W = c.Object($, { default: GF({}), ...X }),
                Q = T0(W);
            return c.Union([W, DF({ compiler: Q })]);
        },
    };
c.BooleanString = e6.BooleanString;
c.ObjectString = e6.ObjectString;
c.ArrayString = e6.ArrayString;
c.Numeric = e6.Numeric;
c.Integer = e6.Integer;
c.File = ($) => {
    if ($?.type) wU();
    return e6.File({
        default: 'File',
        ...$,
        extension: $?.type,
        type: 'string',
        format: 'binary',
    });
};
c.Files = ($) => {
    if ($?.type) wU();
    return e6.Files({
        ...$,
        elysiaMeta: 'Files',
        default: 'Files',
        extension: $?.type,
        type: 'array',
        items: { ...$, default: 'Files', type: 'string', format: 'binary' },
    });
};
c.Nullable = ($) => e6.Nullable($);
c.MaybeEmpty = e6.MaybeEmpty;
c.Cookie = e6.Cookie;
c.Date = e6.Date;
c.UnionEnum = e6.UnionEnum;
c.NoValidate = e6.NoValidate;
c.Form = e6.Form;
var BF = ($) => {
        if ($.startsWith('async')) $ = $.slice(5);
        $ = $.trimStart();
        let X = -1;
        if ($.charCodeAt(0) === 40) {
            if (((X = $.indexOf('=>', $.indexOf(')'))), X !== -1)) {
                let Y = X;
                while (Y > 0) if ($.charCodeAt(--Y) === 41) break;
                let J = $.slice(X + 2);
                if (J.charCodeAt(0) === 32) J = J.trimStart();
                return [
                    $.slice(1, Y),
                    J,
                    { isArrowReturn: J.charCodeAt(0) !== 123 },
                ];
            }
        }
        if (/^(\w+)=>/g.test($)) {
            if (((X = $.indexOf('=>')), X !== -1)) {
                let Y = $.slice(X + 2);
                if (Y.charCodeAt(0) === 32) Y = Y.trimStart();
                return [
                    $.slice(0, X),
                    Y,
                    { isArrowReturn: Y.charCodeAt(0) !== 123 },
                ];
            }
        }
        if ($.startsWith('function')) {
            X = $.indexOf('(');
            let Y = $.indexOf(')');
            return [$.slice(X + 1, Y), $.slice(Y + 2), { isArrowReturn: !1 }];
        }
        let W = $.indexOf('(');
        if (W !== -1) {
            let Y = $.indexOf(
                    `
`,
                    2,
                ),
                J = $.slice(0, Y),
                U = J.lastIndexOf(')') + 1,
                N = $.slice(Y + 1);
            return [J.slice(W, U), '{' + N, { isArrowReturn: !1 }];
        }
        let Q = $.split(
            `
`,
            2,
        );
        return [Q[0], Q[1], { isArrowReturn: !1 }];
    },
    OF = ($) => {
        let X = $.indexOf('{');
        if (X === -1) return [-1, 0];
        let W = X + 1,
            Q = 1;
        for (; W < $.length; W++) {
            let Y = $.charCodeAt(W);
            if (Y === 123) Q++;
            else if (Y === 125) Q--;
            if (Q === 0) break;
        }
        if (Q !== 0) return [0, $.length];
        return [X, W + 1];
    },
    HF = ($) => {
        let X = $.lastIndexOf('}');
        if (X === -1) return [-1, 0];
        let W = X - 1,
            Q = 1;
        for (; W >= 0; W--) {
            let Y = $.charCodeAt(W);
            if (Y === 125) Q++;
            else if (Y === 123) Q--;
            if (Q === 0) break;
        }
        if (Q !== 0) return [-1, 0];
        return [W, X + 1];
    },
    uZ = ($) => {
        while (!0) {
            let X = $.indexOf(':');
            if (X === -1) break;
            let W = $.indexOf(',', X);
            if (W === -1) W = $.indexOf('}', X) - 1;
            if (W === -2) W = $.length;
            $ = $.slice(0, X) + $.slice(W);
        }
        return $;
    },
    dZ = ($) => {
        let X = !1;
        if ($.charCodeAt(0) === 40) $ = $.slice(1, -1);
        if ($.charCodeAt(0) === 123) (X = !0), ($ = $.slice(1, -1));
        $ = $.replace(/( |\t|\n)/g, '').trim();
        let W = [];
        while (!0) {
            let [Y, J] = OF($);
            if (Y === -1) break;
            if ((W.push($.slice(0, Y - 1)), $.charCodeAt(J) === 44)) J++;
            $ = $.slice(J);
        }
        if ((($ = uZ($)), $)) W = W.concat($.split(','));
        let Q = Object.create(null);
        for (let Y of W) {
            if (Y.indexOf(',') === -1) {
                Q[Y] = !0;
                continue;
            }
            for (let J of Y.split(',')) Q[J.trim()] = !0;
        }
        return { hasParenthesis: X, parameters: Q };
    },
    qF = ($, X) => {
        let { parameters: W, hasParenthesis: Q } = dZ($);
        if (W.query) X.query = !0;
        if (W.headers) X.headers = !0;
        if (W.body) X.body = !0;
        if (W.cookie) X.cookie = !0;
        if (W.set) X.set = !0;
        if (W.server) X.server = !0;
        if (W.route) X.route = !0;
        if (W.url) X.url = !0;
        if (W.path) X.path = !0;
        if (Q) return `{ ${Object.keys(W).join(', ')} }`;
        return Object.keys(W).join(', ');
    },
    PZ = ($, X, W) => {
        let Q = new RegExp(
            `${$.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}[\\n\\t,; ]`,
        );
        if (W !== void 0) Q.lastIndex = W;
        let Y = Q.exec(X);
        return Y ? Y.index : -1;
    },
    iZ = ($, X, W = 0) => {
        if (W > 5) return [];
        let Q = [],
            Y = X;
        while (!0) {
            let J = PZ(' = ' + $, Y);
            if (J === -1) J = PZ('=' + $, Y);
            if (J === -1) {
                let G = Y.indexOf(' = ' + $);
                if (G === -1) G = Y.indexOf('=' + $);
                if (G + 3 + $.length !== Y.length) break;
                J = G;
            }
            let U = Y.slice(0, J),
                N = U.lastIndexOf(' '),
                M = U.slice(N !== -1 ? N + 1 : -1);
            if (M === '}') {
                let [G, Z] = HF(U);
                Q.push(uZ(Y.slice(G, Z))), (Y = Y.slice(J + 3 + $.length));
                continue;
            }
            while (M.charCodeAt(0) === 44) M = M.slice(1);
            while (M.charCodeAt(0) === 9) M = M.slice(1);
            if (!M.includes('(')) Q.push(M);
            Y = Y.slice(J + 3 + $.length);
        }
        for (let J of Q) {
            if (J.charCodeAt(0) === 123) continue;
            let U = iZ(J, X);
            if (U.length > 0) Q.push(...U);
        }
        return Q;
    },
    AF = ($) => {
        if (!$) return;
        if ($.charCodeAt(0) !== 123) return $;
        if ((($ = $.slice(2, -2)), !$.includes(','))) {
            if ($.indexOf('...') !== -1) return $.slice($.indexOf('...') + 3);
            return;
        }
        let X = $.indexOf('...');
        if (X === -1) return;
        return $.slice(X + 3).trimEnd();
    },
    PF = ($, X, W) => {
        let Q = (Y, J) =>
            new RegExp(`${J}\\.(${Y})|${J}\\["${Y}"\\]|${J}\\['${Y}'\\]`).test(
                $,
            );
        for (let Y of X) {
            if (!Y) continue;
            if (Y.charCodeAt(0) === 123) {
                let J = dZ(Y).parameters;
                if (J.query) W.query = !0;
                if (J.headers) W.headers = !0;
                if (J.body) W.body = !0;
                if (J.cookie) W.cookie = !0;
                if (J.set) W.set = !0;
                if (J.server) W.server = !0;
                if (J.url) W.url = !0;
                if (J.route) W.route = !0;
                if (J.path) W.path = !0;
                continue;
            }
            if (
                !W.query &&
                (Q('query', Y) ||
                    $.includes('return ' + Y) ||
                    $.includes('return ' + Y + '.query'))
            )
                W.query = !0;
            if (!W.headers && Q('headers', Y)) W.headers = !0;
            if (!W.body && Q('body', Y)) W.body = !0;
            if (!W.cookie && Q('cookie', Y)) W.cookie = !0;
            if (!W.set && Q('set', Y)) W.set = !0;
            if (!W.server && Q('server', Y)) W.server = !0;
            if (!W.route && Q('route', Y)) W.route = !0;
            if (!W.url && Q('url', Y)) W.url = !0;
            if (!W.path && Q('path', Y)) W.path = !0;
            if (
                W.query &&
                W.headers &&
                W.body &&
                W.cookie &&
                W.set &&
                W.server &&
                W.route &&
                W.url &&
                W.path
            )
                break;
        }
        return X;
    },
    SF = ($, X, W) => {
        try {
            let Q = new RegExp(`\\w\\((.*?)?${$}`, 'gs');
            Q.test(X);
            let Y = X.charCodeAt(Q.lastIndex);
            if (Y === 41 || Y === 44)
                return (
                    (W.query = !0),
                    (W.headers = !0),
                    (W.body = !0),
                    (W.cookie = !0),
                    (W.set = !0),
                    (W.server = !0),
                    (W.url = !0),
                    (W.route = !0),
                    (W.path = !0),
                    !0
                );
            return !1;
        } catch (Q) {
            return (
                console.log(
                    '[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:',
                ),
                console.log('--- body ---'),
                console.log(X),
                console.log('--- context ---'),
                console.log($),
                !0
            );
        }
    },
    G8,
    w8 = {},
    SZ = ($ = 0) => {
        if (G8) clearTimeout(G8);
        G8 = setTimeout(() => {
            if (((w8 = {}), (G8 = void 0), VX)) Bun.gc(!1);
        }, $);
    },
    YU = ($, X) => {
        return {
            body: $.body || X.body,
            cookie: $.cookie || X.cookie,
            headers: $.headers || X.headers,
            query: $.query || X.query,
            set: $.set || X.set,
            server: $.server || X.server,
            url: $.url || X.url,
            route: $.route || X.route,
            path: $.path || X.path,
        };
    },
    CW = (
        $,
        X = {
            query: !1,
            headers: !1,
            body: !1,
            cookie: !1,
            set: !1,
            server: !1,
            url: !1,
            route: !1,
            path: !1,
        },
    ) => {
        let W = [];
        if ($.request?.length) W.push(...$.request);
        if ($.beforeHandle?.length) W.push(...$.beforeHandle);
        if ($.parse?.length) W.push(...$.parse);
        if ($.error?.length) W.push(...$.error);
        if ($.transform?.length) W.push(...$.transform);
        if ($.afterHandle?.length) W.push(...$.afterHandle);
        if ($.mapResponse?.length) W.push(...$.mapResponse);
        if ($.afterResponse?.length) W.push(...$.afterResponse);
        if ($.handler && typeof $.handler === 'function') W.push($.handler);
        for (let Q = 0; Q < W.length; Q++) {
            let Y = W[Q];
            if (!Y) continue;
            let J = typeof Y === 'object' ? Y.fn : Y;
            if (typeof J !== 'function') continue;
            let U = J.toString(),
                N = IX(U),
                M = w8[N];
            if (M) {
                X = YU(X, M);
                continue;
            }
            let G = {
                    query: !1,
                    headers: !1,
                    body: !1,
                    cookie: !1,
                    set: !1,
                    server: !1,
                    url: !1,
                    route: !1,
                    path: !1,
                },
                [Z, B] = BF(U),
                O = qF(Z, G),
                w = AF(O);
            if (w) {
                let z = iZ(w, B.slice(1, -1));
                z.splice(0, -1, w);
                let H = B;
                if (
                    H.charCodeAt(0) === 123 &&
                    H.charCodeAt(B.length - 1) === 125
                )
                    H = H.slice(1, -1);
                if (!SF(w, H, G)) PF(H, z, G);
                if (!G.query && H.includes('return ' + w + '.query'))
                    G.query = !0;
            }
            if (!w8[N]) w8[N] = G;
            if (
                ((X = YU(X, G)),
                X.query &&
                    X.headers &&
                    X.body &&
                    X.cookie &&
                    X.set &&
                    X.server &&
                    X.url &&
                    X.route &&
                    X.path)
            )
                break;
        }
        return X;
    },
    nZ = I8(g_(), 1),
    jF = I8(NU(), 1);
class f1 {
    name;
    jar;
    initial;
    constructor($, X, W = {}) {
        (this.name = $), (this.jar = X), (this.initial = W);
    }
    get cookie() {
        return this.jar[this.name] ?? this.initial;
    }
    set cookie($) {
        if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
        this.jar[this.name] = $;
    }
    get setCookie() {
        if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
        return this.jar[this.name];
    }
    set setCookie($) {
        this.cookie = $;
    }
    get value() {
        return this.cookie.value;
    }
    set value($) {
        this.setCookie.value = $;
    }
    get expires() {
        return this.cookie.expires;
    }
    set expires($) {
        this.setCookie.expires = $;
    }
    get maxAge() {
        return this.cookie.maxAge;
    }
    set maxAge($) {
        this.setCookie.maxAge = $;
    }
    get domain() {
        return this.cookie.domain;
    }
    set domain($) {
        this.setCookie.domain = $;
    }
    get path() {
        return this.cookie.path;
    }
    set path($) {
        this.setCookie.path = $;
    }
    get secure() {
        return this.cookie.secure;
    }
    set secure($) {
        this.setCookie.secure = $;
    }
    get httpOnly() {
        return this.cookie.httpOnly;
    }
    set httpOnly($) {
        this.setCookie.httpOnly = $;
    }
    get sameSite() {
        return this.cookie.sameSite;
    }
    set sameSite($) {
        this.setCookie.sameSite = $;
    }
    get priority() {
        return this.cookie.priority;
    }
    set priority($) {
        this.setCookie.priority = $;
    }
    get partitioned() {
        return this.cookie.partitioned;
    }
    set partitioned($) {
        this.setCookie.partitioned = $;
    }
    get secrets() {
        return this.cookie.secrets;
    }
    set secrets($) {
        this.setCookie.secrets = $;
    }
    update($) {
        return (
            (this.setCookie = Object.assign(
                this.cookie,
                typeof $ === 'function' ? $(this.cookie) : $,
            )),
            this
        );
    }
    set($) {
        return (
            (this.setCookie = Object.assign(
                { ...this.initial, value: this.value },
                typeof $ === 'function' ? $(this.cookie) : $,
            )),
            this
        );
    }
    remove() {
        if (this.value === void 0) return;
        return this.set({ expires: new Date(0), maxAge: 0, value: '' }), this;
    }
    toString() {
        return typeof this.value === 'object'
            ? JSON.stringify(this.value)
            : (this.value?.toString() ?? '');
    }
}
var jZ = ($, X, W) => {
        if (!$.cookie) $.cookie = {};
        return new Proxy(X, {
            get(Q, Y) {
                if (Y in X)
                    return new f1(
                        Y,
                        $.cookie,
                        Object.assign({}, W ?? {}, X[Y]),
                    );
                return new f1(Y, $.cookie, Object.assign({}, W));
            },
        });
    },
    pZ = async ($, X, { secrets: W, sign: Q, ...Y } = {}) => {
        if (!X) return jZ($, {}, Y);
        let J = typeof W === 'string';
        if (Q && Q !== !0 && !Array.isArray(Q)) Q = [Q];
        let U = {},
            N = nZ.parse(X);
        for (let [M, G] of Object.entries(N)) {
            if (G === void 0) continue;
            let Z = jF.default(G);
            if (Q === !0 || Q?.includes(M)) {
                if (!W)
                    throw new Error('No secret is provided to cookie plugin');
                if (J) {
                    let B = await ZZ(Z, W);
                    if (B === !1) throw new XU(M);
                    Z = B;
                } else {
                    let B = !0;
                    for (let O = 0; O < W.length; O++) {
                        let w = await ZZ(Z, W[O]);
                        if (w !== !1) {
                            (B = !0), (Z = w);
                            break;
                        }
                    }
                    if (!B) throw new XU(M);
                }
            }
            U[M] = { value: Z };
        }
        return jZ($, U, Y);
    },
    lZ = ($) => {
        if (!$ || !f$($)) return;
        let X = [];
        for (let [W, Q] of Object.entries($)) {
            if (!W || !Q) continue;
            let Y = Q.value;
            if (Y === void 0 || Y === null) continue;
            X.push(
                nZ.serialize(
                    W,
                    typeof Y === 'object' ? JSON.stringify(Y) : Y + '',
                    Q,
                ),
            );
        }
        if (X.length === 0) return;
        if (X.length === 1) return X[0];
        return X;
    },
    i$ = ($, X) => {
        if (!VX && $ instanceof Promise) return $.then((Q) => i$(Q, X));
        let W = $.size;
        if (
            (!X && W) ||
            (W &&
                X &&
                X.status !== 206 &&
                X.status !== 304 &&
                X.status !== 412 &&
                X.status !== 416)
        ) {
            if (X) {
                if (X.headers instanceof Headers) {
                    let Q = {
                        'accept-ranges': 'bytes',
                        'content-range': `bytes 0-${W - 1}/${W}`,
                        'transfer-encoding': 'chunked',
                    };
                    if (H8) Q = X.headers.toJSON();
                    else {
                        Q = {};
                        for (let [Y, J] of X.headers.entries())
                            if (Y in X.headers) Q[Y] = J;
                    }
                    return new Response($, { status: X.status, headers: Q });
                }
                if (f$(X.headers))
                    return new Response($, {
                        status: X.status,
                        headers: Object.assign(
                            {
                                'accept-ranges': 'bytes',
                                'content-range': `bytes 0-${W - 1}/${W}`,
                                'transfer-encoding': 'chunked',
                            },
                            X.headers,
                        ),
                    });
            }
            return new Response($, {
                headers: {
                    'accept-ranges': 'bytes',
                    'content-range': `bytes 0-${W - 1}/${W}`,
                    'transfer-encoding': 'chunked',
                },
            });
        }
        return new Response($);
    },
    oZ = ($, X) => {
        if (!$) return $;
        $.delete('set-cookie');
        for (let W = 0; W < X.length; W++) {
            let Q = X[W].indexOf('=');
            $.append(
                'set-cookie',
                `${X[W].slice(0, Q)}=${X[W].slice(Q + 1) || ''}`,
            );
        }
        return $;
    },
    w0 = ($, X) => {
        if (X?.headers) {
            if ($) {
                if (H8) Object.assign(X.headers, $.headers.toJSON());
                else
                    for (let [W, Q] of $.headers.entries())
                        if (W in X.headers) X.headers[W] = Q;
            }
            if (X.status === 200) X.status = $.status;
            if (X.headers['content-encoding'])
                delete X.headers['content-encoding'];
            return X;
        }
        if (!$) return { headers: {}, status: X?.status ?? 200 };
        if (H8) {
            if (
                ((X = {
                    headers: $.headers.toJSON(),
                    status: X?.status ?? 200,
                }),
                X.headers['content-encoding'])
            )
                delete X.headers['content-encoding'];
            return X;
        }
        X = { headers: {}, status: X?.status ?? 200 };
        for (let [W, Q] of $.headers.entries()) {
            if (W === 'content-encoding') continue;
            if (W in X.headers) X.headers[W] = Q;
        }
        return X;
    },
    DU =
        ({ mapResponse: $, mapCompactResponse: X }) =>
        async (W, Q, Y) => {
            let J = W.next();
            if (J instanceof Promise) J = await J;
            if (typeof J?.done === 'undefined' || J?.done) {
                if (Q) return $(J.value, Q, Y);
                return X(J.value, Y);
            }
            let U =
                J.value && typeof J.value?.stream
                    ? 'text/event-stream'
                    : J.value && typeof J.value === 'object'
                      ? 'application/json'
                      : 'text/plain';
            if (Q?.headers) {
                if (!Q.headers['transfer-encoding'])
                    Q.headers['transfer-encoding'] = 'chunked';
                if (!Q.headers['content-type']) Q.headers['content-type'] = U;
                if (!Q.headers['cache-control'])
                    Q.headers['cache-control'] = 'no-cache';
            } else
                Q = {
                    status: 200,
                    headers: {
                        'content-type': U,
                        'transfer-encoding': 'chunked',
                        'cache-control': 'no-cache',
                        connection: 'keep-alive',
                    },
                };
            return new Response(
                new ReadableStream({
                    async start(N) {
                        let M = !1;
                        if (
                            (Y?.signal?.addEventListener('abort', () => {
                                M = !0;
                                try {
                                    N.close();
                                } catch {}
                            }),
                            J.value !== void 0 && J.value !== null)
                        )
                            if (J.value.toStream) N.enqueue(J.value.toStream());
                            else if (typeof J.value === 'object')
                                try {
                                    N.enqueue(
                                        Buffer.from(JSON.stringify(J.value)),
                                    );
                                } catch {
                                    N.enqueue(Buffer.from(J.value.toString()));
                                }
                            else N.enqueue(Buffer.from(J.value.toString()));
                        for await (let G of W) {
                            if (M) break;
                            if (G === void 0 || G === null) continue;
                            if (G.toStream) N.enqueue(G.toStream());
                            else if (typeof G === 'object')
                                try {
                                    N.enqueue(Buffer.from(JSON.stringify(G)));
                                } catch {
                                    N.enqueue(Buffer.from(G.toString()));
                                }
                            else N.enqueue(Buffer.from(G.toString()));
                            await new Promise((Z) => setTimeout(() => Z(), 0));
                        }
                        try {
                            N.close();
                        } catch {}
                    },
                }),
                Q,
            );
        };
async function* D0($) {
    let X = $.body;
    if (!X) return;
    let W = X.getReader(),
        Q = new TextDecoder();
    try {
        while (!0) {
            let { done: Y, value: J } = await W.read();
            if (Y) break;
            yield Q.decode(J);
        }
    } finally {
        W.releaseLock();
    }
}
var E8 = ($) => {
        if (typeof $.status === 'string') $.status = C8[$.status];
        if ($.cookie && f$($.cookie)) {
            let X = lZ($.cookie);
            if (X) $.headers['set-cookie'] = X;
        }
        if ($.headers['set-cookie'] && Array.isArray($.headers['set-cookie']))
            $.headers = oZ(new Headers($.headers), $.headers['set-cookie']);
    },
    rZ = ($) => {
        let X = DU($);
        return (W, Q, Y) => {
            let J = !1;
            if (Q.headers instanceof Headers)
                for (let N of Q.headers.keys())
                    if (N === 'set-cookie') {
                        if (J) continue;
                        J = !0;
                        for (let M of Q.headers.getSetCookie())
                            W.headers.append('set-cookie', M);
                    } else W.headers.append(N, Q.headers?.get(N) ?? '');
            else for (let N in Q.headers) W.headers.append(N, Q.headers[N]);
            let U = Q.status ?? 200;
            if (
                W.status !== U &&
                U !== 200 &&
                (W.status <= 300 || W.status > 400)
            )
                return W.text().then((N) => {
                    let M = new Response(N, {
                        headers: W.headers,
                        status: Q.status,
                    });
                    if (
                        !M.headers.has('content-length') &&
                        M.headers.get('transfer-encoding') === 'chunked'
                    )
                        return X(D0(M), w0(M, Q), Y);
                    return M;
                });
            if (
                !W.headers.has('content-length') &&
                W.headers.get('transfer-encoding') === 'chunked'
            )
                return X(D0(W), w0(W, Q), Y);
            return W;
        };
    },
    a6 = ($, X, W) => {
        if (f$(X.headers) || X.status !== 200 || X.cookie)
            switch ((E8(X), $?.constructor?.name)) {
                case 'String':
                    return (
                        (X.headers['content-type'] = 'text/plain'),
                        new Response($, X)
                    );
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), a6($.response, X, W);
                case 'ReadableStream':
                    if (
                        !X.headers['content-type']?.startsWith(
                            'text/event-stream',
                        )
                    )
                        X.headers['content-type'] =
                            'text/event-stream; charset=utf-8';
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, X)
                    );
                case void 0:
                    if (!$) return new Response('', X);
                    return new Response(JSON.stringify($), X);
                case 'Response':
                    return L8($, X, W);
                case 'Error':
                    return M0($, X);
                case 'Promise':
                    return $.then((Q) => a6(Q, X, W));
                case 'Function':
                    return a6($(), X, W);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString(), X);
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                case 'FormData':
                    return new Response($, X);
                default:
                    if ($ instanceof Response) return L8($, X, W);
                    if ($ instanceof Promise) return $.then((Q) => a6(Q, X));
                    if ($ instanceof Error) return M0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), a6($.response, X, W);
                    if (typeof $?.next === 'function') return z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => a6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return a6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($, X);
            }
        if (
            $ instanceof Response &&
            !$.headers.has('content-length') &&
            $.headers.get('transfer-encoding') === 'chunked'
        )
            return z0(D0($), w0($, X), W);
        if (typeof $?.next === 'function' || $ instanceof ReadableStream)
            return z0($, X, W);
        return k1($, W);
    },
    r6 = ($, X, W) => {
        if ($ === void 0 || $ === null) return;
        if (f$(X.headers) || X.status !== 200 || X.cookie)
            switch ((E8(X), $?.constructor?.name)) {
                case 'String':
                    return (
                        (X.headers['content-type'] = 'text/plain'),
                        new Response($, X)
                    );
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), r6($.response, X, W);
                case 'ReadableStream':
                    if (
                        !X.headers['content-type']?.startsWith(
                            'text/event-stream',
                        )
                    )
                        X.headers['content-type'] =
                            'text/event-stream; charset=utf-8';
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, X)
                    );
                case void 0:
                    if (!$) return;
                    return new Response(JSON.stringify($), X);
                case 'Response':
                    return L8($, X, W);
                case 'Promise':
                    return $.then((Q) => r6(Q, X));
                case 'Error':
                    return M0($, X);
                case 'Function':
                    return r6($(), X);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString(), X);
                case 'FormData':
                    return new Response($);
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                default:
                    if ($ instanceof Response) return L8($, X, W);
                    if ($ instanceof Promise) return $.then((Q) => r6(Q, X));
                    if ($ instanceof Error) return M0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), r6($.response, X, W);
                    if (typeof $?.next === 'function') return z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => r6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return r6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($, X);
            }
        else
            switch ($?.constructor?.name) {
                case 'String':
                    return (
                        (X.headers['content-type'] = 'text/plain'),
                        new Response($)
                    );
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), r6($.response, X, W);
                case 'ReadableStream':
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, {
                            headers: {
                                'Content-Type':
                                    'text/event-stream; charset=utf-8',
                            },
                        })
                    );
                case void 0:
                    if (!$) return new Response('');
                    return new Response(JSON.stringify($), {
                        headers: { 'content-type': 'application/json' },
                    });
                case 'Response':
                    if (
                        !$.headers.has('content-length') &&
                        $.headers.get('transfer-encoding') === 'chunked'
                    )
                        return z0(D0($), w0($), W);
                    return $;
                case 'Promise':
                    return $.then((Q) => {
                        let Y = r6(Q, X);
                        if (Y !== void 0) return Y;
                    });
                case 'Error':
                    return M0($, X);
                case 'Function':
                    return k1($(), W);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString());
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                case 'FormData':
                    return new Response($);
                default:
                    if ($ instanceof Response) return $;
                    if ($ instanceof Promise) return $.then((Q) => r6(Q, X));
                    if ($ instanceof Error) return M0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), r6($.response, X, W);
                    if (typeof $?.next === 'function') return z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => r6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return r6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($);
            }
    },
    k1 = ($, X) => {
        switch ($?.constructor?.name) {
            case 'String':
                return new Response($, {
                    headers: { 'Content-Type': 'text/plain' },
                });
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify($), {
                    headers: { 'Content-Type': 'application/json' },
                });
            case 'ElysiaFile':
                return i$($.value);
            case 'File':
                return i$($);
            case 'Blob':
                return i$($);
            case 'ElysiaCustomStatusResponse':
                return a6($.response, { status: $.code, headers: {} });
            case 'ReadableStream':
                return (
                    X?.signal?.addEventListener(
                        'abort',
                        {
                            handleEvent() {
                                if (X?.signal && !X?.signal?.aborted)
                                    $.cancel();
                            },
                        },
                        { once: !0 },
                    ),
                    new Response($, {
                        headers: {
                            'Content-Type': 'text/event-stream; charset=utf-8',
                        },
                    })
                );
            case void 0:
                if (!$) return new Response('');
                return new Response(JSON.stringify($), {
                    headers: { 'content-type': 'application/json' },
                });
            case 'Response':
                if ($.headers.get('transfer-encoding') === 'chunked')
                    return z0(D0($), w0($), X);
                return $;
            case 'Error':
                return M0($);
            case 'Promise':
                return $.then((W) => k1(W, X));
            case 'Function':
                return k1($(), X);
            case 'Number':
            case 'Boolean':
                return new Response($.toString());
            case 'FormData':
                return new Response($);
            default:
                if ($ instanceof Response) return $;
                if ($ instanceof Promise) return $.then((W) => k1(W, X));
                if ($ instanceof Error) return M0($);
                if ($ instanceof g6)
                    return a6($.response, { status: $.code, headers: {} });
                if (typeof $?.next === 'function') return z0($, void 0, X);
                if (typeof $?.then === 'function')
                    return $.then((W) => a6(W, set));
                if (typeof $?.toResponse === 'function')
                    return k1($.toResponse());
                if ('charCodeAt' in $) {
                    let W = $.charCodeAt(0);
                    if (W === 123 || W === 91)
                        return new Response(JSON.stringify($), {
                            headers: { 'Content-Type': 'application/json' },
                        });
                }
                return new Response($);
        }
    },
    M0 = ($, X) =>
        new Response(
            JSON.stringify({
                name: $?.name,
                message: $?.message,
                cause: $?.cause,
            }),
            {
                status: X?.status !== 200 ? (X?.status ?? 500) : 500,
                headers: X?.headers,
            },
        ),
    LF = ($, X, W = {}) => {
        if (typeof $ === 'function') return;
        let Q = a6($, { headers: W });
        if (
            !X.parse?.length &&
            !X.transform?.length &&
            !X.beforeHandle?.length &&
            !X.afterHandle?.length
        )
            return Q.clone.bind(Q);
    },
    L8 = rZ({ mapResponse: a6, mapCompactResponse: k1 }),
    z0 = DU({ mapResponse: a6, mapCompactResponse: k1 }),
    QU = {
        name: 'web-standard',
        isWebStandard: !0,
        handler: {
            mapResponse: a6,
            mapEarlyResponse: r6,
            mapCompactResponse: k1,
            createStaticHandler: LF,
        },
        composeHandler: {
            mapResponseContext: 'c.request',
            preferWebstandardHeaders: !0,
            headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`,
            parser: {
                json($) {
                    if ($)
                        return `try{c.body=await c.request.json()}catch{}
`;
                    return `c.body=await c.request.json()
`;
                },
                text() {
                    return `c.body=await c.request.text()
`;
                },
                urlencoded() {
                    return `c.body=parseQuery(await c.request.text())
`;
                },
                arrayBuffer() {
                    return `c.body=await c.request.arrayBuffer()
`;
                },
                formData($) {
                    let X = `
c.body={}
`;
                    if ($)
                        X +=
                            'let form;try{form=await c.request.formData()}catch{}';
                    else
                        X += `const form=await c.request.formData()
`;
                    return (
                        X +
                        `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`
                    );
                },
            },
        },
        composeGeneralHandler: {
            parameters: 'r',
            createContext($) {
                let X = '',
                    W = '',
                    Q = $.setHeaders;
                for (let U of Object.keys($.decorator))
                    X += `,'${U}':decorator['${U}']`;
                let Y = $.config.handler?.standardHostname ?? !0,
                    J = !!$.event.trace?.length;
                if (
                    ((W += `const u=r.url,s=u.indexOf('/',${Y ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`),
                    J)
                )
                    W += `const id=randomId()
`;
                if (
                    ((W +=
                        'const c={request:r,store,qi,path:p,url:u,redirect,error:status,status,set:{headers:'),
                    (W += Object.keys(Q ?? {}).length
                        ? 'Object.assign({},app.setHeaders)'
                        : 'Object.create(null)'),
                    (W += ',status:200}'),
                    $.inference.server)
                )
                    W += ',get server(){return app.getServer()}';
                if (J) W += ',[ELYSIA_REQUEST_ID]:id';
                return (
                    (W += X),
                    (W += `}
`),
                    W
                );
            },
            error404($, X) {
                let W = 'if(route===null)return ';
                if (X)
                    W += `app.handleError(c,notFound,false,${this.parameters})`;
                else
                    W += $
                        ? 'new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})'
                        : 'error404.clone()';
                return {
                    declare: X
                        ? ''
                        : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
                    code: W,
                };
            },
        },
        composeError: {
            mapResponseContext: '',
            validationError:
                "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})",
            unknownError:
                'return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})',
        },
        listen() {
            return () => {
                throw new Error(
                    'WebStandard does not support listen, you might want to export default Elysia.fetch instead',
                );
            };
        },
    },
    KF = I8(NU(), 1),
    K8 = I8(NU(), 1);
function _F($, X = 0) {
    let W = Object.create(null),
        Q = 1,
        Y = 2,
        J = 4,
        U = 8,
        N = 0,
        M = X - 1,
        G = M,
        Z = $.length;
    for (let O = X; O < Z; O++)
        switch ($.charCodeAt(O)) {
            case 38:
                B(O), (M = O), (G = O), (N = 0);
                break;
            case 61:
                if (G <= M) G = O;
                else N |= 8;
                break;
            case 43:
                if (G > M) N |= 4;
                else N |= 1;
                break;
            case 37:
                if (G > M) N |= 8;
                else N |= 2;
                break;
        }
    return B(Z), W;
    function B(O) {
        let w = G > M,
            z = w ? G : O;
        if (z <= M + 1) return;
        let H = $.slice(M + 1, z);
        if (N & 1) H = H.replace(/\+/g, ' ');
        if (N & 2) H = K8.default(H) || H;
        if (W[H] !== void 0) return;
        let P = '';
        if (w) {
            if (((P = $.slice(G + 1, O)), N & 4)) P = P.replace(/\+/g, ' ');
            if (N & 8) P = K8.default(P) || P;
        }
        W[H] = P;
    }
}
function D8($) {
    let X = Object.create(null),
        W = 0,
        Q = 1,
        Y = 2,
        J = 4,
        U = 8,
        N = $.length,
        M = -1,
        G = -1;
    for (let B = 0; B < N; B++)
        switch ($.charCodeAt(B)) {
            case 38:
                Z($, B), (M = B), (G = B), (W = 0);
                break;
            case 61:
                if (G <= M) G = B;
                else W |= U;
                break;
            case 43:
                if (G > M) W |= J;
                else W |= Q;
                break;
            case 37:
                if (G > M) W |= U;
                else W |= Y;
                break;
        }
    if (M < N) Z($, N);
    return X;
    function Z(B, O) {
        let w = G > M,
            z = w ? G : O,
            H = B.slice(M + 1, z);
        if (!w && H.length === 0) return;
        let P = H;
        if (W & Q) P = P.replace(/\+/g, ' ');
        if (W & Y) P = K8.default(P) || P;
        let E = '';
        if (w) {
            let V = B.slice(G + 1, O);
            if (W & J) V = V.replace(/\+/g, ' ');
            if (W & U) V = K8.default(V) || V;
            E = V;
        }
        let j = X[P];
        if (j === void 0) X[P] = E;
        else if (Array.isArray(j)) j.push(E);
        else X[P] = [j, E];
    }
}
var x8 = Symbol('ElysiaTrace'),
    b1 = () => {
        let { promise: $, resolve: X } = Promise.withResolvers(),
            { promise: W, resolve: Q } = Promise.withResolvers(),
            { promise: Y, resolve: J } = Promise.withResolvers(),
            U = [],
            N = [];
        return [
            (M) => {
                if (M) U.push(M);
                return $;
            },
            (M) => {
                let G = [],
                    Z = [],
                    B = null;
                for (let w = 0; w < (M.total ?? 0); w++) {
                    let { promise: z, resolve: H } = Promise.withResolvers(),
                        { promise: P, resolve: E } = Promise.withResolvers(),
                        { promise: j, resolve: V } = Promise.withResolvers(),
                        i = [],
                        $$ = [];
                    G.push((y) => {
                        if (y) i.push(y);
                        return z;
                    }),
                        Z.push((y) => {
                            let n = {
                                ...y,
                                end: P,
                                error: j,
                                index: w,
                                onStop(k) {
                                    if (k) $$.push(k);
                                    return P;
                                },
                            };
                            H(n);
                            for (let k = 0; k < i.length; k++) i[k](n);
                            return (k = null) => {
                                let b = performance.now();
                                if (k) B = k;
                                let T = {
                                    end: b,
                                    error: k,
                                    get elapsed() {
                                        return b - y.begin;
                                    },
                                };
                                for (let o = 0; o < $$.length; o++) $$[o](T);
                                E(b), V(k);
                            };
                        });
                }
                let O = {
                    ...M,
                    end: W,
                    error: Y,
                    onEvent(w) {
                        for (let z = 0; z < G.length; z++) G[z](w);
                    },
                    onStop(w) {
                        if (w) N.push(w);
                        return W;
                    },
                };
                X(O);
                for (let w = 0; w < U.length; w++) U[w](O);
                return {
                    resolveChild: Z,
                    resolve(w = null) {
                        let z = performance.now();
                        if (!w && B) w = B;
                        let H = {
                            end: z,
                            error: w,
                            get elapsed() {
                                return z - M.begin;
                            },
                        };
                        for (let P = 0; P < N.length; P++) N[P](H);
                        Q(z), J(w);
                    },
                };
            },
        ];
    },
    FF = ($) => {
        return (X) => {
            let [W, Q] = b1(),
                [Y, J] = b1(),
                [U, N] = b1(),
                [M, G] = b1(),
                [Z, B] = b1(),
                [O, w] = b1(),
                [z, H] = b1(),
                [P, E] = b1(),
                [j, V] = b1();
            return (
                $({
                    id: X[RW],
                    context: X,
                    set: X.set,
                    onRequest: W,
                    onParse: Y,
                    onTransform: U,
                    onBeforeHandle: M,
                    onHandle: Z,
                    onAfterHandle: O,
                    onMapResponse: P,
                    onAfterResponse: j,
                    onError: z,
                    time: Date.now(),
                    store: X.store,
                }),
                {
                    request: Q,
                    parse: J,
                    transform: N,
                    beforeHandle: G,
                    handle: B,
                    afterHandle: w,
                    error: H,
                    mapResponse: E,
                    afterResponse: V,
                }
            );
        };
    },
    s6 = Symbol.for('TypeBox.Kind'),
    IF = Symbol.for('TypeBox.Hint'),
    tZ = ($) => /(\ |-|\t|\n)/.test($),
    aZ = ($, X, W = !1) => {
        if (typeof X === 'number') return `${$}[${X}]`;
        if (tZ(X)) return `${$}${W ? '?.' : ''}["${X}"]`;
        return `${$}${W ? '?' : ''}.${X}`;
    },
    CF = ($) => (tZ($) ? `"${$}"` : $),
    LZ = ($, X = 0, W) => {
        if (W.type !== 'string' || W.const || W.trusted) return $;
        let Q = '';
        for (let Y = X - 1; Y >= 0; Y--) Q += `d.h${Y}(`;
        return Q + $ + ')'.repeat(X);
    },
    sZ = ($) => {
        if (
            !$.allOf ||
            (s6 in $ && ($[s6] !== 'Intersect' || $.type !== 'object'))
        )
            return $;
        let { allOf: X, ...W } = $;
        if (((W.properties = {}), s6 in W)) W[s6] = 'Object';
        for (let Q of X) {
            if (Q.type !== 'object') continue;
            let { properties: Y, required: J, type: U, [s6]: N, ...M } = Q;
            if (J) W.required = W.required ? W.required.concat(J) : J;
            Object.assign(W, M);
            for (let G in Q.properties) W.properties[G] = sZ(Q.properties[G]);
        }
        return W;
    },
    RF = ($, X, W) => {
        let Q =
            $.patternProperties['^(.*)$'] ??
            $.patternProperties[Object.keys($.patternProperties)[0]];
        if (!Q) return X;
        let Y = W.array;
        return (
            W.array++,
            `(()=>{const ar${Y}s=Object.keys(${X}),ar${Y}v={};for(let i=0;i<ar${Y}s.length;i++){const ar${Y}p=${X}[ar${Y}s[i]];ar${Y}v[ar${Y}s[i]]=${g1(Q, `ar${Y}p`, W)}}return ar${Y}v})()`
        );
    },
    VF = ($, X, W) => {
        let Q = W.array;
        W.array++;
        let Y = X === 'v' && !W.unions.length,
            J = '';
        if (!Y) J = '(()=>{';
        J += `const ar${Q}v=[`;
        for (let U = 0; U < $.length; U++) {
            if (U !== 0) J += ',';
            J += g1($[U], aZ(X, U, W.parentIsOptional), W);
        }
        if (((J += '];'), !Y)) J += `return ar${Q}v})()`;
        return J;
    };
function _8($, X = new WeakMap()) {
    if ($ === null || typeof $ !== 'object' || typeof $ === 'function')
        return $;
    if (X.has($)) return X.get($);
    if (Array.isArray($)) {
        let W = new Array($.length);
        X.set($, W);
        for (let Q = 0; Q < $.length; Q++) W[Q] = _8($[Q], X);
        return W;
    }
    if (typeof $ === 'object') {
        let W = Object.keys($).concat(Object.getOwnPropertySymbols($)),
            Q = {};
        for (let Y of W) Q[Y] = _8($[Y], X);
        return Q;
    }
    return $;
}
var EF = ($, X, W) => {
        if (W.TypeCompiler === void 0) {
            if (!W.typeCompilerWanred)
                console.warn(
                    new Error(
                        "[exact-mirror] TypeBox's TypeCompiler is required to use Union",
                    ),
                ),
                    (W.typeCompilerWanred = !0);
            return X;
        }
        W.unionKeys[X] = 1;
        let Q = W.unions.length,
            Y = (W.unions[Q] = []),
            J = `(()=>{
`,
            U = (N) => {
                if (!(s6 in N) || !N.$ref) return N;
                if (N[s6] === 'This') return _8(W.definitions[N.$ref]);
                else if (N[s6] === 'Ref')
                    if (!W.modules)
                        console.warn(
                            new Error(
                                '[exact-mirror] modules is required when using nested cyclic reference',
                            ),
                        );
                    else return W.modules.Import(N.$ref);
                return N;
            };
        for (let N = 0; N < $.length; N++) {
            let M = U($[N]);
            if (Array.isArray(M.anyOf))
                for (let G = 0; G < M.anyOf.length; G++)
                    M.anyOf[G] = U(M.anyOf[G]);
            else if (M.items)
                if (Array.isArray(M.items))
                    for (let G = 0; G < M.items.length; G++)
                        M.items[G] = U(M.items[G]);
                else M.items = U(M.items);
            Y.push(Q1.Compile(M)),
                (J += `if(d.unions[${Q}][${N}].Check(${X})){return ${g1(M, X, { ...W, recursion: W.recursion + 1, parentIsOptional: !0 })}}
`);
        }
        return (
            (J += `return ${W.removeUnknownUnionType ? 'undefined' : X}})()`), J
        );
    },
    g1 = ($, X, W) => {
        if (!$) return '';
        let Q = X === 'v' && !W.unions.length;
        if (s6 in $ && $[s6] === 'Import' && $.$ref in $.$defs)
            return g1($.$defs[$.$ref], X, {
                ...W,
                definitions: Object.assign(W.definitions, $.$defs),
            });
        if (Q && $.type !== 'object' && $.type !== 'array' && !$.anyOf)
            return `return ${LZ('v', W.sanitize?.length, $)}`;
        if (W.recursion >= W.recursionLimit) return X;
        let Y = '';
        if ($.$id && IF in $) W.definitions[$.$id] = $;
        switch ($.type) {
            case 'object':
                if ($[s6] === 'Record') {
                    Y = RF($, X, W);
                    break;
                }
                if ((($ = sZ($)), (Y += '{'), $.additionalProperties))
                    Y += `...${X}`;
                let J = Object.keys($.properties);
                for (let G = 0; G < J.length; G++) {
                    let Z = J[G],
                        B =
                            ($.required && !$.required.includes(Z)) ||
                            Array.isArray($.properties[Z].anyOf),
                        O = aZ(X, Z, W.parentIsOptional);
                    if (B) {
                        let z = W.array;
                        if (X.startsWith('ar')) {
                            let H = O.slice(O.indexOf('.') + 1),
                                P = W.optionalsInArray;
                            if (P[z]) P[z].push(H);
                            else P[z] = [H];
                        } else W.optionals.push(O);
                    }
                    let w = $.properties[Z];
                    if ($.additionalProperties && w.type !== 'object') continue;
                    if (G !== 0) Y += ',';
                    Y += `${CF(Z)}:${B ? `${O}===undefined?undefined:` : ''}${g1(w, O, { ...W, recursion: W.recursion + 1, parentIsOptional: B })}`;
                }
                Y += '}';
                break;
            case 'array':
                if ($.items.type !== 'object' && $.items.type !== 'array')
                    if (Array.isArray($.items)) {
                        Y = VF($.items, X, W);
                        break;
                    } else if (Q) return 'return v';
                    else if (
                        s6 in $.items &&
                        $.items.$ref &&
                        ($.items[s6] === 'Ref' || $.items[s6] === 'This')
                    )
                        Y = g1(_8(W.definitions[$.items.$ref]), X, {
                            ...W,
                            parentIsOptional: !0,
                            recursion: W.recursion + 1,
                        });
                    else {
                        Y = X;
                        break;
                    }
                let U = W.array;
                W.array++;
                let N = X;
                if (Q) Y = `const ar${U}v=new Array(${X}.length);`;
                else
                    (N = `ar${U}s`),
                        (Y = `((${N})=>{const ar${U}v=new Array(${N}.length);`);
                Y += `for(let i=0;i<${N}.length;i++){const ar${U}p=${N}[i];ar${U}v[i]=${g1($.items, `ar${U}p`, W)}`;
                let M = W.optionalsInArray[U + 1];
                if (M)
                    for (let G = 0; G < M.length; G++) {
                        let Z = `ar${U}v[i].${M[G]}`;
                        Y += `;if(${Z}===undefined)delete ${Z}`;
                    }
                if (((Y += '}'), !Q)) Y += `return ar${U}v})(${X})`;
                break;
            default:
                if ($.$ref && $.$ref in W.definitions)
                    return g1(W.definitions[$.$ref], X, W);
                if (Array.isArray($.anyOf)) {
                    Y = EF($.anyOf, X, W);
                    break;
                }
                Y = LZ(X, W.sanitize?.length, $);
                break;
        }
        if (!Q) return Y;
        if ($.type === 'array') return `${Y}return ar0v`;
        Y = `const x=${Y}
`;
        for (let J = 0; J < W.optionals.length; J++) {
            let U = W.optionals[J],
                N = U.slice(1);
            if (((Y += `if(${U}===undefined`), W.unionKeys[U]))
                Y += `||x${N}===undefined`;
            Y += `)delete x${N.charCodeAt(0) !== 63 ? '?' : ''}${N}
`;
        }
        return `${Y}return x`;
    },
    KZ = (
        $,
        {
            TypeCompiler: X,
            modules: W,
            definitions: Q,
            sanitize: Y,
            recursionLimit: J = 8,
            removeUnknownUnionType: U = !1,
        } = {},
    ) => {
        let N = [];
        if (typeof Y === 'function') Y = [Y];
        let M = g1($, 'v', {
            optionals: [],
            optionalsInArray: [],
            array: 0,
            parentIsOptional: !1,
            unions: N,
            unionKeys: {},
            TypeCompiler: X,
            modules: W,
            definitions: Q ?? W?.$defs ?? {},
            sanitize: Y,
            recursion: 0,
            recursionLimit: J,
            removeUnknownUnionType: U,
        });
        if (!N.length && !Y?.length) return Function('v', M);
        let G;
        if (Y?.length) {
            G = {};
            for (let Z = 0; Z < Y.length; Z++) G[`h${Z}`] = Y[Z];
        }
        return Function(
            'd',
            `return function mirror(v){${M}}`,
        )({ unions: N, ...G });
    },
    JU = ($) => {
        if (!$) return !1;
        if ($?.[S] === 'Import' && $.References) return $.References().some(JU);
        if ($.schema) $ = $.schema;
        return !!$ && Y6 in $;
    },
    M1 = ($) => {
        if (!$) return !1;
        let X = $?.schema ?? $;
        if (X[S] === 'Import' && $.References) return $.References().some(M1);
        if (X.anyOf) return X.anyOf.some(M1);
        if (X.someOf) return X.someOf.some(M1);
        if (X.allOf) return X.allOf.some(M1);
        if (X.not) return X.not.some(M1);
        if (X.type === 'object') {
            let W = X.properties;
            if ('additionalProperties' in X) return X.additionalProperties;
            if ('patternProperties' in X) return !1;
            for (let Q of Object.keys(W)) {
                let Y = W[Q];
                if (Y.type === 'object') {
                    if (M1(Y)) return !0;
                } else if (Y.anyOf) {
                    for (let J = 0; J < Y.anyOf.length; J++)
                        if (M1(Y.anyOf[J])) return !0;
                }
                return Y.additionalProperties;
            }
            return !1;
        }
        if (X.type === 'array' && X.items && !Array.isArray(X.items))
            return M1(X.items);
        return !1;
    },
    N0 = ($, X) => {
        if (!X) return !1;
        if (S in X && X[S] === $) return !0;
        if (X.type === 'object') {
            let W = X.properties;
            if (!W) return !1;
            for (let Q of Object.keys(W)) {
                let Y = W[Q];
                if (Y.type === 'object') {
                    if (N0($, Y)) return !0;
                } else if (Y.anyOf) {
                    for (let J = 0; J < Y.anyOf.length; J++)
                        if (N0($, Y.anyOf[J])) return !0;
                }
                if (S in Y && Y[S] === $) return !0;
            }
            return !1;
        }
        return !!X.properties && S in X.properties && X.properties[S] === $;
    },
    _W = ($, X) => {
        if (!X) return;
        let W = X.schema ?? X;
        if (W[S] === 'Import' && X.References)
            return X.References().some((Q) => _W($, Q));
        if (W.type === 'object') {
            let Q = W.properties;
            if (!Q) return !1;
            for (let Y of Object.keys(Q)) {
                let J = Q[Y];
                if ($ in J) return !0;
                if (J.type === 'object') {
                    if (_W($, J)) return !0;
                } else if (J.anyOf) {
                    for (let U = 0; U < J.anyOf.length; U++)
                        if (_W($, J.anyOf[U])) return !0;
                }
            }
            return !1;
        }
        return $ in W;
    },
    G1 = ($) => {
        if (!$) return !1;
        if ($.oneOf) {
            for (let X = 0; X < $.oneOf.length; X++)
                if (G1($.oneOf[X])) return !0;
        }
        if ($.anyOf) {
            for (let X = 0; X < $.anyOf.length; X++)
                if (G1($.anyOf[X])) return !0;
        }
        if ($.oneOf) {
            for (let X = 0; X < $.oneOf.length; X++)
                if (G1($.oneOf[X])) return !0;
        }
        if ($.allOf) {
            for (let X = 0; X < $.allOf.length; X++)
                if (G1($.allOf[X])) return !0;
        }
        if ($.not && G1($.not)) return !0;
        if ($.type === 'object' && $.properties) {
            let X = $.properties;
            for (let W of Object.keys(X)) {
                let Q = X[W];
                if (G1(Q)) return !0;
                if (Q.type === 'array' && Q.items && G1(Q.items)) return !0;
            }
        }
        if ($.type === 'array' && $.items && G1($.items)) return !0;
        return $[S] === 'Ref' && '$ref' in $;
    },
    a4 = ($) => {
        if (!$) return !1;
        if ($.$ref && $.$defs && $.$ref in $.$defs && a4($.$defs[$.$ref]))
            return !0;
        if ($.oneOf) {
            for (let X = 0; X < $.oneOf.length; X++)
                if (a4($.oneOf[X])) return !0;
        }
        if ($.anyOf) {
            for (let X = 0; X < $.anyOf.length; X++)
                if (a4($.anyOf[X])) return !0;
        }
        if ($.allOf) {
            for (let X = 0; X < $.allOf.length; X++)
                if (a4($.allOf[X])) return !0;
        }
        if ($.not && a4($.not)) return !0;
        if ($.type === 'object' && $.properties) {
            let X = $.properties;
            for (let W of Object.keys(X)) {
                let Q = X[W];
                if (a4(Q)) return !0;
                if (Q.type === 'array' && Q.items && a4(Q.items)) return !0;
            }
        }
        if ($.type === 'array' && $.items && a4($.items)) return !0;
        return R$ in $;
    },
    _Z = ($, X, W = {}) => {
        let Q = W;
        if (((Q.root = !0), !Array.isArray(X)))
            return (X.original = $), F6($, X, Q);
        for (let Y of X) (Y.original = $), ($ = F6($, Y, Q));
        return $;
    },
    F6 = ($, X, W) => {
        if (!$) return $;
        let Q = W.root;
        if (X.untilObjectFound && !Q && $.type === 'object') return $;
        let Y = X.from[S];
        if ($.oneOf) {
            for (let N = 0; N < $.oneOf.length; N++)
                $.oneOf[N] = F6($.oneOf[N], X, W);
            return $;
        }
        if ($.anyOf) {
            for (let N = 0; N < $.anyOf.length; N++)
                $.anyOf[N] = F6($.anyOf[N], X, W);
            return $;
        }
        if ($.allOf) {
            for (let N = 0; N < $.allOf.length; N++)
                $.allOf[N] = F6($.allOf[N], X, W);
            return $;
        }
        if ($.not) return F6($.not, X, W);
        let J = Q && !!X.excludeRoot;
        if ($[S] === Y) {
            let {
                    anyOf: N,
                    oneOf: M,
                    allOf: G,
                    not: Z,
                    properties: B,
                    items: O,
                    ...w
                } = $,
                z = X.to(w);
            if (!z) return $;
            let H,
                P = (j) => {
                    let V = E(j);
                    if (V.$id) delete V.$id;
                    return V;
                },
                E = (j) => {
                    if (B && j.type === 'object') {
                        let i = {};
                        for (let [$$, y] of Object.entries(B))
                            i[$$] = F6(y, X, { ...W, root: !1 });
                        return { ...w, ...j, properties: i };
                    }
                    if (O && j.type === 'array')
                        return {
                            ...w,
                            ...j,
                            items: F6(O, X, { ...W, root: !1 }),
                        };
                    let V = { ...w, ...j };
                    if (
                        (delete V.required,
                        B &&
                            j.type === 'string' &&
                            j.format === 'ObjectString' &&
                            j.default === '{}')
                    )
                        (H = c.ObjectString(B, w)),
                            (V.default = JSON.stringify(
                                L$.Create(c.Object(B)),
                            )),
                            (V.properties = B);
                    if (
                        O &&
                        j.type === 'string' &&
                        j.format === 'ArrayString' &&
                        j.default === '[]'
                    )
                        (H = c.ArrayString(O, w)),
                            (V.default = JSON.stringify(L$.Create(c.Array(O)))),
                            (V.items = O);
                    return V;
                };
            if (J) {
                if (B) {
                    let j = {};
                    for (let [V, i] of Object.entries(B))
                        j[V] = F6(i, X, { ...W, root: !1 });
                    return { ...w, properties: j };
                } else if (O?.map)
                    return {
                        ...w,
                        items: O.map((j) => F6(j, X, { ...W, root: !1 })),
                    };
                return w;
            }
            if (z.anyOf)
                for (let j = 0; j < z.anyOf.length; j++)
                    z.anyOf[j] = P(z.anyOf[j]);
            else if (z.oneOf)
                for (let j = 0; j < z.oneOf.length; j++)
                    z.oneOf[j] = P(z.oneOf[j]);
            else if (z.allOf)
                for (let j = 0; j < z.allOf.length; j++)
                    z.allOf[j] = P(z.allOf[j]);
            else if (z.not) z.not = P(z.not);
            if (H) z[R$] = H[R$];
            if (z.anyOf || z.oneOf || z.allOf || z.not) return z;
            if (B) {
                let j = {};
                for (let [V, i] of Object.entries(B))
                    j[V] = F6(i, X, { ...W, root: !1 });
                return { ...w, ...z, properties: j };
            } else if (O?.map)
                return {
                    ...w,
                    ...z,
                    items: O.map((j) => F6(j, X, { ...W, root: !1 })),
                };
            return { ...w, ...z };
        }
        let U = $?.properties;
        if (U && Q && X.rootOnly !== !0)
            for (let [N, M] of Object.entries(U))
                switch (M[S]) {
                    case Y:
                        let {
                                anyOf: G,
                                oneOf: Z,
                                allOf: B,
                                not: O,
                                type: w,
                                ...z
                            } = M,
                            H = X.to(z);
                        if (!H) return $;
                        if (H.anyOf)
                            for (let P = 0; P < H.anyOf.length; P++)
                                H.anyOf[P] = { ...z, ...H.anyOf[P] };
                        else if (H.oneOf)
                            for (let P = 0; P < H.oneOf.length; P++)
                                H.oneOf[P] = { ...z, ...H.oneOf[P] };
                        else if (H.allOf)
                            for (let P = 0; P < H.allOf.length; P++)
                                H.allOf[P] = { ...z, ...H.allOf[P] };
                        else if (H.not) H.not = { ...z, ...H.not };
                        U[N] = { ...z, ...F6(z, X, { ...W, root: !1 }) };
                        break;
                    case 'Object':
                    case 'Union':
                        U[N] = F6(M, X, { ...W, root: !1 });
                        break;
                    default:
                        if (Array.isArray(M.items))
                            for (let P = 0; P < M.items.length; P++)
                                M.items[P] = F6(M.items[P], X, {
                                    ...W,
                                    root: !1,
                                });
                        else if (M.anyOf || M.oneOf || M.allOf || M.not)
                            U[N] = F6(M, X, { ...W, root: !1 });
                        else if (M.type === 'array')
                            M.items = F6(M.items, X, { ...W, root: !1 });
                        break;
                }
        return $;
    },
    AW = ($) => (X) => {
        if (typeof X === 'object')
            try {
                return L$.Clean($, X);
            } catch {
                try {
                    return L$.Clean($, X);
                } catch {
                    return X;
                }
            }
        return X;
    },
    P6 = (
        $,
        {
            models: X = {},
            dynamic: W = !1,
            modules: Q,
            normalize: Y = !1,
            additionalProperties: J = !1,
            coerce: U = !1,
            additionalCoerce: N = [],
            validators: M,
            sanitize: G,
        } = {},
    ) => {
        if (((M = M?.filter((H) => H)), !$)) {
            if (!M?.length) return;
            ($ = M[0]), (M = M.slice(1));
        }
        let Z = void 0,
            B = (H) => {
                if (U)
                    return _Z(H, [
                        {
                            from: c.Number(),
                            to: (P) => c.Numeric(P),
                            untilObjectFound: !0,
                        },
                        {
                            from: c.Boolean(),
                            to: (P) => c.BooleanString(P),
                            untilObjectFound: !0,
                        },
                        ...(Array.isArray(N) ? N : [N]),
                    ]);
                return _Z(H, N);
            },
            O = (H) => {
                let P;
                if (!H) return;
                if (typeof H !== 'string') P = H;
                else {
                    let j = H.endsWith('[]'),
                        V = j ? H.substring(0, H.length - 2) : H;
                    if (((P = Q?.Import(V) ?? X[V]), j)) P = c.Array(P);
                }
                if (!P) return;
                let E;
                if (P[S] !== 'Import' && (E = G1(P))) {
                    let j = R8();
                    if (Z === void 0) Z = E;
                    P = c.Module({ ...Q?.$defs, [j]: P }).Import(j);
                }
                if (P[S] === 'Import') {
                    let j = {};
                    for (let [i, $$] of Object.entries(P.$defs)) j[i] = B($$);
                    let V = P.$ref;
                    P = c.Module(j).Import(V);
                } else if (U || N) P = B(P);
                return P;
            },
            w = O($);
        if (M?.length) {
            let H = !1,
                { schema: P, notObjects: E } = bF([w, ...M.map(O)]);
            if (E) {
                if (
                    ((w = c.Intersect([
                        ...(P ? [P] : []),
                        ...E.map((j) => {
                            let V = O(j);
                            if (
                                V.type === 'object' &&
                                'additionalProperties' in V
                            ) {
                                if (!H && V.additionalProperties === !1) H = !0;
                                delete V.additionalProperties;
                            }
                            return V;
                        }),
                    ])),
                    w.type === 'object' && H)
                )
                    w.additionalProperties = !1;
            }
        } else if (w.type === 'object' && 'additionalProperties' in w === !1)
            w.additionalProperties = J;
        if (W) {
            let H = {
                schema: w,
                references: '',
                checkFunc: () => {},
                code: '',
                Check: (P) => L$.Check(w, P),
                Errors: (P) => L$.Errors(w, P),
                Code: () => '',
                Clean: AW(w),
                Decode: (P) => L$.Decode(w, P),
                Encode: (P) => L$.Encode(w, P),
                get hasAdditionalProperties() {
                    if ('~hasAdditionalProperties' in this)
                        return this['~hasAdditionalProperties'];
                    return (this['~hasAdditionalProperties'] = M1(w));
                },
                get hasDefault() {
                    if ('~hasDefault' in this) return this['~hasDefault'];
                    return (this['~hasDefault'] = _W('default', w));
                },
                get isOptional() {
                    if ('~isOptional' in this) return this['~isOptional'];
                    return (this['~isOptional'] = JU(w));
                },
                get hasTransform() {
                    if ('~hasTransform' in this) return this['~hasTransform'];
                    return (this['~hasTransform'] = a4(w));
                },
                '~hasRef': Z,
                get hasRef() {
                    if ('~hasRef' in this) return this['~hasRef'];
                    return (this['~hasRef'] = a4(w));
                },
            };
            if (w.config) {
                if (((H.config = w.config), H?.schema?.config))
                    delete H.schema.config;
            }
            if (Y && w.additionalProperties === !1)
                if (Y === !0 || Y === 'exactMirror')
                    try {
                        H.Clean = KZ(w, {
                            TypeCompiler: Q1,
                            sanitize: G?.(),
                            modules: Q,
                        });
                    } catch {
                        console.warn(
                            'Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues',
                        ),
                            console.warn(w),
                            (H.Clean = AW(w));
                    }
                else H.Clean = AW(w);
            return (
                (H.parse = (P) => {
                    try {
                        return H.Decode(P);
                    } catch (E) {
                        throw [...H.Errors(P)].map(s4);
                    }
                }),
                (H.safeParse = (P) => {
                    try {
                        return { success: !0, data: H.Decode(P), error: null };
                    } catch (E) {
                        let j = [...z.Errors(P)].map(s4);
                        return {
                            success: !1,
                            data: null,
                            error: j[0]?.summary,
                            errors: j,
                        };
                    }
                }),
                H
            );
        }
        let z = Q1.Compile(w, Object.values(X));
        if (w.config) {
            if (((z.config = w.config), z?.schema?.config))
                delete z.schema.config;
        }
        if (Y === !0 || Y === 'exactMirror')
            try {
                z.Clean = KZ(w, {
                    TypeCompiler: Q1,
                    sanitize: G?.(),
                    modules: Q,
                });
            } catch (H) {
                console.warn(
                    'Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues',
                ),
                    console.warn(w),
                    (z.Clean = AW(w));
            }
        else z.Clean = AW(w);
        return (
            (z.parse = (H) => {
                try {
                    return z.Decode(H);
                } catch (P) {
                    throw [...z.Errors(H)].map(s4);
                }
            }),
            (z.safeParse = (H) => {
                try {
                    return { success: !0, data: z.Decode(H), error: null };
                } catch (P) {
                    let E = [...z.Errors(H)].map(s4);
                    return {
                        success: !1,
                        data: null,
                        error: E[0]?.summary,
                        errors: E,
                    };
                }
            }),
            Object.assign(z, {
                get hasAdditionalProperties() {
                    if ('~hasAdditionalProperties' in this)
                        return this['~hasAdditionalProperties'];
                    return (this['~hasAdditionalProperties'] = M1(z));
                },
                get hasDefault() {
                    if ('~hasDefault' in this) return this['~hasDefault'];
                    return (this['~hasDefault'] = _W('default', z));
                },
                get isOptional() {
                    if ('~isOptional' in this) return this['~isOptional'];
                    return (this['~isOptional'] = JU(z));
                },
                get hasTransform() {
                    if ('~hasTransform' in this) return this['~hasTransform'];
                    return (this['~hasTransform'] = a4(w));
                },
                get hasRef() {
                    if ('~hasRef' in this) return this['~hasRef'];
                    return (this['~hasRef'] = G1(w));
                },
                '~hasRef': Z,
            }),
            z
        );
    },
    xF = ($) => $[S] === 'Union' || (!$.schema && !!$.anyOf),
    bF = ($) => {
        if ($.length === 0) return { schema: void 0, notObjects: [] };
        if ($.length === 1)
            return $[0].type === 'object'
                ? { schema: $[0], notObjects: [] }
                : { schema: void 0, notObjects: $ };
        let X,
            W = [],
            Q = !1,
            Y = !1;
        for (let J of $) {
            if (J.type !== 'object') {
                W.push(J);
                continue;
            }
            if ('additionalProperties' in J) {
                if (J.additionalProperties === !0) Q = !0;
                else if (J.additionalProperties === !1) Y = !0;
            }
            if (!X) {
                X = J;
                continue;
            }
            X = {
                ...X,
                ...J,
                properties: { ...X.properties, ...J.properties },
                required: [...(X?.required ?? []), ...J.required],
            };
        }
        if (X) {
            if (X.required) X.required = [...new Set(X.required)];
            if (Y) X.additionalProperties = !1;
            else if (Q) X.additionalProperties = !0;
        }
        return { schema: X, notObjects: W };
    },
    FZ = (
        $,
        {
            models: X = {},
            modules: W,
            dynamic: Q = !1,
            normalize: Y = !1,
            additionalProperties: J = !1,
            validators: U = [],
            sanitize: N,
        },
    ) => {
        if (((U = U.filter((Z) => Z)), !$)) {
            if (!U?.length) return;
            ($ = U[0]), (U = U.slice(1));
        }
        let M;
        if (typeof $ !== 'string') M = $;
        else {
            let Z = $.endsWith('[]'),
                B = Z ? $.substring(0, $.length - 2) : $;
            if (((M = W.Import(B) ?? X[B]), Z)) M = c.Array(M);
        }
        if (!M) return;
        if (S in M)
            return {
                200: P6(M, {
                    modules: W,
                    models: X,
                    additionalProperties: J,
                    dynamic: Q,
                    normalize: Y,
                    coerce: !1,
                    additionalCoerce: [],
                    validators: U.map((Z) => Z[200]),
                    sanitize: N,
                }),
            };
        let G = {};
        return (
            Object.keys(M).forEach((Z) => {
                if (isNaN(+Z)) return;
                let B = M[+Z];
                if (typeof B === 'string') {
                    if (B in X) {
                        let O = X[B];
                        G[+Z] =
                            S in O
                                ? P6(O, {
                                      modules: W,
                                      models: X,
                                      additionalProperties: J,
                                      dynamic: Q,
                                      normalize: Y,
                                      coerce: !1,
                                      additionalCoerce: [],
                                      validators: U.map((w) => w[+Z]),
                                      sanitize: N,
                                  })
                                : O;
                    }
                    return;
                }
                G[+Z] =
                    S in B
                        ? P6(B, {
                              modules: W,
                              models: X,
                              additionalProperties: J,
                              dynamic: Q,
                              normalize: Y,
                              coerce: !1,
                              additionalCoerce: [],
                              validators: U.map((O) => O[+Z]),
                              sanitize: N,
                          })
                        : B;
            }),
            G
        );
    },
    oJ,
    k0 = () => {
        if (!oJ)
            oJ = [
                {
                    from: c.Object({}),
                    to: () => c.ObjectString({}),
                    excludeRoot: !0,
                },
                { from: c.Array(c.Any()), to: () => c.ArrayString(c.Any()) },
            ];
        return oJ;
    },
    rJ,
    UU = () => {
        if (!rJ)
            rJ = [
                { from: c.Number(), to: ($) => c.Numeric($), rootOnly: !0 },
                {
                    from: c.Boolean(),
                    to: ($) => c.BooleanString($),
                    rootOnly: !0,
                },
            ];
        return rJ;
    },
    eZ = ({
        validator: $,
        modules: X,
        defaultConfig: W = {},
        config: Q,
        dynamic: Y,
        models: J,
        validators: U,
        sanitize: N,
    }) => {
        let M = P6($, {
            modules: X,
            dynamic: Y,
            models: J,
            additionalProperties: !0,
            coerce: !0,
            additionalCoerce: k0(),
            validators: U,
            sanitize: N,
        });
        if (M) M.config = vZ(M.config, Q);
        else
            (M = P6(c.Cookie(c.Any()), {
                modules: X,
                dynamic: Y,
                models: J,
                additionalProperties: !0,
                validators: U,
                sanitize: N,
            })),
                (M.config = W);
        return M;
    },
    z8 = ($) =>
        $[S] === 'Import' && $.$defs[$.$ref][S] === 'Object'
            ? $.$defs[$.$ref]
            : $,
    $6 = ($, X) => (X ? $ : ''),
    gF = [
        'json',
        'text',
        'urlencoded',
        'arrayBuffer',
        'formdata',
        'application/json',
        'text/plain',
        'application/x-www-form-urlencoded',
        'application/octet-stream',
        'multipart/form-data',
    ],
    BU = ({ context: $ = 'c', trace: X = [], addFn: W }) => {
        if (!X.length)
            return () => {
                return {
                    resolveChild() {
                        return () => {};
                    },
                    resolve() {},
                };
            };
        for (let Q = 0; Q < X.length; Q++)
            W(`let report${Q},reportChild${Q},reportErr${Q},reportErrChild${Q};let trace${Q}=${$}[ELYSIA_TRACE]?.[${Q}]??trace[${Q}](${$});
`);
        return (Q, { name: Y, total: J = 0 } = {}) => {
            if (!Y) Y = 'anonymous';
            let U = Q === 'error' ? 'reportErr' : 'report';
            for (let N = 0; N < X.length; N++)
                W(`${U}${N} = trace${N}.${Q}({id,event:'${Q}',name:'${Y}',begin:performance.now(),total:${J}})
`);
            return {
                resolve() {
                    for (let N = 0; N < X.length; N++)
                        W(`${U}${N}.resolve()
`);
                },
                resolveChild(N) {
                    for (let M = 0; M < X.length; M++)
                        W(`${U}Child${M}=${U}${M}.resolveChild?.shift()?.({id,event:'${Q}',name:'${N}',begin:performance.now()})
`);
                    return (M) => {
                        for (let G = 0; G < X.length; G++)
                            if (M)
                                W(
                                    `if(${M} instanceof Error){${U}Child${G}?.(${M}) }else{${U}Child${G}?.()}`,
                                );
                            else
                                W(`${U}Child${G}?.()
`);
                    };
                },
            };
        };
    },
    jW = ({
        schema: $,
        name: X,
        type: W,
        typeAlias: Q = W,
        normalize: Y,
        ignoreTryCatch: J = !1,
    }) => {
        if (!Y || !$.Clean || $.hasAdditionalProperties) return '';
        if (Y === !0 || Y === 'exactMirror') {
            if (J)
                return `${X}=validator.${Q}.Clean(${X})
`;
            return `try{${X}=validator.${Q}.Clean(${X})
}catch{}`;
        }
        if (Y === 'typebox')
            return `${X}=validator.${Q}.Clean(${X})
`;
        return '';
    },
    TF = ({
        injectResponse: $ = '',
        normalize: X = !1,
        validator: W,
        encodeSchema: Q = !1,
        isStaticResponse: Y = !1,
        hasSanitize: J = !1,
    }) => ({
        validate: (U, N = `c.${U}`) =>
            `c.set.status=422;throw new ValidationError('${U}',validator.${U},${N})`,
        response: (U = 'r') => {
            if (Y) return '';
            let N =
                $ +
                `
`;
            N += `if(${U} instanceof ElysiaCustomStatusResponse){c.set.status=${U}.code
${U}=${U}.response}switch(c.set.status){`;
            for (let [M, G] of Object.entries(W.response)) {
                N += `
case ${M}:if(${U} instanceof Response)break
`;
                let Z = G.schema?.noValidate === !0,
                    B = Z || J,
                    O = ({ ignoreTryCatch: z = !1 } = {}) =>
                        jW({
                            name: U,
                            schema: G,
                            type: 'response',
                            typeAlias: `response[${M}]`,
                            normalize: X,
                            ignoreTryCatch: z,
                        });
                if (B) N += O();
                let w = !B && X && !Z;
                if (Q && G.hasTransform)
                    N +=
                        `try{${U}=validator.response[${M}].Encode(${U})
c.set.status=${M}}catch{` +
                        (w
                            ? `try{
` +
                              O({ ignoreTryCatch: !0 }) +
                              `${U}=validator.response[${M}].Encode(${U})
}catch{throw new ValidationError('response',validator.response[${M}],${U})}`
                            : `throw new ValidationError('response',validator.response[${M}],${U})`) +
                        '}';
                else {
                    if (!B) N += O();
                    if (!Z)
                        N += `if(validator.response[${M}].Check(${U})===false)throw new ValidationError('response',validator.response[${M}],${U})
c.set.status=${M}
`;
                }
                N += `break
`;
            }
            return N + '}';
        },
    }),
    CX = ($) => {
        return ($?.fn ?? $).constructor.name === 'AsyncFunction';
    },
    kF = /=>\s?response\.clone\(/,
    vF = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/,
    G6 = ($) => {
        let X = typeof $ === 'object';
        if (X && $.isAsync !== void 0) return $.isAsync;
        let W = X ? $.fn : $;
        if (W.constructor.name === 'AsyncFunction') return !0;
        let Q = W.toString();
        if (kF.test(Q)) {
            if (X) $.isAsync = !1;
            return !1;
        }
        let Y = vF.test(Q);
        if (X) $.isAsync = Y;
        return Y;
    },
    FW = ($) => {
        let X = typeof $ === 'object';
        if (X && $.hasReturn !== void 0) return $.hasReturn;
        let W = X ? $.fn.toString() : typeof $ === 'string' ? $.toString() : $,
            Q = W.indexOf(')');
        if (W.charCodeAt(Q + 2) === 61 && W.charCodeAt(Q + 5) !== 123) {
            if (X) $.hasReturn = !0;
            return !0;
        }
        let Y = W.includes('return');
        if (X) $.hasReturn = Y;
        return Y;
    },
    Z8 = ($) => {
        let X = $?.fn ?? $;
        return (
            X.constructor.name === 'AsyncGeneratorFunction' ||
            X.constructor.name === 'GeneratorFunction'
        );
    },
    fF = ({
        app: $,
        path: X,
        method: W,
        hooks: Q,
        validator: Y,
        handler: J,
        allowMeta: U = !1,
        inference: N,
    }) => {
        let M = $['~adapter'].composeHandler,
            G = $['~adapter'].handler,
            Z = typeof J === 'function';
        if (!Z) {
            if (
                ((J = G.mapResponse(J, { headers: $.setHeaders ?? {} })),
                Q.parse?.length &&
                    Q.transform?.length &&
                    Q.beforeHandle?.length &&
                    Q.afterHandle?.length)
            ) {
                if (J instanceof Response)
                    return Function(
                        'a',
                        `"use strict";
return function(){return a.clone()}`,
                    )(J);
                return Function(
                    'a',
                    `"use strict";
return function(){return a}`,
                )(J);
            }
        }
        let B = Z ? 'handler(c)' : 'handler',
            O = !!Q.afterResponse?.length,
            w = !!Q.trace?.length,
            z = '';
        if (((N = CW(Q, N)), (N = CW({ handler: J }, N)), M.declare)) {
            let u = M.declare(N);
            if (u) z += u;
        }
        if (N.server)
            z += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
        Y.createBody?.(),
            Y.createQuery?.(),
            Y.createHeaders?.(),
            Y.createParams?.(),
            Y.createCookie?.(),
            Y.createResponse?.();
        let H =
                !!Y.body ||
                !!Y.headers ||
                !!Y.params ||
                !!Y.query ||
                !!Y.cookie ||
                !!Y.response,
            P = N.query || !!Y.query,
            E = Q.parse?.length === 1 && Q.parse[0].fn === 'none',
            j =
                W !== '' &&
                W !== 'GET' &&
                W !== 'HEAD' &&
                (N.body || !!Y.body || !!Q.parse?.length) &&
                !E,
            V = $.setHeaders,
            i = V && !!Object.keys(V).length,
            $$ =
                N.headers ||
                !!Y.headers ||
                (M.preferWebstandardHeaders !== !0 && N.body),
            y = N.cookie || !!Y.cookie,
            n = Y.cookie?.config
                ? vZ(Y?.cookie?.config, $.config.cookie)
                : $.config.cookie,
            k = '',
            b = () => {
                if (k) return k;
                if (n?.sign) {
                    if (!n.secrets)
                        throw new Error(
                            `t.Cookie required secret which is not set in (${W}) ${X}.`,
                        );
                    let u = !n.secrets
                        ? void 0
                        : typeof n.secrets === 'string'
                          ? n.secrets
                          : n.secrets[0];
                    if (
                        ((k += `const _setCookie = c.set.cookie
if(_setCookie){`),
                        n.sign === !0)
                    )
                        k += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${u}')}`;
                    else
                        for (let R of n.sign)
                            k += `if(_setCookie['${R}']?.value)c.set.cookie['${R}'].value=await signCookie(_setCookie['${R}'].value,'${u}')
`;
                    k += `}
`;
                }
                return k;
            },
            T = $.config.normalize,
            o = $.config.encodeSchema,
            e = TF({
                normalize: T,
                validator: Y,
                encodeSchema: o,
                isStaticResponse: J instanceof Response,
                hasSanitize: !!$.config.sanitize,
            });
        if ($$) z += M.headers;
        if (w)
            z += `const id=c[ELYSIA_REQUEST_ID]
`;
        let W$ = BU({
            trace: Q.trace,
            addFn: (u) => {
                z += u;
            },
        });
        if (((z += 'try{'), y)) {
            let u = (D, K) => {
                    let q = n?.[D] ?? K;
                    if (!q)
                        return typeof K === 'string'
                            ? `${D}:"${K}",`
                            : `${D}:${K},`;
                    if (typeof q === 'string') return `${D}:'${q}',`;
                    if (q instanceof Date)
                        return `${D}: new Date(${q.getTime()}),`;
                    return `${D}:${q},`;
                },
                R = n
                    ? `{secrets:${n.secrets !== void 0 ? (typeof n.secrets === 'string' ? `'${n.secrets}'` : '[' + n.secrets.reduce((D, K) => D + `'${K}',`, '') + ']') : 'undefined'},sign:${n.sign === !0 ? !0 : n.sign !== void 0 ? '[' + n.sign.reduce((D, K) => D + `'${K}',`, '') + ']' : 'undefined'},` +
                      u('domain') +
                      u('expires') +
                      u('httpOnly') +
                      u('maxAge') +
                      u('path', '/') +
                      u('priority') +
                      u('sameSite') +
                      u('secure') +
                      '}'
                    : 'undefined';
            if ($$)
                z += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${R})
`;
            else
                z += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${R})
`;
        }
        if (P) {
            let u = [];
            if (Y.query && Y.query.schema.type === 'object') {
                let R = Y.query.schema.properties;
                if (!Y.query.hasAdditionalProperties)
                    for (let [D, K] of Object.entries(R)) {
                        let q = K,
                            g =
                                q.type === 'array' ||
                                !!q.anyOf?.some(
                                    (p) =>
                                        p.type === 'string' &&
                                        p.format === 'ArrayString',
                                );
                        if (q && Y6 in q && q.type === 'array' && q.items)
                            q = q.items;
                        let { type: x, anyOf: f } = q;
                        u.push({
                            key: D,
                            isArray: g,
                            isNestedObjectArray:
                                (g && q.items?.type === 'object') ||
                                !!q.items?.anyOf?.some(
                                    (p) =>
                                        p.type === 'object' ||
                                        p.type === 'array',
                                ),
                            isObject:
                                x === 'object' ||
                                f?.some(
                                    (p) =>
                                        p.type === 'string' &&
                                        p.format === 'ArrayString',
                                ),
                            anyOf: !!f,
                        });
                    }
            }
            if (!u.length)
                z +=
                    'if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}';
            else {
                z += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi+1)
`;
                let R = 0;
                for (let {
                    key: D,
                    isArray: K,
                    isObject: q,
                    isNestedObjectArray: g,
                    anyOf: x,
                } of u) {
                    let f =
                        (R === 0 ? 'let ' : '') +
                        `memory=url.indexOf('&${D}=')
let a${R}
`;
                    if (K)
                        if (((z += f), g))
                            z += `while(memory!==-1){const start=memory+${D.length + 2}
memory=url.indexOf('&',start)
if(a${R}===undefined)
a${R}=''
else
a${R}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${R}+=temp
if(memory===-1)break
memory=url.indexOf('&${D}=',memory)
if(memory===-1)break}try{if(a${R}.charCodeAt(0)===91)a${R} = JSON.parse(a${R})
else
a${R}=JSON.parse('['+a${R}+']')}catch{}
`;
                        else
                            z += `while(memory!==-1){const start=memory+${D.length + 2}
memory=url.indexOf('&',start)
if(a${R}===undefined)a${R}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${R}=a${R}.concat(temp.split(','))}else{a${R}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${R}=a${R}.concat(temp.split(','))}else{a${R}.push(temp)}
}memory=url.indexOf('&${D}=',memory)
if(memory===-1) break
}`;
                    else if (q)
                        z +=
                            f +
                            `if(memory!==-1){const start=memory+${D.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${R}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${R}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${R}!==undefined)try{a${R}=JSON.parse(a${R})}catch{}}`;
                    else {
                        if (
                            ((z +=
                                f +
                                `if(memory!==-1){const start=memory+${D.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${R}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${R}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`),
                            x)
                        )
                            z += `
let deepMemory=url.indexOf('&${D}=',memory)
if(deepMemory!==-1){a${R}=[a${R}]
let first=true
while(true){const start=deepMemory+${D.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${R}.push(JSON.parse(value))}catch{a${R}.push(value)}if(deepMemory===-1)break}}`;
                        z += '}}';
                    }
                    R++,
                        (z += `
`);
                }
                (z +=
                    'c.query={' +
                    u.map(({ key: D }, K) => `'${D}':a${K}`).join(',') +
                    '}'),
                    (z += `} else c.query = {}
`);
            }
        }
        let W4 = typeof J === 'function' && G6(J),
            A$ = w || Q.afterResponse?.length ? 'c.response= ' : '',
            c6 =
                y ||
                j ||
                W4 ||
                !!Q.parse?.length ||
                !!Q.afterHandle?.some(G6) ||
                !!Q.beforeHandle?.some(G6) ||
                !!Q.transform?.some(G6) ||
                !!Q.mapResponse?.some(G6),
            Z1 =
                (typeof J === 'function' ? Z8(J) : !1) ||
                !!Q.beforeHandle?.some(Z8) ||
                !!Q.afterHandle?.some(Z8) ||
                !!Q.transform?.some(Z8),
            w1 = Object.keys(Y.response ?? {}),
            q4 = w1.length > 1,
            e4 = w1.length === 0 || (w1.length === 1 && w1[0] === '200'),
            s$ = N.cookie || N.set || $$ || w || q4 || !e4 || (Z && i) || Z1,
            U6 = (
                u = 'r',
            ) => `return ${s$ ? 'mapResponse' : 'mapCompactResponse'}(${A$}${u}${s$ ? ',c.set' : ''}${j6})
`,
            j6 = Z1 || M.mapResponseContext ? `,${M.mapResponseContext}` : '';
        if (w || N.route)
            z += `c.route=\`${X}\`
`;
        let x4 = W$('parse', { total: Q.parse?.length });
        if (j) {
            let u = !!Q.parse?.length || N.body || Y.body;
            if (M.parser.declare) z += M.parser.declare;
            z += `
try{`;
            let R =
                typeof Q.parse === 'string'
                    ? Q.parse
                    : Array.isArray(Q.parse) && Q.parse.length === 1
                      ? typeof Q.parse[0] === 'string'
                          ? Q.parse[0]
                          : typeof Q.parse[0].fn === 'string'
                            ? Q.parse[0].fn
                            : void 0
                      : void 0;
            if (!R && Y.body && !Q.parse?.length) {
                let D = Y.body.schema;
                if (
                    D &&
                    D.anyOf &&
                    D[S] === 'Union' &&
                    D.anyOf?.length === 2 &&
                    D.anyOf?.find((K) => K[S] === 'ElysiaForm')
                )
                    R = 'formdata';
            }
            if (R && gF.includes(R)) {
                let D = W$('parse', { total: Q.parse?.length }),
                    K = !!Y.body?.isOptional;
                switch (R) {
                    case 'json':
                    case 'application/json':
                        z += M.parser.json(K);
                        break;
                    case 'text':
                    case 'text/plain':
                        z += M.parser.text(K);
                        break;
                    case 'urlencoded':
                    case 'application/x-www-form-urlencoded':
                        z += M.parser.urlencoded(K);
                        break;
                    case 'arrayBuffer':
                    case 'application/octet-stream':
                        z += M.parser.arrayBuffer(K);
                        break;
                    case 'formdata':
                    case 'multipart/form-data':
                        z += M.parser.formData(K);
                        break;
                    default:
                        if (R[0] in $['~parser'])
                            (z += $$
                                ? "let contentType = c.headers['content-type']"
                                : "let contentType = c.request.headers.get('content-type')"),
                                (z += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${R}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`);
                        break;
                }
                D.resolve();
            } else if (u) {
                z += `
`;
                let D = Q.parse?.length ? 'let' : 'const';
                z += $$
                    ? `${D} contentType=c.headers['content-type']
`
                    : `${D} contentType=c.request.headers.get('content-type')
`;
                let K = !1;
                if (Q.parse?.length)
                    z += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
                else {
                    K = !0;
                    let g = !!Y.body?.isOptional;
                    z +=
                        `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` +
                        M.parser.json(g) +
                        `break
case 120:` +
                        M.parser.urlencoded(g) +
                        `break
case 111:` +
                        M.parser.arrayBuffer(g) +
                        `break
case 114:` +
                        M.parser.formData(g) +
                        `break
default:if(contentType.charCodeAt(0)===116){` +
                        M.parser.text(g) +
                        `}break
}`;
                }
                let q = W$('parse', { total: Q.parse?.length });
                if (Q.parse)
                    for (let g = 0; g < Q.parse.length; g++) {
                        let x = `bo${g}`;
                        if (g !== 0)
                            z += `
if(!used){`;
                        if (typeof Q.parse[g].fn === 'string') {
                            let f = q.resolveChild(Q.parse[g].fn),
                                p = !!Y.body?.isOptional;
                            switch (Q.parse[g].fn) {
                                case 'json':
                                case 'application/json':
                                    (K = !0), (z += M.parser.json(p));
                                    break;
                                case 'text':
                                case 'text/plain':
                                    (K = !0), (z += M.parser.text(p));
                                    break;
                                case 'urlencoded':
                                case 'application/x-www-form-urlencoded':
                                    (K = !0), (z += M.parser.urlencoded(p));
                                    break;
                                case 'arrayBuffer':
                                case 'application/octet-stream':
                                    (K = !0), (z += M.parser.arrayBuffer(p));
                                    break;
                                case 'formdata':
                                case 'multipart/form-data':
                                    (K = !0), (z += M.parser.formData(p));
                                    break;
                                default:
                                    z += `let ${x}=parser['${Q.parse[g].fn}'](c,contentType)
if(${x} instanceof Promise)${x}=await ${x}
if(${x}!==undefined){c.body=${x};used=true;}
`;
                            }
                            f();
                        } else {
                            let f = q.resolveChild(Q.parse[g].fn.name);
                            (z += `let ${x}=e.parse[${g}]
${x}=${x}(c,contentType)
if(${x} instanceof Promise)${x}=await ${x}
if(${x}!==undefined){c.body=${x};used=true}`),
                                f();
                        }
                        if (g !== 0) z += '}';
                        if (K) break;
                    }
                if ((q.resolve(), !K)) {
                    let g = !!Y.body?.isOptional;
                    if (Q.parse?.length)
                        z += `
if(!used){
if(!contentType) throw new ParseError()
`;
                    (z += 'switch(contentType){'),
                        (z +=
                            `case 'application/json':
` +
                            M.parser.json(g) +
                            `break
case 'text/plain':` +
                            M.parser.text(g) +
                            `break
case 'application/x-www-form-urlencoded':` +
                            M.parser.urlencoded(g) +
                            `break
case 'application/octet-stream':` +
                            M.parser.arrayBuffer(g) +
                            `break
case 'multipart/form-data':` +
                            M.parser.formData(g) +
                            `break
`);
                    for (let x of Object.keys($['~parser']))
                        z += `case '${x}':let bo${x}=parser['${x}'](c,contentType)
if(bo${x} instanceof Promise)bo${x}=await bo${x}
if(bo${x} instanceof ElysiaCustomStatusResponse)throw result
if(bo${x}!==undefined)c.body=bo${x}
break
`;
                    if (Q.parse?.length) z += '}';
                    z += '}';
                }
                if (Q.parse?.length)
                    z += `
delete c.contentType`;
            }
            z += '}catch(error){throw new ParseError(error)}';
        }
        if ((x4.resolve(), Q?.transform)) {
            let u = W$('transform', { total: Q.transform.length });
            if (Q.transform.length)
                z += `let transformed
`;
            for (let R = 0; R < Q.transform.length; R++) {
                let D = Q.transform[R],
                    K = u.resolveChild(D.fn.name);
                if (
                    ((z += G6(D)
                        ? `transformed=await e.transform[${R}](c)
`
                        : `transformed=e.transform[${R}](c)
`),
                    D.subType === 'mapDerive')
                )
                    z += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
                else
                    z += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
                K();
            }
            u.resolve();
        }
        let T6 = [];
        if (Y) {
            if (Y.headers) {
                if (Y.headers.hasDefault)
                    for (let [u, R] of Object.entries(
                        L$.Default(Y.headers.schema, {}),
                    )) {
                        let D =
                            typeof R === 'object'
                                ? JSON.stringify(R)
                                : typeof R === 'string'
                                  ? `'${R}'`
                                  : R;
                        if (D !== void 0)
                            z += `c.headers['${u}']??=${D}
`;
                    }
                if (
                    ((z += jW({
                        name: 'c.headers',
                        schema: Y.headers,
                        type: 'headers',
                        normalize: T,
                    })),
                    Y.headers.isOptional)
                )
                    z += 'if(isNotEmpty(c.headers)){';
                if (Y.body?.schema?.noValidate !== !0)
                    z +=
                        'if(validator.headers.Check(c.headers) === false){' +
                        e.validate('headers') +
                        '}';
                if (Y.headers.hasTransform)
                    z += `c.headers=validator.headers.Decode(c.headers)
`;
                if (Y.headers.isOptional) z += '}';
            }
            if (Y.params) {
                if (Y.params.hasDefault)
                    for (let [u, R] of Object.entries(
                        L$.Default(Y.params.schema, {}),
                    )) {
                        let D =
                            typeof R === 'object'
                                ? JSON.stringify(R)
                                : typeof R === 'string'
                                  ? `'${R}'`
                                  : R;
                        if (D !== void 0)
                            z += `c.params['${u}']??=${D}
`;
                    }
                if (Y.params?.schema?.noValidate !== !0)
                    z +=
                        'if(validator.params.Check(c.params)===false){' +
                        e.validate('params') +
                        '}';
                if (Y.params.hasTransform)
                    z += `c.params=validator.params.Decode(c.params)
`;
            }
            if (Y.query) {
                if (Y.query.hasDefault)
                    for (let [u, R] of Object.entries(
                        L$.Default(Y.query.schema, {}),
                    )) {
                        let D =
                            typeof R === 'object'
                                ? JSON.stringify(R)
                                : typeof R === 'string'
                                  ? `'${R}'`
                                  : R;
                        if (D !== void 0)
                            z += `if(c.query['${u}']===undefined)c.query['${u}']=${D}
`;
                        z += jW({
                            name: 'c.query',
                            schema: Y.query,
                            type: 'query',
                            normalize: T,
                        });
                    }
                if (Y.query.isOptional) z += 'if(isNotEmpty(c.query)){';
                if (Y.query?.schema?.noValidate !== !0)
                    z +=
                        'if(validator.query.Check(c.query)===false){' +
                        e.validate('query') +
                        '}';
                if (Y.query.hasTransform)
                    z += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
                if (Y.query.isOptional) z += '}';
            }
            if (j && Y.body) {
                if (Y.body.hasTransform || Y.body.isOptional)
                    z += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
                let u = xF(Y.body.schema),
                    R = !1;
                if (Y.body.hasDefault) {
                    let D = L$.Default(
                            Y.body.schema,
                            Y.body.schema.type === 'object' ||
                                (Y.body.schema[S] === 'Import' &&
                                    Y.body.schema.$defs[Y.body.schema.$ref][
                                        S
                                    ] === 'Object')
                                ? {}
                                : void 0,
                        ),
                        K = z8(Y.body.schema);
                    if (
                        !u &&
                        D &&
                        typeof D === 'object' &&
                        (N0('File', K) || N0('Files', K))
                    ) {
                        R = !0;
                        for (let [g, x] of Object.entries(D))
                            if (x === 'File' || x === 'Files') delete D[g];
                        if (!f$(D)) D = void 0;
                    }
                    let q =
                        typeof D === 'object'
                            ? JSON.stringify(D)
                            : typeof D === 'string'
                              ? `'${D}'`
                              : D;
                    if (D !== void 0 && D !== null)
                        if (Array.isArray(D))
                            z += `if(!c.body)c.body=${q}
`;
                        else if (typeof D === 'object')
                            z += `c.body=Object.assign(${q},c.body)
`;
                        else
                            z += `c.body=${q}
`;
                    if (
                        ((z += jW({
                            name: 'c.body',
                            schema: Y.body,
                            type: 'body',
                            normalize: T,
                        })),
                        Y.body?.schema?.noValidate !== !0)
                    )
                        if (Y.body.isOptional)
                            z +=
                                'if(isNotEmptyObject&&validator.body.Check(c.body)===false){' +
                                e.validate('body') +
                                '}';
                        else
                            z +=
                                'if(validator.body.Check(c.body)===false){' +
                                e.validate('body') +
                                '}';
                } else if (
                    ((z += jW({
                        name: 'c.body',
                        schema: Y.body,
                        type: 'body',
                        normalize: T,
                    })),
                    Y.body?.schema?.noValidate !== !0)
                )
                    if (Y.body.isOptional)
                        z +=
                            'if(isNotEmptyObject&&validator.body.Check(c.body)===false){' +
                            e.validate('body') +
                            '}';
                    else
                        z +=
                            'if(validator.body.Check(c.body)===false){' +
                            e.validate('body') +
                            '}';
                if (Y.body.hasTransform)
                    z += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
                if (u && Y.body.schema.anyOf?.length) {
                    let D = Object.values(Y.body.schema.anyOf);
                    for (let K = 0; K < D.length; K++) {
                        let q = D[K];
                        if (N0('File', q) || N0('Files', q)) {
                            let g = P6(q, {
                                modules: $.definitions.typebox,
                                dynamic: !$.config.aot,
                                models: $.definitions.type,
                                normalize: $.config.normalize,
                                additionalCoerce: UU(),
                                sanitize: () => $.config.sanitize,
                            });
                            if (g) {
                                let x = T6.length === 0,
                                    f = Object.entries(q.properties),
                                    p = x
                                        ? `
`
                                        : ' else ';
                                p += `if(fileUnions[${T6.length}].Check(c.body)){`;
                                let E$ = '',
                                    I6 = 0;
                                for (let L6 = 0; L6 < f.length; L6++) {
                                    let [Y4, D1] = f[L6];
                                    if (
                                        !D1.extension ||
                                        (D1[S] !== 'File' && D1[S] !== 'Files')
                                    )
                                        continue;
                                    if (I6) E$ += ',';
                                    (E$ += `validateFileExtension(c.body.${Y4},${JSON.stringify(D1.extension)},'body.${Y4}')`),
                                        I6++;
                                }
                                if (E$) {
                                    if (I6 === 1)
                                        p += `await ${E$}
`;
                                    else if (I6 > 1)
                                        p += `await Promise.all([${E$}])
`;
                                    (p += '}'), (z += p), T6.push(g);
                                }
                            }
                        }
                    }
                } else if (
                    R ||
                    (!u &&
                        (N0('File', z8(Y.body.schema)) ||
                            N0('Files', z8(Y.body.schema))))
                ) {
                    let D = '',
                        K = 0;
                    for (let [q, g] of Object.entries(
                        z8(Y.body.schema).properties,
                    )) {
                        if (
                            !g.extension ||
                            (g[S] !== 'File' && g[S] !== 'Files')
                        )
                            continue;
                        if (K) D += ',';
                        (D += `validateFileExtension(c.body.${q},${JSON.stringify(g.extension)},'body.${q}')`),
                            K++;
                    }
                    if (K)
                        z += `
`;
                    if (K === 1)
                        z += `await ${D}
`;
                    else if (K > 1)
                        z += `await Promise.all([${D}])
`;
                }
            }
            if (Y.cookie) {
                let u = eZ({
                    modules: $.definitions.typebox,
                    validator: Y.cookie,
                    defaultConfig: $.config.cookie,
                    dynamic: !!$.config.aot,
                    config: Y.cookie?.config ?? {},
                    models: $.definitions.type,
                });
                if (
                    ((z += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`),
                    u.hasDefault)
                )
                    for (let [R, D] of Object.entries(L$.Default(u.schema, {})))
                        z += `cookieValue['${R}'] = ${typeof D === 'object' ? JSON.stringify(D) : D}
`;
                if (u.isOptional) z += 'if(isNotEmpty(c.cookie)){';
                if (Y.body?.schema?.noValidate !== !0)
                    z +=
                        'if(validator.cookie.Check(cookieValue)===false){' +
                        e.validate('cookie', 'cookieValue') +
                        '}';
                if (u.hasTransform)
                    z += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
                if (u.isOptional) z += '}';
            }
        }
        if (Q?.beforeHandle) {
            let u = W$('beforeHandle', { total: Q.beforeHandle.length }),
                R = !1;
            for (let D = 0; D < Q.beforeHandle.length; D++) {
                let K = Q.beforeHandle[D],
                    q = u.resolveChild(K.fn.name),
                    g = FW(K);
                if (K.subType === 'resolve' || K.subType === 'mapResolve') {
                    if (!R)
                        (R = !0),
                            (z += `
let resolved
`);
                    if (
                        ((z += G6(K)
                            ? `resolved=await e.beforeHandle[${D}](c);
`
                            : `resolved=e.beforeHandle[${D}](c);
`),
                        K.subType === 'mapResolve')
                    )
                        z += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
                    else
                        z += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
                } else if (!g)
                    (z += G6(K)
                        ? `await e.beforeHandle[${D}](c)
`
                        : `e.beforeHandle[${D}](c)
`),
                        q();
                else {
                    if (
                        ((z += G6(K)
                            ? `be=await e.beforeHandle[${D}](c)
`
                            : `be=e.beforeHandle[${D}](c)
`),
                        q('be'),
                        (z += 'if(be!==undefined){'),
                        u.resolve(),
                        Q.afterHandle?.length)
                    ) {
                        W$('handle', { name: Z ? J.name : void 0 }).resolve();
                        let f = W$('afterHandle', {
                            total: Q.afterHandle.length,
                        });
                        for (let p = 0; p < Q.afterHandle.length; p++) {
                            let E$ = Q.afterHandle[p],
                                I6 = FW(E$),
                                L6 = f.resolveChild(E$.fn.name);
                            if (
                                ((z += `c.response = be
`),
                                !I6)
                            )
                                z += G6(E$.fn)
                                    ? `await e.afterHandle[${p}](c, be)
`
                                    : `e.afterHandle[${p}](c, be)
`;
                            else
                                (z += G6(E$.fn)
                                    ? `af=await e.afterHandle[${p}](c)
`
                                    : `af=e.afterHandle[${p}](c)
`),
                                    (z += `if(af!==undefined) c.response=be=af
`);
                            L6('af');
                        }
                        f.resolve();
                    }
                    if (Y.response) z += e.response('be');
                    let x = W$('mapResponse', { total: Q.mapResponse?.length });
                    if (Q.mapResponse?.length) {
                        z += `c.response=be
`;
                        for (let f = 0; f < Q.mapResponse.length; f++) {
                            let p = Q.mapResponse[f],
                                E$ = x.resolveChild(p.fn.name);
                            (z += `if(mr===undefined){mr=${CX(p) ? 'await ' : ''}e.mapResponse[${f}](c)
if(mr!==undefined)be=c.response=mr}`),
                                E$();
                        }
                    }
                    x.resolve(),
                        (z += b()),
                        (z += `return mapEarlyResponse(${A$}be,c.set${j6})}
`);
                }
            }
            u.resolve();
        }
        if (Q.afterHandle?.length) {
            let u = W$('handle', { name: Z ? J.name : void 0 });
            if (Q.afterHandle.length)
                z += W4
                    ? `let r=c.response=await ${B}
`
                    : `let r=c.response=${B}
`;
            else
                z += W4
                    ? `let r=await ${B}
`
                    : `let r=${B}
`;
            u.resolve();
            let R = W$('afterHandle', { total: Q.afterHandle.length });
            for (let K = 0; K < Q.afterHandle.length; K++) {
                let q = Q.afterHandle[K],
                    g = FW(q),
                    x = R.resolveChild(q.fn.name);
                if (!g)
                    (z += G6(q.fn)
                        ? `await e.afterHandle[${K}](c)
`
                        : `e.afterHandle[${K}](c)
`),
                        x();
                else if (
                    ((z += G6(q.fn)
                        ? `af=await e.afterHandle[${K}](c)
`
                        : `af=e.afterHandle[${K}](c)
`),
                    x('af'),
                    Y.response)
                )
                    (z += 'if(af!==undefined){'),
                        R.resolve(),
                        (z += e.response('af')),
                        (z += 'c.response=af}');
                else
                    (z += 'if(af!==undefined){'),
                        R.resolve(),
                        (z += 'c.response=af}');
            }
            if (
                (R.resolve(),
                (z += `r=c.response
`),
                Y.response)
            )
                z += e.response();
            z += b();
            let D = W$('mapResponse', { total: Q.mapResponse?.length });
            if (Q.mapResponse?.length)
                for (let K = 0; K < Q.mapResponse.length; K++) {
                    let q = Q.mapResponse[K],
                        g = D.resolveChild(q.fn.name);
                    (z += `mr=${CX(q) ? 'await ' : ''}e.mapResponse[${K}](c)
if(mr!==undefined)r=c.response=mr
`),
                        g();
                }
            D.resolve(), (z += U6());
        } else {
            let u = W$('handle', { name: Z ? J.name : void 0 });
            if (Y.response || Q.mapResponse?.length) {
                if (
                    ((z += W4
                        ? `let r=await ${B}
`
                        : `let r=${B}
`),
                    u.resolve(),
                    Y.response)
                )
                    z += e.response();
                W$('afterHandle').resolve();
                let R = W$('mapResponse', { total: Q.mapResponse?.length });
                if (Q.mapResponse?.length) {
                    z += `
c.response=r
`;
                    for (let D = 0; D < Q.mapResponse.length; D++) {
                        let K = Q.mapResponse[D],
                            q = R.resolveChild(K.fn.name);
                        (z += `
if(mr===undefined){mr=${CX(K) ? 'await ' : ''}e.mapResponse[${D}](c)
if(mr!==undefined)r=c.response=mr}
`),
                            q();
                    }
                }
                if ((R.resolve(), (z += b()), J instanceof Response))
                    (z += N.set
                        ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${A$}${B}.clone(),c.set${j6})else return ${B}.clone()`
                        : `return ${B}.clone()`),
                        (z += `
`);
                else z += U6();
            } else if (y || w) {
                (z += W4
                    ? `let r=await ${B}
`
                    : `let r=${B}
`),
                    u.resolve(),
                    W$('afterHandle').resolve();
                let R = W$('mapResponse', { total: Q.mapResponse?.length });
                if (Q.mapResponse?.length) {
                    z += `c.response= r
`;
                    for (let D = 0; D < Q.mapResponse.length; D++) {
                        let K = Q.mapResponse[D],
                            q = R.resolveChild(K.fn.name);
                        (z += `if(mr===undefined){mr=${CX(K) ? 'await ' : ''}e.mapResponse[${D}](c)
if(mr!==undefined)r=c.response=mr}`),
                            q();
                    }
                }
                R.resolve(), (z += b() + U6());
            } else {
                u.resolve();
                let R = W4 ? `await ${B}` : B;
                if ((W$('afterHandle').resolve(), J instanceof Response))
                    z += N.set
                        ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${A$}${B}.clone(),c.set${j6})
else return ${B}.clone()
`
                        : `return ${B}.clone()
`;
                else z += U6(R);
            }
        }
        if (
            ((z += `
}catch(error){`),
            !c6 && Q.error?.length)
        )
            z += 'return(async()=>{';
        if (
            ((z += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`),
            y)
        )
            z += b();
        if (w && Q.trace)
            for (let u = 0; u < Q.trace.length; u++)
                z += `report${u}?.resolve(error);reportChild${u}?.(error)
`;
        let A4 = W$('error', { total: Q.error?.length });
        if (Q.error?.length) {
            if (
                ((z += `c.error=error
`),
                H)
            )
                z += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
            else
                z += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
            z += `let er
`;
            for (let u = 0; u < Q.error.length; u++) {
                let R = A4.resolveChild(Q.error[u].fn.name);
                if (G6(Q.error[u]))
                    z += `er=await e.error[${u}](c)
`;
                else
                    z += `er=e.error[${u}](c)
if(er instanceof Promise)er=await er
`;
                R();
                let D = W$('mapResponse', { total: Q.mapResponse?.length });
                if (Q.mapResponse?.length)
                    for (let K = 0; K < Q.mapResponse.length; K++) {
                        let q = Q.mapResponse[K],
                            g = D.resolveChild(q.fn.name);
                        (z += `c.response=er
er=e.mapResponse[${K}](c)
if(er instanceof Promise)er=await er
`),
                            g();
                    }
                if (
                    (D.resolve(),
                    (z += `er=mapEarlyResponse(er,set${j6})
`),
                    (z += 'if(er){'),
                    w && Q.trace)
                ) {
                    for (let K = 0; K < Q.trace.length; K++)
                        z += `report${K}.resolve()
`;
                    A4.resolve();
                }
                z += 'return er}';
            }
        }
        if (
            (A4.resolve(),
            (z += 'return handleError(c,error,true)'),
            !c6 && Q.error?.length)
        )
            z += '})()';
        if (((z += '}'), O || w)) {
            if (((z += 'finally{ '), !c6)) z += ';(async()=>{';
            let u = W$('afterResponse', { total: Q.afterResponse?.length });
            if (O && Q.afterResponse)
                for (let R = 0; R < Q.afterResponse.length; R++) {
                    let D = u.resolveChild(Q.afterResponse[R].fn.name);
                    (z += `
await e.afterResponse[${R}](c)
`),
                        D();
                }
            if ((u.resolve(), !c6)) z += '})()';
            z += '}';
        }
        let n1 = M.inject ? Object.keys(M.inject).join(',') + ',' : '',
            b4 =
                'const {handler,handleError,hooks:e, ' +
                $6('validator,', H) +
                'mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{' +
                $6('parseQuery,', j) +
                $6('parseQueryFromURL,', P) +
                '},error:{' +
                $6('ValidationError,', H) +
                $6('ParseError', j) +
                '},validateFileExtension,schema,definitions,ERROR_CODE,' +
                $6('parseCookie,', y) +
                $6('signCookie,', y) +
                $6('decodeURIComponent,', P) +
                'ElysiaCustomStatusResponse,' +
                $6('ELYSIA_TRACE,', w) +
                $6('ELYSIA_REQUEST_ID,', w) +
                $6('parser,', Q.parse?.length) +
                $6('getServer,', N.server) +
                $6('fileUnions,', T6.length) +
                n1 +
                $6('TypeBoxError', H) +
                `}=hooks
const trace=e.trace
return ${c6 ? 'async ' : ''}function handle(c){`;
        if (Q.beforeHandle?.length)
            b4 += `let be
`;
        if (Q.afterHandle?.length)
            b4 += `let af
`;
        if (Q.mapResponse?.length)
            b4 += `let mr
`;
        if (U)
            b4 += `c.schema=schema
c.defs=definitions
`;
        (z = b4 + z + '}'), (b4 = '');
        try {
            return Function(
                'hooks',
                `"use strict";
` + z,
            )({
                handler: J,
                hooks: DZ({ ...Q }),
                validator: H ? Y : void 0,
                handleError: $.handleError,
                mapResponse: G.mapResponse,
                mapCompactResponse: G.mapCompactResponse,
                mapEarlyResponse: G.mapEarlyResponse,
                isNotEmpty: f$,
                utils: {
                    parseQuery: j ? D8 : void 0,
                    parseQueryFromURL: P ? _F : void 0,
                },
                error: {
                    ValidationError: H ? V$ : void 0,
                    ParseError: j ? mZ : void 0,
                },
                validateFileExtension: cZ,
                schema: $.router.history,
                definitions: $.definitions.type,
                ERROR_CODE: A8,
                parseCookie: y ? pZ : void 0,
                signCookie: y ? q8 : void 0,
                decodeURIComponent: P ? KF.default : void 0,
                ElysiaCustomStatusResponse: g6,
                ELYSIA_TRACE: w ? x8 : void 0,
                ELYSIA_REQUEST_ID: w ? RW : void 0,
                getServer: () => $.getServer(),
                fileUnions: T6.length ? T6 : void 0,
                TypeBoxError: H ? r : void 0,
                parser: $['~parser'],
                ...M.inject,
            });
        } catch (u) {
            let R = DZ(Q);
            console.log('[Composer] failed to generate optimized handler'),
                console.log('---'),
                console.log({
                    handler: typeof J === 'function' ? J.toString() : J,
                    instruction: z,
                    hooks: {
                        ...R,
                        transform: R?.transform?.map?.((D) => D.toString()),
                        resolve: R?.resolve?.map?.((D) => D.toString()),
                        beforeHandle: R?.beforeHandle?.map?.((D) =>
                            D.toString(),
                        ),
                        afterHandle: R?.afterHandle?.map?.((D) => D.toString()),
                        mapResponse: R?.mapResponse?.map?.((D) => D.toString()),
                        parse: R?.parse?.map?.((D) => D.toString()),
                        error: R?.error?.map?.((D) => D.toString()),
                        afterResponse: R?.afterResponse?.map?.((D) =>
                            D.toString(),
                        ),
                        stop: R?.stop?.map?.((D) => D.toString()),
                    },
                    validator: Y,
                    definitions: $.definitions.type,
                    error: u,
                }),
                console.log('---'),
                process.exit(1);
        }
    },
    $w = ($, X) => {
        let W = '',
            Q = BU({
                trace: $.event.trace,
                addFn:
                    X ??
                    ((Y) => {
                        W += Y;
                    }),
            })('request', { total: $.event.request?.length });
        if ($.event.request?.length) {
            W += 'try{';
            for (let Y = 0; Y < $.event.request.length; Y++) {
                let J = $.event.request[Y],
                    U = FW(J),
                    N = G6(J),
                    M = Q.resolveChild($.event.request[Y].fn.name);
                if (U)
                    (W += `re=mapEarlyResponse(${N ? 'await ' : ''}onRequest[${Y}](c),c.set)
`),
                        M('re'),
                        (W += `if(re!==undefined)return re
`);
                else
                    (W += `${N ? 'await ' : ''}onRequest[${Y}](c)
`),
                        M();
            }
            W += '}catch(error){return app.handleError(c,error,false)}';
        }
        return Q.resolve(), W;
    },
    Xw = ($, X = 'map') => {
        let W = $.extender.higherOrderFunctions;
        if (!W.length) return 'return ' + X;
        let Q = $['~adapter'].composeGeneralHandler,
            Y = X;
        for (let J = 0; J < W.length; J++)
            Y = `hoc[${J}](${Y},${Q.parameters})`;
        return `return function hocMap(${Q.parameters}){return ${Y}(${Q.parameters})}`;
    },
    tJ = ($) => {
        let X = $['~adapter'].composeGeneralHandler;
        $.router.http.build();
        let W = X.error404(!!$.event.request?.length, !!$.event.error?.length),
            Q = $.event.trace?.length,
            Y = '',
            J = $.router,
            U = J.http.root.WS
                ? `const route=router.find(r.method === "GET" && r.headers.get('upgrade')==='websocket'?'WS':r.method,p)`
                : 'const route=router.find(r.method,p)';
        (U += J.http.root.ALL
            ? `??router.find("ALL",p)
`
            : `
`),
            (U += W.code),
            (U += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`);
        let N = '';
        for (let [B, O] of Object.entries(J.static)) {
            if (((N += `case'${B}':`), $.config.strictPath !== !0))
                N += `case'${PW(B)}':`;
            let w = SW(B);
            if (B !== w) N += `case'${w}':`;
            if (((N += 'switch(r.method){'), 'GET' in O || 'WS' in O)) {
                if (((N += "case 'GET':"), 'WS' in O))
                    N += `if(r.headers.get('upgrade')==='websocket')return ht[${O.WS}].composed(c)
`;
                if ('GET' in O)
                    N += `return ht[${O.GET}].composed(c)
`;
            }
            for (let [z, H] of Object.entries(O)) {
                if (z === 'ALL' || z === 'GET' || z === 'WS') continue;
                N += `case '${z}':return ht[${H}].composed(c)
`;
            }
            if ('ALL' in O)
                N += `default:return ht[${O.ALL}].composed(c)
`;
            else
                N += `default:break map
`;
            N += '}';
        }
        let M = !!$.event.request?.some(G6),
            G = X.inject ? Object.keys(X.inject).join(',') + ',' : '';
        if (
            ((Y +=
                `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,` +
                $6('ELYSIA_TRACE,', Q) +
                $6('ELYSIA_REQUEST_ID,', Q) +
                G +
                `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`),
            $.event.request?.length)
        )
            Y += `const onRequest=app.event.request.map(x=>x.fn)
`;
        if (((Y += W.declare), $.event.trace?.length))
            Y +=
                'const ' +
                $.event.trace
                    .map((B, O) => `tr${O}=app.event.trace[${O}].fn`)
                    .join(',') +
                `
`;
        if (
            ((Y += `${M ? 'async ' : ''}function map(${X.parameters}){`),
            $.event.request?.length)
        )
            Y += `let re
`;
        if (((Y += X.createContext($)), $.event.trace?.length))
            Y +=
                'c[ELYSIA_TRACE]=[' +
                $.event.trace.map((B, O) => `tr${O}(c)`).join(',') +
                `]
`;
        if (((Y += $w($)), N))
            Y +=
                `
map: switch(p){
` +
                N +
                '}';
        (Y +=
            U +
            `}
` +
            Xw($)),
            ($.handleError = Ww($));
        let Z = Function(
            'data',
            `"use strict";
` + Y,
        )({
            app: $,
            mapEarlyResponse: $['~adapter'].handler.mapEarlyResponse,
            NotFoundError: ZU,
            randomId: R8,
            handleError: $.handleError,
            status: P8,
            redirect: zU,
            ELYSIA_TRACE: Q ? x8 : void 0,
            ELYSIA_REQUEST_ID: Q ? RW : void 0,
            ...X.inject,
        });
        if (VX) Bun.gc(!1);
        return Z;
    },
    Ww = ($) => {
        let X = $.event,
            W = '',
            Q = $['~adapter'].composeError,
            Y = Q.inject ? Object.keys(Q.inject).join(',') + ',' : '',
            J = !!$.event.trace?.length;
        if (
            ((W +=
                'const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,' +
                $6('onError,', $.event.error) +
                $6('afterResponse,', $.event.afterResponse) +
                $6('trace,', $.event.trace) +
                $6('onMapResponse,', $.event.mapResponse) +
                $6('ELYSIA_TRACE,', J) +
                $6('ELYSIA_REQUEST_ID,', J) +
                Y +
                `}=inject
`),
            (W += `return ${$.event.error?.find(G6) || $.event.mapResponse?.find(G6) ? 'async ' : ''}function(context,error,skipGlobal){`),
            (W += ''),
            J)
        )
            W += `const id=context[ELYSIA_REQUEST_ID]
`;
        let U = BU({
            context: 'context',
            trace: X.trace,
            addFn: (Z) => {
                W += Z;
            },
        });
        if (
            ((W += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`),
            Q.declare)
        )
            W += Q.declare;
        let N =
            J || !!X.afterResponse?.length || !!X.afterResponse?.length
                ? 'context.response = '
                : '';
        if ($.event.error)
            for (let Z = 0; Z < $.event.error.length; Z++) {
                let B = $.event.error[Z],
                    O = `${G6(B) ? 'await ' : ''}onError[${Z}](context)
`;
                if (((W += 'if(skipGlobal!==true){'), FW(B))) {
                    W += `_r=${O}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${Q.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
                    let w = U('mapResponse', {
                        total: X.mapResponse?.length,
                        name: 'context',
                    });
                    if (X.mapResponse?.length)
                        for (let z = 0; z < X.mapResponse.length; z++) {
                            let H = X.mapResponse[z],
                                P = w.resolveChild(H.fn.name);
                            (W += `context.response=_r_r=${CX(H) ? 'await ' : ''}onMapResponse[${z}](context)
`),
                                P();
                        }
                    w.resolve(),
                        (W += `return mapResponse(${N}_r,set${Q.mapResponseContext})}`);
                } else W += O;
                W += '}';
            }
        (W +=
            `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` +
            Q.validationError +
            `
}
`),
            (W +=
                `if(error instanceof Error){
if(typeof error.toResponse==='function')return context.response=error.toResponse()
` +
                Q.unknownError +
                `
}`);
        let M = U('mapResponse', {
            total: X.mapResponse?.length,
            name: 'context',
        });
        if (
            ((W += `
if(!context.response)context.response=error.message??error
`),
            X.mapResponse?.length)
        ) {
            W += `let mr
`;
            for (let Z = 0; Z < X.mapResponse.length; Z++) {
                let B = X.mapResponse[Z],
                    O = M.resolveChild(B.fn.name);
                (W += `if(mr===undefined){mr=${CX(B) ? 'await ' : ''}onMapResponse[${Z}](context)
if(mr!==undefined)error=context.response=mr}`),
                    O();
            }
        }
        M.resolve(),
            (W += `
return mapResponse(${N}error,set${Q.mapResponseContext})}`);
        let G = (Z) => (typeof Z === 'function' ? Z : Z.fn);
        return Function(
            'inject',
            `"use strict";
` + W,
        )({
            mapResponse: $['~adapter'].handler.mapResponse,
            ERROR_CODE: A8,
            ElysiaCustomStatusResponse: g6,
            onError: $.event.error?.map(G),
            afterResponse: $.event.afterResponse?.map(G),
            trace: $.event.trace?.map(G),
            onMapResponse: $.event.mapResponse?.map(G),
            ELYSIA_TRACE: J ? x8 : void 0,
            ELYSIA_REQUEST_ID: J ? RW : void 0,
            ...Q.inject,
        });
    },
    m6 = ($, X, W) => {
        if (f$(X.headers) || X.status !== 200 || X.cookie)
            switch ((E8(X), $?.constructor?.name)) {
                case 'String':
                    return new Response($, X);
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), m6($.response, X, W);
                case 'ReadableStream':
                    if (
                        !X.headers['content-type']?.startsWith(
                            'text/event-stream',
                        )
                    )
                        X.headers['content-type'] =
                            'text/event-stream; charset=utf-8';
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, X)
                    );
                case void 0:
                    if (!$) return new Response('', X);
                    return new Response(JSON.stringify($), X);
                case 'Response':
                    return F8($, X, W);
                case 'Error':
                    return G0($, X);
                case 'Promise':
                    return $.then((Q) => m6(Q, X, W));
                case 'Function':
                    return m6($(), X, W);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString(), X);
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                case 'FormData':
                    return new Response($, X);
                default:
                    if ($ instanceof Response) return F8($, X, W);
                    if ($ instanceof Promise) return $.then((Q) => m6(Q, X));
                    if ($ instanceof Error) return G0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), m6($.response, X, W);
                    if (typeof $?.next === 'function') return Z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => m6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return m6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($, X);
            }
        if (
            $ instanceof Response &&
            !$.headers.has('content-length') &&
            $.headers.get('transfer-encoding') === 'chunked'
        )
            return Z0(D0($), w0($, X), W);
        if (typeof $?.next === 'function' || $ instanceof ReadableStream)
            return Z0($, X, W);
        return v1($, W);
    },
    h6 = ($, X, W) => {
        if ($ === void 0 || $ === null) return;
        if (f$(X.headers) || X.status !== 200 || X.cookie)
            switch ((E8(X), $?.constructor?.name)) {
                case 'String':
                    return new Response($, X);
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), h6($.response, X, W);
                case 'ReadableStream':
                    if (
                        !X.headers['content-type']?.startsWith(
                            'text/event-stream',
                        )
                    )
                        X.headers['content-type'] =
                            'text/event-stream; charset=utf-8';
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, X)
                    );
                case void 0:
                    if (!$) return;
                    return new Response(JSON.stringify($), X);
                case 'Response':
                    return F8($, X, W);
                case 'Promise':
                    return $.then((Q) => h6(Q, X));
                case 'Error':
                    return G0($, X);
                case 'Function':
                    return h6($(), X);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString(), X);
                case 'FormData':
                    return new Response($);
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                default:
                    if ($ instanceof Response) return F8($, X, W);
                    if ($ instanceof Promise) return $.then((Q) => h6(Q, X));
                    if ($ instanceof Error) return G0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), h6($.response, X, W);
                    if (typeof $?.next === 'function') return Z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => h6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return h6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($, X);
            }
        else
            switch ($?.constructor?.name) {
                case 'String':
                    return new Response($);
                case 'Array':
                case 'Object':
                    return (
                        (X.headers['content-type'] = 'application/json'),
                        new Response(JSON.stringify($), X)
                    );
                case 'ElysiaFile':
                    return i$($.value);
                case 'File':
                    return i$($, X);
                case 'Blob':
                    return i$($, X);
                case 'ElysiaCustomStatusResponse':
                    return (X.status = $.code), h6($.response, X, W);
                case 'ReadableStream':
                    return (
                        W?.signal?.addEventListener(
                            'abort',
                            {
                                handleEvent() {
                                    if (W?.signal && !W?.signal?.aborted)
                                        $.cancel();
                                },
                            },
                            { once: !0 },
                        ),
                        new Response($, {
                            headers: {
                                'Content-Type':
                                    'text/event-stream; charset=utf-8',
                            },
                        })
                    );
                case void 0:
                    if (!$) return new Response('');
                    return new Response(JSON.stringify($), {
                        headers: { 'content-type': 'application/json' },
                    });
                case 'Response':
                    if (
                        !$.headers.has('content-length') &&
                        $.headers.get('transfer-encoding') === 'chunked'
                    )
                        return Z0(D0($), w0($), W);
                    return $;
                case 'Promise':
                    return $.then((Q) => {
                        let Y = h6(Q, X);
                        if (Y !== void 0) return Y;
                    });
                case 'Error':
                    return G0($, X);
                case 'Function':
                    return v1($(), W);
                case 'Number':
                case 'Boolean':
                    return new Response($.toString());
                case 'Cookie':
                    if ($ instanceof f1) return new Response($.value, X);
                    return new Response($?.toString(), X);
                case 'FormData':
                    return new Response($);
                default:
                    if ($ instanceof Response) return $;
                    if ($ instanceof Promise) return $.then((Q) => h6(Q, X));
                    if ($ instanceof Error) return G0($, X);
                    if ($ instanceof g6)
                        return (X.status = $.code), h6($.response, X, W);
                    if (typeof $?.next === 'function') return Z0($, X, W);
                    if (typeof $?.then === 'function')
                        return $.then((Q) => h6(Q, X));
                    if (typeof $?.toResponse === 'function')
                        return h6($.toResponse(), X);
                    if ('charCodeAt' in $) {
                        let Q = $.charCodeAt(0);
                        if (Q === 123 || Q === 91) {
                            if (!X.headers['Content-Type'])
                                X.headers['Content-Type'] = 'application/json';
                            return new Response(JSON.stringify($), X);
                        }
                    }
                    return new Response($);
            }
    },
    v1 = ($, X) => {
        switch ($?.constructor?.name) {
            case 'String':
                return new Response($);
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify($), {
                    headers: { 'Content-Type': 'application/json' },
                });
            case 'ElysiaFile':
                return i$($.value);
            case 'File':
                return i$($);
            case 'Blob':
                return i$($);
            case 'ElysiaCustomStatusResponse':
                return m6($.response, { status: $.code, headers: {} });
            case 'ReadableStream':
                return (
                    X?.signal?.addEventListener(
                        'abort',
                        {
                            handleEvent() {
                                if (X?.signal && !X?.signal?.aborted)
                                    $.cancel();
                            },
                        },
                        { once: !0 },
                    ),
                    new Response($, {
                        headers: {
                            'Content-Type': 'text/event-stream; charset=utf-8',
                        },
                    })
                );
            case void 0:
                if (!$) return new Response('');
                return new Response(JSON.stringify($), {
                    headers: { 'content-type': 'application/json' },
                });
            case 'Response':
                if ($.headers.get('transfer-encoding') === 'chunked')
                    return Z0(D0($), w0($), X);
                return $;
            case 'Error':
                return G0($);
            case 'Promise':
                return $.then((W) => v1(W, X));
            case 'Function':
                return v1($(), X);
            case 'Number':
            case 'Boolean':
                return new Response($.toString());
            case 'FormData':
                return new Response($);
            default:
                if ($ instanceof Response) return $;
                if ($ instanceof Promise) return $.then((W) => v1(W, X));
                if ($ instanceof Error) return G0($);
                if ($ instanceof g6)
                    return m6($.response, { status: $.code, headers: {} });
                if (typeof $?.next === 'function') return Z0($, void 0, X);
                if (typeof $?.then === 'function')
                    return $.then((W) => m6(W, set));
                if (typeof $?.toResponse === 'function')
                    return v1($.toResponse());
                if ('charCodeAt' in $) {
                    let W = $.charCodeAt(0);
                    if (W === 123 || W === 91)
                        return new Response(JSON.stringify($), {
                            headers: { 'Content-Type': 'application/json' },
                        });
                }
                return new Response($);
        }
    },
    G0 = ($, X) =>
        new Response(
            JSON.stringify({
                name: $?.name,
                message: $?.message,
                cause: $?.cause,
            }),
            {
                status: X?.status !== 200 ? (X?.status ?? 500) : 500,
                headers: X?.headers,
            },
        ),
    yF = ($, X, W = {}) => {
        if (typeof $ === 'function') return;
        let Q = m6($, { headers: W });
        if (
            !X.parse?.length &&
            !X.transform?.length &&
            !X.beforeHandle?.length &&
            !X.afterHandle?.length
        )
            return Q.clone.bind(Q);
    },
    F8 = rZ({ mapResponse: m6, mapCompactResponse: v1 }),
    Z0 = DU({ mapResponse: m6, mapCompactResponse: v1 }),
    T1 = ($, X) => (X ? $ : ''),
    IZ = ($, X, W, Q = !1) => {
        let Y = '',
            J = $.setHeaders,
            U = !!$.event.trace?.length;
        if (U)
            Y += `const id=randomId()
`;
        let N = /[:*]/.test(X.path),
            M = `const u=request.url,s=u.indexOf('/',${($.config.handler?.standardHostname ?? !0) ? 11 : 7}),qi=u.indexOf('?', s + 1)
`;
        if (W.query) Y += M;
        let G = !W.path
            ? ''
            : !N
              ? `path:'${X.path}',`
              : 'get path(){' +
                (W.query ? '' : M) +
                `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
        if (
            ((Y +=
                T1('const c=', !Q) +
                '{request,store,' +
                T1('qi,', W.query) +
                T1('params:request.params,', N) +
                G +
                T1('url:request.url,', U || W.url || W.query) +
                'redirect,error:status,status,set:{headers:' +
                (f$(J)
                    ? 'Object.assign({},app.setHeaders)'
                    : 'Object.create(null)') +
                ',status:200}'),
            W.server)
        )
            Y += ',get server(){return app.getServer()}';
        if (U) Y += ',[ELYSIA_REQUEST_ID]:id';
        {
            let Z = '';
            for (let B of Object.keys($.singleton.decorator))
                Z += `,'${B}':decorator['${B}']`;
            Y += Z;
        }
        return (
            (Y += `}
`),
            Y
        );
    },
    aJ = ($, X) => {
        let W = !!$.event.trace?.length,
            Q = !!$.extender.higherOrderFunctions.length,
            Y = CW(X.hooks, $.inference);
        Y = CW({ handler: X.handler }, Y);
        let J =
            'const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse,' +
            T1('randomId=data.randomId,', W) +
            T1('ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,', W) +
            T1('ELYSIA_TRACE=data.ELYSIA_TRACE,', W) +
            T1('trace=data.trace,', W) +
            T1('hoc=data.hoc,', Q) +
            `status=data.status
`;
        if ($.event.request?.length)
            J += `const onRequest=app.event.request.map(x=>x.fn)
`;
        if (
            ((J += `${$.event.request?.find(G6) ? 'async' : ''} function map(request){`),
            W || Y.query || $.event.request?.length)
        )
            (J += IZ($, X, Y)), (J += $w($)), (J += 'return handler(c)}');
        else J += `return handler(${IZ($, X, Y, !0)})}`;
        return (
            (J += Xw($)),
            Function(
                'data',
                J,
            )({
                app: $,
                handler: X.compile?.() ?? X.composed,
                redirect: zU,
                status: P8,
                hoc: $.extender.higherOrderFunctions.map((U) => U.fn),
                store: $.store,
                decorator: $.decorator,
                route: X.path,
                randomId: W ? R8 : void 0,
                ELYSIA_TRACE: W ? x8 : void 0,
                ELYSIA_REQUEST_ID: W ? RW : void 0,
                trace: W ? $.event.trace?.map((U) => U?.fn ?? U) : void 0,
                mapEarlyResponse: h6,
            })
        );
    },
    hF = ($, X, W = {}) => {
        if (typeof $ === 'function' || $ instanceof Blob) return;
        if (typeof $ === 'object' && $?.toString() === '[object HTMLBundle]')
            return () => $;
        let Q = m6($, { headers: W });
        if (
            !X.parse?.length &&
            !X.transform?.length &&
            !X.beforeHandle?.length &&
            !X.afterHandle?.length
        ) {
            if (Q instanceof Promise)
                return Q.then((Y) => {
                    if (!Y) return;
                    if (!Y.headers.has('content-type'))
                        Y.headers.append('content-type', 'text/plain');
                    return Y.clone();
                });
            if (!Q.headers.has('content-type'))
                Q.headers.append('content-type', 'text/plain');
            return Q.clone.bind(Q);
        }
    },
    CZ = {
        open($) {
            $.data.open?.($);
        },
        message($, X) {
            $.data.message?.($, X);
        },
        drain($) {
            $.data.drain?.($);
        },
        close($, X, W) {
            $.data.close?.($, X, W);
        },
    };
class LW {
    raw;
    data;
    body;
    validator;
    ['~types'];
    get id() {
        return this.data.id;
    }
    constructor($, X, W = void 0) {
        (this.raw = $),
            (this.data = X),
            (this.body = W),
            (this.validator = $.data?.validator),
            (this.sendText = $.sendText.bind($)),
            (this.sendBinary = $.sendBinary.bind($)),
            (this.close = $.close.bind($)),
            (this.terminate = $.terminate.bind($)),
            (this.publishText = $.publishText.bind($)),
            (this.publishBinary = $.publishBinary.bind($)),
            (this.subscribe = $.subscribe.bind($)),
            (this.unsubscribe = $.unsubscribe.bind($)),
            (this.isSubscribed = $.isSubscribed.bind($)),
            (this.cork = $.cork.bind($)),
            (this.remoteAddress = $.remoteAddress),
            (this.binaryType = $.binaryType),
            (this.data = $.data),
            (this.send = this.send.bind(this)),
            (this.ping = this.ping.bind(this)),
            (this.pong = this.pong.bind(this)),
            (this.publish = this.publish.bind(this));
    }
    send($, X) {
        if (Buffer.isBuffer($)) return this.raw.send($, X);
        if (this.validator?.Check($) === !1)
            return this.raw.send(new V$('message', this.validator, $).message);
        if (typeof $ === 'object') $ = JSON.stringify($);
        return this.raw.send($, X);
    }
    ping($) {
        if (Buffer.isBuffer($)) return this.raw.ping($);
        if (this.validator?.Check($) === !1)
            return this.raw.send(new V$('message', this.validator, $).message);
        if (typeof $ === 'object') $ = JSON.stringify($);
        return this.raw.ping($);
    }
    pong($) {
        if (Buffer.isBuffer($)) return this.raw.pong($);
        if (this.validator?.Check($) === !1)
            return this.raw.send(new V$('message', this.validator, $).message);
        if (typeof $ === 'object') $ = JSON.stringify($);
        return this.raw.pong($);
    }
    publish($, X, W) {
        if (Buffer.isBuffer(X)) return this.raw.publish($, X, W);
        if (this.validator?.Check(X) === !1)
            return this.raw.send(new V$('message', this.validator, X).message);
        if (typeof X === 'object') X = JSON.stringify(X);
        return this.raw.publish($, X, W);
    }
    sendText;
    sendBinary;
    close;
    terminate;
    publishText;
    publishBinary;
    subscribe;
    unsubscribe;
    isSubscribed;
    cork;
    remoteAddress;
    binaryType;
    get readyState() {
        return this.raw.readyState;
    }
}
var mF = ($) => {
        let X = typeof $ === 'function' ? [$] : $;
        return async function W(Q, Y) {
            if (typeof Y === 'string') {
                let J = Y?.charCodeAt(0);
                if (J === 34 || J === 47 || J === 91 || J === 123)
                    try {
                        Y = JSON.parse(Y);
                    } catch {}
                else if (GU(Y)) Y = +Y;
                else if (Y === 'true') Y = !0;
                else if (Y === 'false') Y = !1;
                else if (Y === 'null') Y = null;
            }
            if (X)
                for (let J = 0; J < X.length; J++) {
                    let U = X[J](Q, Y);
                    if (U instanceof Promise) U = await U;
                    if (U !== void 0) return U;
                }
            return Y;
        };
    },
    cF = ($) => {
        let X = (W, Q) => {
            if (Q instanceof Promise) return Q.then((U) => X(W, U));
            if (Buffer.isBuffer(Q)) return W.send(Q.toString());
            if (Q === void 0) return;
            let Y = (U) => {
                if ($?.Check(U) === !1)
                    return W.send(new V$('message', $, U).message);
                if (typeof U === 'object') return W.send(JSON.stringify(U));
                W.send(U);
            };
            if (typeof Q?.next !== 'function') return void Y(Q);
            let J = Q.next();
            if (J instanceof Promise)
                return (async () => {
                    let U = await J;
                    if ($?.Check(U) === !1)
                        return W.send(new V$('message', $, U).message);
                    if ((Y(U.value), !U.done)) for await (let N of Q) Y(N);
                })();
            if ((Y(J.value), !J.done)) for (let U of Q) Y(U);
        };
        return X;
    },
    uF = /:.+?\?(?=\/|$)/,
    Yw = ($) => {
        let X = uF.exec($);
        if (!X) return [$];
        let W = [],
            Q = $.slice(0, X.index),
            Y = X[0].slice(0, -1),
            J = $.slice(X.index + X[0].length);
        W.push(Q.slice(0, -1)), W.push(Q + Y);
        for (let U of Yw(J)) {
            if (!U) continue;
            if (!U.startsWith('/:')) W.push(Q.slice(0, -1) + U);
            W.push(Q + Y + U);
        }
        return W;
    },
    Qw = {
        GET: !0,
        HEAD: !0,
        OPTIONS: !0,
        DELETE: !0,
        PATCH: !0,
        POST: !0,
        PUT: !0,
    },
    sJ = ($) => {
        if (!$.config.aot || !$.config.systemRouter) return;
        let X = {},
            W = (Y, J) => {
                if (X[Y.path]) {
                    if (!X[Y.path][Y.method]) X[Y.path][Y.method] = J;
                } else X[Y.path] = { [Y.method]: J };
            },
            Q = $.routeTree;
        for (let Y of $.router.history) {
            if (typeof Y.handler !== 'function') continue;
            let J = Y.method;
            if (
                (J === 'GET' && `WS_${Y.path}` in Q) ||
                J === 'WS' ||
                Y.path.charCodeAt(Y.path.length - 1) === 42 ||
                !(J in Qw)
            )
                continue;
            if (J === 'ALL') {
                if (!(`WS_${Y.path}` in Q))
                    X[Y.path] = Y.hooks?.config?.mount
                        ? Y.hooks.trace ||
                          $.event.trace ||
                          $.extender.higherOrderFunctions
                            ? aJ($, Y)
                            : Y.hooks.mount || Y.handler
                        : Y.handler;
                continue;
            }
            let U,
                N = $.config.precompile
                    ? aJ($, Y)
                    : (M) => {
                          if (U) return U(M);
                          return (U = aJ($, Y))(M);
                      };
            for (let M of Yw(Y.path)) W({ method: J, path: M }, N);
        }
        return X;
    },
    FX = ($, X) => {
        if (!X) return $;
        for (let W of Object.keys(X)) {
            if ($[W] === X[W]) continue;
            if (!$[W]) {
                $[W] = X[W];
                continue;
            }
            if ($[W] && X[W]) {
                if (typeof $[W] === 'function' || $[W] instanceof Response) {
                    $[W] = X[W];
                    continue;
                }
                $[W] = { ...$[W], ...X[W] };
            }
        }
        return $;
    },
    dF = {
        ...QU,
        name: 'bun',
        handler: {
            mapResponse: m6,
            mapEarlyResponse: h6,
            mapCompactResponse: v1,
            createStaticHandler: yF,
            createNativeStaticHandler: hF,
        },
        composeHandler: {
            ...QU.composeHandler,
            headers: H8
                ? `c.headers=c.request.headers.toJSON()
`
                : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`,
        },
        listen($) {
            return (X, W) => {
                if (typeof Bun === 'undefined')
                    throw new Error(
                        '.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch',
                    );
                if (($.compile(), typeof X === 'string')) {
                    if (!GU(X)) throw new Error('Port must be a numeric value');
                    X = parseInt(X);
                }
                let Q = (J, { withAsync: U = !1 } = {}) => {
                        let N = {},
                            M = [];
                        for (let [G, Z] of Object.entries(J))
                            if (hZ) {
                                if (!Z) continue;
                                for (let [B, O] of Object.entries(Z)) {
                                    if (!O || !(B in Qw)) continue;
                                    if (O instanceof Promise) {
                                        if (U) {
                                            if (!N[G]) N[G] = {};
                                            M.push(
                                                O.then((w) => {
                                                    if (w instanceof Response)
                                                        N[G][B] = w;
                                                    if (
                                                        typeof w === 'object' &&
                                                        w?.toString() ===
                                                            '[object HTMLBundle]'
                                                    )
                                                        N[G][B] = w;
                                                }),
                                            );
                                        }
                                        continue;
                                    }
                                    if (
                                        !(O instanceof Response) &&
                                        !(
                                            typeof O === 'object' &&
                                            O?.toString() ===
                                                '[object HTMLBundle]'
                                        )
                                    )
                                        continue;
                                    if (!N[G]) N[G] = {};
                                    N[G][B] = O;
                                }
                            } else {
                                if (!Z) continue;
                                if (Z instanceof Promise) {
                                    if (U) {
                                        if (!N[G]) N[G] = {};
                                        M.push(
                                            Z.then((B) => {
                                                if (B instanceof Response)
                                                    N[G] = B;
                                            }),
                                        );
                                    }
                                    continue;
                                }
                                if (!(Z instanceof Response)) continue;
                                N[G] = Z;
                            }
                        if (U) return Promise.all(M).then(() => N);
                        return N;
                    },
                    Y =
                        typeof X === 'object'
                            ? {
                                  development: !IW,
                                  reusePort: !0,
                                  ...($.config.serve || {}),
                                  ...(X || {}),
                                  routes: FX(
                                      FX(Q($.router.response), sJ($)),
                                      $.config.serve?.routes,
                                  ),
                                  websocket: {
                                      ...($.config.websocket || {}),
                                      ...(CZ || {}),
                                  },
                                  fetch: $.fetch,
                              }
                            : {
                                  development: !IW,
                                  reusePort: !0,
                                  ...($.config.serve || {}),
                                  routes: FX(
                                      FX(Q($.router.response), sJ($)),
                                      $.config.serve?.routes,
                                  ),
                                  websocket: {
                                      ...($.config.websocket || {}),
                                      ...(CZ || {}),
                                  },
                                  port: X,
                                  fetch: $.fetch,
                              };
                if ((($.server = Bun.serve(Y)), $.event.start))
                    for (let J = 0; J < $.event.start.length; J++)
                        $.event.start[J].fn($);
                if (W) W($.server);
                process.on('beforeExit', () => {
                    if ($.server) {
                        if (
                            ($.server.stop?.(), ($.server = null), $.event.stop)
                        )
                            for (let J = 0; J < $.event.stop.length; J++)
                                $.event.stop[J].fn($);
                    }
                }),
                    $.promisedModules.then(async () => {
                        $.server?.reload({
                            ...Y,
                            fetch: $.fetch,
                            routes: FX(
                                FX(
                                    await Q($.router.response, {
                                        withAsync: !0,
                                    }),
                                    sJ($),
                                ),
                                $.config.serve?.routes,
                            ),
                        }),
                            Bun?.gc(!1);
                    });
            };
        },
        ws($, X, W) {
            let { parse: Q, body: Y, response: J, ...U } = W,
                N = P6(Y, {
                    modules: $.definitions.typebox,
                    models: $.definitions.type,
                    normalize: $.config.normalize,
                }),
                M = P6(J, {
                    modules: $.definitions.typebox,
                    models: $.definitions.type,
                    normalize: $.config.normalize,
                });
            $.route(
                'WS',
                X,
                async (G) => {
                    let Z = $.getServer(),
                        {
                            set: B,
                            path: O,
                            qi: w,
                            headers: z,
                            query: H,
                            params: P,
                        } = G;
                    if (((G.validator = M), W.upgrade)) {
                        if (typeof W.upgrade === 'function') {
                            let y = W.upgrade(G);
                            if (y instanceof Promise) await y;
                        } else if (W.upgrade)
                            Object.assign(B.headers, W.upgrade);
                    }
                    if (B.cookie && f$(B.cookie)) {
                        let y = lZ(B.cookie);
                        if (y) B.headers['set-cookie'] = y;
                    }
                    if (
                        B.headers['set-cookie'] &&
                        Array.isArray(B.headers['set-cookie'])
                    )
                        B.headers = oZ(
                            new Headers(B.headers),
                            B.headers['set-cookie'],
                        );
                    let E = cF(M),
                        j = mF(Q),
                        V;
                    if (typeof W.beforeHandle === 'function') {
                        let y = W.beforeHandle(G);
                        if (y instanceof Promise) await y;
                    }
                    let i = [
                            ...(Array.isArray(W.error) ? W.error : [W.error]),
                            ...($.event.error ?? []).map((y) =>
                                typeof y === 'function' ? y : y.fn,
                            ),
                        ].filter((y) => y),
                        $$ = !i.length
                            ? () => {}
                            : async (y, n) => {
                                  for (let k of i) {
                                      let b = k(Object.assign(G, { error: n }));
                                      if (b instanceof Promise) b = await b;
                                      if ((await E(y, b), b)) break;
                                  }
                              };
                    if (
                        Z?.upgrade(G.request, {
                            headers: f$(B.headers) ? B.headers : void 0,
                            data: {
                                ...G,
                                get id() {
                                    if (V) return V;
                                    return (V = R8());
                                },
                                validator: M,
                                ping(y) {
                                    W.ping?.(y);
                                },
                                pong(y) {
                                    W.pong?.(y);
                                },
                                open(y) {
                                    try {
                                        E(y, W.open?.(new LW(y, G)));
                                    } catch (n) {
                                        $$(y, n);
                                    }
                                },
                                message: async (y, n) => {
                                    let k = await j(y, n);
                                    if (N?.Check(k) === !1)
                                        return void y.send(
                                            new V$('message', N, k).message,
                                        );
                                    try {
                                        E(y, W.message?.(new LW(y, G, k), k));
                                    } catch (b) {
                                        $$(y, b);
                                    }
                                },
                                drain(y) {
                                    try {
                                        E(y, W.drain?.(new LW(y, G)));
                                    } catch (n) {
                                        $$(y, n);
                                    }
                                },
                                close(y, n, k) {
                                    try {
                                        E(y, W.close?.(new LW(y, G), n, k));
                                    } catch (b) {
                                        $$(y, b);
                                    }
                                },
                            },
                        })
                    )
                        return;
                    return (B.status = 400), 'Expected a websocket connection';
                },
                { ...U, websocket: W },
            );
        },
    },
    RZ = VX
        ? Bun.env
        : typeof process !== 'undefined' && process?.env
          ? process.env
          : {},
    eJ = ($, X) => {
        for (let [W, Q] of Object.entries($.schema.properties))
            X[W] ??= Q.default;
    },
    VZ = ($) => {
        let { mapResponse: X, mapEarlyResponse: W } = $['~adapter'].handler;
        return async (Q) => {
            let Y = Q.url,
                J = Y.indexOf('/', 11),
                U = Y.indexOf('?', J + 1),
                N = U === -1 ? Y.substring(J) : Y.substring(J, U),
                M = { cookie: {}, status: 200, headers: {} },
                G = Object.assign({}, $.singleton.decorator, {
                    set: M,
                    store: $.singleton.store,
                    request: Q,
                    path: N,
                    qi: U,
                    error: P8,
                    status: P8,
                    redirect: zU,
                });
            try {
                if ($.event.request)
                    for (let k = 0; k < $.event.request.length; k++) {
                        let b = $.event.request[k].fn,
                            T = b(G);
                        if (T instanceof Promise) T = await T;
                        if (((T = W(T, M)), T)) return (G.response = T);
                    }
                let Z =
                        Q.method === 'GET' &&
                        Q.headers.get('upgrade')?.toLowerCase() === 'websocket'
                            ? 'WS'
                            : Q.method,
                    B =
                        $.router.dynamic.find(Q.method, N) ??
                        $.router.dynamic.find(Z, N) ??
                        $.router.dynamic.find('ALL', N);
                if (!B) throw new ZU();
                let {
                        handle: O,
                        hooks: w,
                        validator: z,
                        content: H,
                        route: P,
                    } = B.store,
                    E;
                if (Q.method !== 'GET' && Q.method !== 'HEAD')
                    if (H)
                        switch (H) {
                            case 'application/json':
                                E = await Q.json();
                                break;
                            case 'text/plain':
                                E = await Q.text();
                                break;
                            case 'application/x-www-form-urlencoded':
                                E = D8(await Q.text());
                                break;
                            case 'application/octet-stream':
                                E = await Q.arrayBuffer();
                                break;
                            case 'multipart/form-data':
                                E = {};
                                let k = await Q.formData();
                                for (let b of k.keys()) {
                                    if (E[b]) continue;
                                    let T = k.getAll(b);
                                    if (T.length === 1) E[b] = T[0];
                                    else E[b] = T;
                                }
                                break;
                        }
                    else {
                        let k = Q.headers.get('content-type');
                        if (k) {
                            let b = k.indexOf(';');
                            if (b !== -1) k = k.slice(0, b);
                            if (((G.contentType = k), w.parse))
                                for (let T = 0; T < w.parse.length; T++) {
                                    let o = w.parse[T].fn,
                                        e = o(G, k);
                                    if (e instanceof Promise) e = await e;
                                    if (e) {
                                        E = e;
                                        break;
                                    }
                                }
                            if ((delete G.contentType, E === void 0))
                                switch (k) {
                                    case 'application/json':
                                        E = await Q.json();
                                        break;
                                    case 'text/plain':
                                        E = await Q.text();
                                        break;
                                    case 'application/x-www-form-urlencoded':
                                        E = D8(await Q.text());
                                        break;
                                    case 'application/octet-stream':
                                        E = await Q.arrayBuffer();
                                        break;
                                    case 'multipart/form-data':
                                        E = {};
                                        let T = await Q.formData();
                                        for (let o of T.keys()) {
                                            if (E[o]) continue;
                                            let e = T.getAll(o);
                                            if (e.length === 1) E[o] = e[0];
                                            else E[o] = e;
                                        }
                                        break;
                                }
                        }
                    }
                (G.route = P),
                    (G.body = E),
                    (G.params = B?.params || void 0),
                    (G.query = U === -1 ? {} : D8(Y.substring(U + 1))),
                    (G.headers = {});
                for (let [k, b] of Q.headers.entries()) G.headers[k] = b;
                let j = Object.assign({}, $.config?.cookie, z?.cookie?.config),
                    V = Q.headers.get('cookie');
                G.cookie = await pZ(
                    G.set,
                    V,
                    j
                        ? {
                              secrets:
                                  j.secrets !== void 0
                                      ? typeof j.secrets === 'string'
                                          ? j.secrets
                                          : j.secrets.join(',')
                                      : void 0,
                              sign:
                                  j.sign === !0
                                      ? !0
                                      : j.sign !== void 0
                                        ? typeof j.sign === 'string'
                                            ? j.sign
                                            : j.sign.join(',')
                                        : void 0,
                          }
                        : void 0,
                );
                let i = z?.createHeaders?.();
                if (i) eJ(i, G.headers);
                let $$ = z?.createParams?.();
                if ($$) eJ($$, G.params);
                let y = z?.createQuery?.();
                if (y) eJ(y, G.query);
                if (w.transform)
                    for (let k = 0; k < w.transform.length; k++) {
                        let b = w.transform[k],
                            T = b.fn(G);
                        if (T instanceof Promise) T = await T;
                        if (T instanceof g6) {
                            let o = W(T, G.set);
                            if (o) return (G.response = o);
                        }
                        if (b.subType === 'derive') Object.assign(G, T);
                    }
                if (z) {
                    if (i) {
                        let k = structuredClone(G.headers);
                        for (let [b, T] of Q.headers) k[b] = T;
                        if (z.headers.Check(k) === !1)
                            throw new V$('header', z.headers, k);
                    } else if (z.headers?.Decode)
                        G.headers = z.headers.Decode(G.headers);
                    if ($$?.Check(G.params) === !1)
                        throw new V$('params', z.params, G.params);
                    else if (z.params?.Decode)
                        G.params = z.params.Decode(G.params);
                    if (y?.Check(G.query) === !1)
                        throw new V$('query', z.query, G.query);
                    else if (z.query?.Decode) G.query = z.query.Decode(G.query);
                    if (z.createCookie?.()) {
                        let k = {};
                        for (let [b, T] of Object.entries(G.cookie))
                            k[b] = T.value;
                        if (z.cookie.Check(k) === !1)
                            throw new V$('cookie', z.cookie, k);
                        else if (z.cookie?.Decode) k = z.cookie.Decode(k);
                    }
                    if (z.createBody?.()?.Check(E) === !1)
                        throw new V$('body', z.body, E);
                    else if (z.body?.Decode) G.body = z.body.Decode(E);
                }
                if (w.beforeHandle)
                    for (let k = 0; k < w.beforeHandle.length; k++) {
                        let b = w.beforeHandle[k],
                            T = b.fn(G);
                        if (T instanceof Promise) T = await T;
                        if (T instanceof g6) {
                            let o = W(T, G.set);
                            if (o) return (G.response = o);
                        }
                        if (b.subType === 'resolve') {
                            Object.assign(G, T);
                            continue;
                        }
                        if (T !== void 0) {
                            if (((G.response = T), w.afterHandle))
                                for (let e = 0; e < w.afterHandle.length; e++) {
                                    let W$ = w.afterHandle[e].fn(G);
                                    if (W$ instanceof Promise) W$ = await W$;
                                    if (W$) T = W$;
                                }
                            let o = W(T, G.set);
                            if (o) return (G.response = o);
                        }
                    }
                let n = typeof O === 'function' ? O(G) : O;
                if (n instanceof Promise) n = await n;
                if (w.afterHandle)
                    if (!w.afterHandle.length) {
                        let k =
                                n instanceof g6
                                    ? n.code
                                    : M.status
                                      ? typeof M.status === 'string'
                                          ? C8[M.status]
                                          : M.status
                                      : 200,
                            b = z?.createResponse?.()?.[k];
                        if (b?.Check(n) === !1) throw new V$('response', b, n);
                        else if (b?.Decode) n = b.Decode(n);
                    } else {
                        G.response = n;
                        for (let k = 0; k < w.afterHandle.length; k++) {
                            let b = w.afterHandle[k].fn(G);
                            if (b instanceof Promise) b = await b;
                            let T = W(b, G.set);
                            if (T !== void 0) {
                                let o = z?.response?.[T.status];
                                if (o?.Check(T) === !1)
                                    throw new V$('response', o, T);
                                else if (o?.Decode) n = o.Decode(n);
                                return (G.response = T);
                            }
                        }
                    }
                if (G.set.cookie && j?.sign) {
                    let k = !j.secrets
                        ? void 0
                        : typeof j.secrets === 'string'
                          ? j.secrets
                          : j.secrets[0];
                    if (j.sign === !0)
                        for (let [b, T] of Object.entries(G.set.cookie))
                            G.set.cookie[b].value = await q8(
                                T.value,
                                '${secret}',
                            );
                    else {
                        let b = z?.cookie?.schema?.properties;
                        for (let T of j.sign) {
                            if (!(T in b)) continue;
                            if (G.set.cookie[T]?.value)
                                G.set.cookie[T].value = await q8(
                                    G.set.cookie[T].value,
                                    k,
                                );
                        }
                    }
                }
                return X((G.response = n), G.set);
            } catch (Z) {
                let B = Z instanceof nY && Z.error ? Z.error : Z;
                return $.handleError(G, B);
            } finally {
                if ($.event.afterResponse)
                    for (let Z of $.event.afterResponse) await Z.fn(G);
            }
        };
    },
    iF = ($) => {
        let { mapResponse: X } = $['~adapter'].handler;
        return async (W, Q) => {
            let Y = Object.assign(W, { error: Q, code: Q.code });
            if (((Y.set = W.set), $.event.error))
                for (let J = 0; J < $.event.error.length; J++) {
                    let U = $.event.error[J].fn(Y);
                    if (U instanceof Promise) U = await U;
                    if (U !== void 0 && U !== null)
                        return (W.response = X(U, W.set));
                }
            return new Response(
                typeof Q.cause === 'string' ? Q.cause : Q.message,
                { headers: W.set.headers, status: Q.status ?? 500 },
            );
        };
    };
class V4 {
    config;
    server = null;
    dependencies = {};
    '~Prefix' = '';
    '~Singleton' = null;
    '~Definitions' = null;
    '~Metadata' = null;
    '~Ephemeral' = null;
    '~Volatile' = null;
    '~Routes' = null;
    singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
    get store() {
        return this.singleton.store;
    }
    get decorator() {
        return this.singleton.decorator;
    }
    definitions = { typebox: c.Module({}), type: {}, error: {} };
    extender = { macros: [], higherOrderFunctions: [] };
    validator = {
        global: null,
        scoped: null,
        local: null,
        getCandidate() {
            if (!this.global && !this.scoped && !this.local)
                return {
                    body: void 0,
                    headers: void 0,
                    params: void 0,
                    query: void 0,
                    cookie: void 0,
                    response: void 0,
                };
            return qW(qW(this.global, this.scoped), this.local);
        },
    };
    standaloneValidator = { global: null, scoped: null, local: null };
    event = {};
    telemetry;
    router = {
        '~http': void 0,
        get http() {
            if (!this['~http']) this['~http'] = new RX({ lazy: !0 });
            return this['~http'];
        },
        '~dynamic': void 0,
        get dynamic() {
            if (!this['~dynamic']) this['~dynamic'] = new RX();
            return this['~dynamic'];
        },
        static: {},
        response: {},
        history: [],
    };
    routeTree = {};
    get routes() {
        return this.router.history;
    }
    getGlobalRoutes() {
        return this.router.history;
    }
    getGlobalDefinitions() {
        return this.definitions;
    }
    inference = {
        body: !1,
        cookie: !1,
        headers: !1,
        query: !1,
        set: !1,
        server: !1,
        path: !1,
        route: !1,
        url: !1,
    };
    getServer() {
        return this.server;
    }
    getParent() {
        return null;
    }
    '~parser' = {};
    _promisedModules;
    get promisedModules() {
        if (!this._promisedModules)
            this._promisedModules = new yZ(console.error, () => {});
        return this._promisedModules;
    }
    constructor($ = {}) {
        if ($.tags)
            if (!$.detail) $.detail = { tags: $.tags };
            else $.detail.tags = $.tags;
        if (
            ((this.config = {
                prefix: '',
                aot: RZ.ELYSIA_AOT !== 'false',
                nativeStaticResponse: !0,
                systemRouter: !0,
                encodeSchema: !0,
                normalize: !0,
                ...$,
                cookie: { path: '/', ...$?.cookie },
                experimental: $?.experimental ?? {},
                seed: $?.seed === void 0 ? '' : $?.seed,
            }),
            (this['~adapter'] =
                $.adapter ?? (typeof Bun !== 'undefined' ? dF : QU)),
            $?.analytic && ($?.name || $?.seed !== void 0))
        )
            this.telemetry = { stack: new Error().stack };
    }
    '~adapter';
    env($, X = RZ) {
        if (
            P6($, {
                modules: this.definitions.typebox,
                dynamic: !0,
                additionalProperties: !0,
                coerce: !0,
                sanitize: () => this.config.sanitize,
            }).Check(X) === !1
        ) {
            let W = new V$('env', $, X);
            throw new Error(
                W.all
                    .map((Q) => Q.summary)
                    .join(`
`),
            );
        }
        return this;
    }
    wrap($) {
        return (
            this.extender.higherOrderFunctions.push({
                checksum: IX(
                    JSON.stringify({
                        name: this.config.name,
                        seed: this.config.seed,
                        content: $.toString(),
                    }),
                ),
                fn: $,
            }),
            this
        );
    }
    applyMacro($) {
        if (this.extender.macros.length) {
            let X = NF({ globalHook: this.event, localHook: $ }),
                W = {
                    events: { global: this.event, local: $ },
                    get onParse() {
                        return X('parse');
                    },
                    get onTransform() {
                        return X('transform');
                    },
                    get onBeforeHandle() {
                        return X('beforeHandle');
                    },
                    get onAfterHandle() {
                        return X('afterHandle');
                    },
                    get mapResponse() {
                        return X('mapResponse');
                    },
                    get onAfterResponse() {
                        return X('afterResponse');
                    },
                    get onError() {
                        return X('error');
                    },
                };
            for (let Q of this.extender.macros) UF(Q.fn(W), $, X);
        }
    }
    get models() {
        let $ = {};
        for (let X of Object.keys(this.definitions.type))
            $[X] = P6(this.definitions.typebox.Import(X));
        return ($.modules = this.definitions.typebox), $;
    }
    add($, X, W, Q, Y, J) {
        let U = Y?.skipPrefix ?? !1,
            N = Y?.allowMeta ?? !1;
        if (((Q ??= {}), J === void 0)) {
            if (((J = []), this.standaloneValidator.local))
                J = J.concat(this.standaloneValidator.local);
            if (this.standaloneValidator.scoped)
                J = J.concat(this.standaloneValidator.scoped);
            if (this.standaloneValidator.global)
                J = J.concat(this.standaloneValidator.global);
        }
        if (X !== '' && X.charCodeAt(0) !== 47) X = '/' + X;
        if (this.config.prefix && !U) X = this.config.prefix + X;
        if (Q?.type)
            switch (Q.type) {
                case 'text':
                    Q.type = 'text/plain';
                    break;
                case 'json':
                    Q.type = 'application/json';
                    break;
                case 'formdata':
                    Q.type = 'multipart/form-data';
                    break;
                case 'urlencoded':
                    Q.type = 'application/x-www-form-urlencoded';
                    break;
                case 'arrayBuffer':
                    Q.type = 'application/octet-stream';
                    break;
                default:
                    break;
            }
        let M = this.validator.getCandidate(),
            G = {
                body: Q?.body ?? M?.body,
                headers: Q?.headers ?? M?.headers,
                params: Q?.params ?? M?.params,
                query: Q?.query ?? M?.query,
                cookie: Q?.cookie ?? M?.cookie,
                response: Q?.response ?? M?.response,
            },
            Z =
                this.config.precompile === !0 ||
                (typeof this.config.precompile === 'object' &&
                    this.config.precompile.compose === !0),
            B = () => {
                let b = this.definitions.type,
                    T = !this.config.aot,
                    o = this.config.normalize,
                    e = this.definitions.typebox,
                    W$ = () => this.config.sanitize,
                    W4 = () => {
                        if (G.cookie || J.find((A$) => A$.cookie))
                            return eZ({
                                modules: e,
                                validator: G.cookie,
                                defaultConfig: this.config.cookie,
                                config: G.cookie?.config ?? {},
                                dynamic: T,
                                models: b,
                                validators: J.map((A$) => A$.cookie),
                                sanitize: W$,
                            });
                    };
                return Z
                    ? {
                          body: P6(G.body, {
                              modules: e,
                              dynamic: T,
                              models: b,
                              normalize: o,
                              additionalCoerce: UU(),
                              validators: J.map((A$) => A$.body),
                              sanitize: W$,
                          }),
                          headers: P6(G.headers, {
                              modules: e,
                              dynamic: T,
                              models: b,
                              additionalProperties: !0,
                              coerce: !0,
                              additionalCoerce: k0(),
                              validators: J.map((A$) => A$.headers),
                              sanitize: W$,
                          }),
                          params: P6(G.params, {
                              modules: e,
                              dynamic: T,
                              models: b,
                              coerce: !0,
                              additionalCoerce: k0(),
                              validators: J.map((A$) => A$.params),
                              sanitize: W$,
                          }),
                          query: P6(G.query, {
                              modules: e,
                              dynamic: T,
                              models: b,
                              normalize: o,
                              coerce: !0,
                              additionalCoerce: k0(),
                              validators: J.map((A$) => A$.query),
                              sanitize: W$,
                          }),
                          cookie: W4(),
                          response: FZ(G.response, {
                              modules: e,
                              dynamic: T,
                              models: b,
                              normalize: o,
                              validators: J.map((A$) => A$.response),
                              sanitize: W$,
                          }),
                      }
                    : {
                          createBody() {
                              if (this.body) return this.body;
                              return (this.body = P6(G.body, {
                                  modules: e,
                                  dynamic: T,
                                  models: b,
                                  normalize: o,
                                  additionalCoerce: UU(),
                                  validators: J.map((A$) => A$.body),
                                  sanitize: W$,
                              }));
                          },
                          createHeaders() {
                              if (this.headers) return this.headers;
                              return (this.headers = P6(G.headers, {
                                  modules: e,
                                  dynamic: T,
                                  models: b,
                                  additionalProperties: !o,
                                  coerce: !0,
                                  additionalCoerce: k0(),
                                  validators: J.map((A$) => A$.headers),
                                  sanitize: W$,
                              }));
                          },
                          createParams() {
                              if (this.params) return this.params;
                              return (this.params = P6(G.params, {
                                  modules: e,
                                  dynamic: T,
                                  models: b,
                                  coerce: !0,
                                  additionalCoerce: k0(),
                                  validators: J.map((A$) => A$.params),
                                  sanitize: W$,
                              }));
                          },
                          createQuery() {
                              if (this.query) return this.query;
                              return (this.query = P6(G.query, {
                                  modules: e,
                                  dynamic: T,
                                  models: b,
                                  coerce: !0,
                                  additionalCoerce: k0(),
                                  validators: J.map((A$) => A$.query),
                                  sanitize: W$,
                              }));
                          },
                          createCookie() {
                              if (this.cookie) return this.cookie;
                              return (this.cookie = W4());
                          },
                          createResponse() {
                              if (this.response) return this.response;
                              return (this.response = FZ(G.response, {
                                  modules: e,
                                  dynamic: T,
                                  models: b,
                                  normalize: o,
                                  validators: J.map((A$) => A$.response),
                                  sanitize: W$,
                              }));
                          },
                      };
            };
        if (
            M.body ||
            M.cookie ||
            M.headers ||
            M.params ||
            M.query ||
            M.response
        )
            Q = x1(Q, M);
        if (Q.tags)
            if (!Q.detail) Q.detail = { tags: Q.tags };
            else Q.detail.tags = Q.tags;
        if (f$(this.config.detail))
            Q.detail = t6(Object.assign({}, this.config.detail), Q.detail);
        this.applyMacro(Q);
        let O = f$(this.event) ? x1(this.event, wZ(Q)) : WF(wZ(Q));
        if (this.config.aot === !1) {
            let b = B();
            this.router.dynamic.add($, X, {
                validator: b,
                hooks: O,
                content: Q?.type,
                handle: W,
                route: X,
            });
            let T = SW(X, { dynamic: !0 });
            if (X !== T)
                this.router.dynamic.add($, T, {
                    validator: b,
                    hooks: O,
                    content: Q?.type,
                    handle: W,
                    route: X,
                });
            if (this.config.strictPath === !1) {
                let o = PW(X);
                this.router.dynamic.add($, o, {
                    validator: b,
                    hooks: O,
                    content: Q?.type,
                    handle: W,
                    route: X,
                });
                let e = SW(o);
                if (o !== e)
                    this.router.dynamic.add($, o, {
                        validator: b,
                        hooks: O,
                        content: Q?.type,
                        handle: W,
                        route: X,
                    });
            }
            this.router.history.push({
                method: $,
                path: X,
                composed: null,
                handler: W,
                compile: void 0,
                hooks: O,
                standaloneValidators: J,
            });
            return;
        }
        let w = this['~adapter'].handler,
            z =
                typeof W !== 'function'
                    ? () => {
                          let b = w.createNativeStaticHandler?.(
                              W,
                              O,
                              this.setHeaders,
                          );
                          return b instanceof Promise
                              ? b.then((T) => {
                                    if (T) return T;
                                })
                              : b?.();
                      }
                    : void 0,
            H = this.config.nativeStaticResponse === !0,
            P = (b) => {
                if (!H || !z) return;
                if (hZ)
                    if (this.router.response[b])
                        this.router.response[b][$] = z();
                    else this.router.response[b] = { [$]: z() };
                else this.router.response[b] = z();
            };
        P(X);
        let E,
            j = () => {
                if (E) return E;
                return (E = fF({
                    app: this,
                    path: X,
                    method: $,
                    hooks: O,
                    validator: B(),
                    handler:
                        typeof W !== 'function' &&
                        typeof w.createStaticHandler !== 'function'
                            ? () => W
                            : W,
                    allowMeta: N,
                    inference: this.inference,
                }));
            },
            V;
        if (`${$}_${X}` in this.routeTree)
            for (let b = 0; b < this.router.history.length; b++) {
                let T = this.router.history[b];
                if (T.path === X && T.method === $) {
                    V = b;
                    break;
                }
            }
        else this.routeTree[`${$}_${X}`] = this.router.history.length;
        let i = V ?? this.router.history.length,
            $$ = Z ? j() : (b) => (this.router.history[i].composed = j())(b);
        if (V !== void 0)
            this.router.history[V] = Object.assign(
                {
                    method: $,
                    path: X,
                    composed: $$,
                    compile: j,
                    handler: W,
                    hooks: O,
                },
                J.length ? { standaloneValidators: J } : void 0,
                Q.webSocket ? { websocket: Q.websocket } : void 0,
            );
        else
            this.router.history.push(
                Object.assign(
                    {
                        method: $,
                        path: X,
                        composed: $$,
                        compile: j,
                        handler: W,
                        hooks: O,
                    },
                    J.length ? { standaloneValidators: J } : void 0,
                    Q.webSocket ? { websocket: Q.websocket } : void 0,
                ),
            );
        let y = {
                handler: Z ? $$ : void 0,
                compile() {
                    return (this.handler = j());
                },
            },
            n = this.router.static,
            k = X.indexOf(':') === -1 && X.indexOf('*') === -1;
        if ($ === 'WS') {
            if (k) {
                if (X in n) n[X][$] = i;
                else n[X] = { [$]: i };
                return;
            }
            if ((this.router.http.add('WS', X, y), !this.config.strictPath))
                this.router.http.add('WS', PW(X), y);
            let b = SW(X, { dynamic: !0 });
            if (X !== b) this.router.http.add('WS', b, y);
            return;
        }
        if (k) {
            if (X in n) n[X][$] = i;
            else n[X] = { [$]: i };
            if (!this.config.strictPath) P(PW(X));
        } else {
            if ((this.router.http.add($, X, y), !this.config.strictPath)) {
                let T = PW(X);
                P(T), this.router.http.add($, T, y);
            }
            let b = SW(X, { dynamic: !0 });
            if (X !== b) this.router.http.add($, b, y), P(b);
        }
    }
    setHeaders;
    headers($) {
        if (!$) return this;
        if (!this.setHeaders) this.setHeaders = {};
        return (this.setHeaders = t6(this.setHeaders, $)), this;
    }
    onStart($) {
        return this.on('start', $), this;
    }
    onRequest($) {
        return this.on('request', $), this;
    }
    onParse($, X) {
        if (!X) {
            if (typeof $ === 'string')
                return this.on('parse', this['~parser'][$]);
            return this.on('parse', $);
        }
        return this.on($, 'parse', X);
    }
    parser($, X) {
        return (this['~parser'][$] = X), this;
    }
    onTransform($, X) {
        if (!X) return this.on('transform', $);
        return this.on($, 'transform', X);
    }
    resolve($, X) {
        if (!X) (X = $), ($ = { as: 'local' });
        let W = { subType: 'resolve', fn: X };
        return this.onBeforeHandle($, W);
    }
    mapResolve($, X) {
        if (!X) (X = $), ($ = { as: 'local' });
        let W = { subType: 'mapResolve', fn: X };
        return this.onBeforeHandle($, W);
    }
    onBeforeHandle($, X) {
        if (!X) return this.on('beforeHandle', $);
        return this.on($, 'beforeHandle', X);
    }
    onAfterHandle($, X) {
        if (!X) return this.on('afterHandle', $);
        return this.on($, 'afterHandle', X);
    }
    mapResponse($, X) {
        if (!X) return this.on('mapResponse', $);
        return this.on($, 'mapResponse', X);
    }
    onAfterResponse($, X) {
        if (!X) return this.on('afterResponse', $);
        return this.on($, 'afterResponse', X);
    }
    trace($, X) {
        if (!X) (X = $), ($ = { as: 'local' });
        if (!Array.isArray(X)) X = [X];
        for (let W of X) this.on($, 'trace', FF(W));
        return this;
    }
    error($, X) {
        switch (typeof $) {
            case 'string':
                return (
                    (X.prototype[A8] = $), (this.definitions.error[$] = X), this
                );
            case 'function':
                return (
                    (this.definitions.error = $(this.definitions.error)), this
                );
        }
        for (let [W, Q] of Object.entries($))
            (Q.prototype[A8] = W), (this.definitions.error[W] = Q);
        return this;
    }
    onError($, X) {
        if (!X) return this.on('error', $);
        return this.on($, 'error', X);
    }
    onStop($) {
        return this.on('stop', $), this;
    }
    on($, X, W) {
        let Q;
        switch (typeof $) {
            case 'string':
                (Q = $), (W = X);
                break;
            case 'object':
                if (((Q = X), !Array.isArray(X) && typeof X === 'object'))
                    W = X;
                break;
        }
        if (Array.isArray(W)) W = D6(W);
        else if (typeof W === 'function') W = [{ fn: W }];
        else W = [W];
        let Y = W;
        for (let J of Y)
            if (
                ((J.scope =
                    typeof $ === 'string' ? 'local' : ($?.as ?? 'local')),
                Q === 'resolve' || Q === 'derive')
            )
                J.subType = Q;
        if (Q !== 'trace')
            this.inference = CW({ [Q]: Y.map((J) => J.fn) }, this.inference);
        for (let J of Y) {
            let U = QF(J, 'global', { skipIfHasType: !0 });
            switch (Q) {
                case 'start':
                    (this.event.start ??= []), this.event.start.push(U);
                    break;
                case 'request':
                    (this.event.request ??= []), this.event.request.push(U);
                    break;
                case 'parse':
                    (this.event.parse ??= []), this.event.parse.push(U);
                    break;
                case 'transform':
                    (this.event.transform ??= []), this.event.transform.push(U);
                    break;
                case 'derive':
                    (this.event.transform ??= []),
                        this.event.transform.push(D6(U, 'derive'));
                    break;
                case 'beforeHandle':
                    (this.event.beforeHandle ??= []),
                        this.event.beforeHandle.push(U);
                    break;
                case 'resolve':
                    (this.event.beforeHandle ??= []),
                        this.event.beforeHandle.push(D6(U, 'resolve'));
                    break;
                case 'afterHandle':
                    (this.event.afterHandle ??= []),
                        this.event.afterHandle.push(U);
                    break;
                case 'mapResponse':
                    (this.event.mapResponse ??= []),
                        this.event.mapResponse.push(U);
                    break;
                case 'afterResponse':
                    (this.event.afterResponse ??= []),
                        this.event.afterResponse.push(U);
                    break;
                case 'trace':
                    (this.event.trace ??= []), this.event.trace.push(U);
                    break;
                case 'error':
                    (this.event.error ??= []), this.event.error.push(U);
                    break;
                case 'stop':
                    (this.event.stop ??= []), this.event.stop.push(U);
                    break;
            }
        }
        return this;
    }
    as($) {
        if (
            (U0(this.event.parse, $),
            U0(this.event.transform, $),
            U0(this.event.beforeHandle, $),
            U0(this.event.afterHandle, $),
            U0(this.event.mapResponse, $),
            U0(this.event.afterResponse, $),
            U0(this.event.trace, $),
            U0(this.event.error, $),
            $ === 'scoped')
        ) {
            if (
                ((this.validator.scoped = qW(
                    this.validator.scoped,
                    this.validator.local,
                )),
                (this.validator.local = null),
                this.standaloneValidator.local !== null)
            )
                (this.standaloneValidator.scoped ||= []),
                    this.standaloneValidator.scoped.push(
                        ...this.standaloneValidator.local,
                    ),
                    (this.standaloneValidator.local = null);
        } else if ($ === 'global') {
            if (
                ((this.validator.global = qW(
                    this.validator.global,
                    qW(this.validator.scoped, this.validator.local),
                )),
                (this.validator.scoped = null),
                (this.validator.local = null),
                this.standaloneValidator.local !== null)
            )
                (this.standaloneValidator.scoped ||= []),
                    this.standaloneValidator.scoped.push(
                        ...this.standaloneValidator.local,
                    ),
                    (this.standaloneValidator.local = null);
            if (this.standaloneValidator.scoped !== null)
                (this.standaloneValidator.global ||= []),
                    this.standaloneValidator.global.push(
                        ...this.standaloneValidator.scoped,
                    ),
                    (this.standaloneValidator.scoped = null);
        }
        return this;
    }
    group($, X, W) {
        let Q = new V4({ ...this.config, prefix: '' });
        (Q.singleton = { ...this.singleton }),
            (Q.definitions = { ...this.definitions }),
            (Q.getServer = () => this.getServer()),
            (Q.inference = BZ(this.inference)),
            (Q.extender = { ...this.extender }),
            (Q['~parser'] = this['~parser']),
            (Q.standaloneValidator = {
                local: [...(this.standaloneValidator.local ?? [])],
                scoped: [...(this.standaloneValidator.scoped ?? [])],
                global: [...(this.standaloneValidator.global ?? [])],
            });
        let Y = typeof X === 'object',
            J = (Y ? W : X)(Q);
        if (
            ((this.singleton = t6(this.singleton, Q.singleton)),
            (this.definitions = t6(this.definitions, Q.definitions)),
            J.event.request?.length)
        )
            this.event.request = [
                ...(this.event.request || []),
                ...(J.event.request || []),
            ];
        if (J.event.mapResponse?.length)
            this.event.mapResponse = [
                ...(this.event.mapResponse || []),
                ...(J.event.mapResponse || []),
            ];
        return (
            this.model(J.definitions.type),
            Object.values(Q.router.history).forEach(
                ({
                    method: U,
                    path: N,
                    handler: M,
                    hooks: G,
                    standaloneValidators: Z,
                }) => {
                    if (((N = (Y ? '' : this.config.prefix) + $ + N), Y)) {
                        let B = X,
                            O = G;
                        this.add(
                            U,
                            N,
                            M,
                            x1(B, {
                                ...(O || {}),
                                error: !O.error
                                    ? J.event.error
                                    : Array.isArray(O.error)
                                      ? [
                                            ...(O.error ?? []),
                                            ...(J.event.error ?? []),
                                        ]
                                      : [O.error, ...(J.event.error ?? [])],
                            }),
                            void 0,
                            Z,
                        );
                    } else
                        this.add(
                            U,
                            N,
                            M,
                            x1(G, { error: J.event.error }),
                            { skipPrefix: !0 },
                            Z,
                        );
                },
            ),
            this
        );
    }
    guard($, X) {
        if (!X) {
            if (typeof $ === 'object') {
                if ((this.applyMacro($), $.detail))
                    if (this.config.detail)
                        this.config.detail = t6(
                            Object.assign({}, this.config.detail),
                            $.detail,
                        );
                    else this.config.detail = $.detail;
                if ($.tags)
                    if (!this.config.detail)
                        this.config.detail = { tags: $.tags };
                    else this.config.detail.tags = $.tags;
                let Y = $.as ?? 'local';
                if ($.schema === 'standalone') {
                    if (!this.standaloneValidator[Y])
                        this.standaloneValidator[Y] = [];
                    let J =
                        $?.response ||
                        typeof $?.response === 'string' ||
                        ($?.response && S in $.response)
                            ? { 200: $.response }
                            : $?.response;
                    this.standaloneValidator[Y].push({
                        body: $.body,
                        headers: $.headers,
                        params: $.params,
                        query: $.query,
                        response: J,
                        cookie: $.cookie,
                    });
                } else
                    this.validator[Y] = {
                        body: $.body ?? this.validator[Y]?.body,
                        headers: $.headers ?? this.validator[Y]?.headers,
                        params: $.params ?? this.validator[Y]?.params,
                        query: $.query ?? this.validator[Y]?.query,
                        response: $.response ?? this.validator[Y]?.response,
                        cookie: $.cookie ?? this.validator[Y]?.cookie,
                    };
                if ($.parse) this.on({ as: Y }, 'parse', $.parse);
                if ($.transform) this.on({ as: Y }, 'transform', $.transform);
                if ($.derive) this.on({ as: Y }, 'derive', $.derive);
                if ($.beforeHandle)
                    this.on({ as: Y }, 'beforeHandle', $.beforeHandle);
                if ($.resolve) this.on({ as: Y }, 'resolve', $.resolve);
                if ($.afterHandle)
                    this.on({ as: Y }, 'afterHandle', $.afterHandle);
                if ($.mapResponse)
                    this.on({ as: Y }, 'mapResponse', $.mapResponse);
                if ($.afterResponse)
                    this.on({ as: Y }, 'afterResponse', $.afterResponse);
                if ($.error) this.on({ as: Y }, 'error', $.error);
                return this;
            }
            return this.guard({}, $);
        }
        let W = new V4({ ...this.config, prefix: '' });
        (W.singleton = { ...this.singleton }),
            (W.definitions = { ...this.definitions }),
            (W.inference = BZ(this.inference)),
            (W.extender = { ...this.extender });
        let Q = X(W);
        if (
            ((this.singleton = t6(this.singleton, W.singleton)),
            (this.definitions = t6(this.definitions, W.definitions)),
            (Q.getServer = () => this.server),
            Q.event.request?.length)
        )
            this.event.request = [
                ...(this.event.request || []),
                ...(Q.event.request || []),
            ];
        if (Q.event.mapResponse?.length)
            this.event.mapResponse = [
                ...(this.event.mapResponse || []),
                ...(Q.event.mapResponse || []),
            ];
        return (
            this.model(Q.definitions.type),
            Object.values(W.router.history).forEach(
                ({ method: Y, path: J, handler: U, hooks: N }) => {
                    this.add(
                        Y,
                        J,
                        U,
                        x1($, {
                            ...(N || {}),
                            error: !N.error
                                ? Q.event.error
                                : Array.isArray(N.error)
                                  ? [
                                        ...(N.error ?? []),
                                        ...(Q.event.error ?? []),
                                    ]
                                  : [N.error, ...(Q.event.error ?? [])],
                        }),
                    );
                },
            ),
            this
        );
    }
    use($) {
        if (Array.isArray($)) {
            let X = this;
            for (let W of $) X = X.use(W);
            return X;
        }
        if ($ instanceof Promise)
            return (
                this.promisedModules.add(
                    $.then((X) => {
                        if (typeof X === 'function') return X(this);
                        if (X instanceof V4) return this._use(X).compile();
                        if (X.constructor.name === 'Elysia')
                            return this._use(X).compile();
                        if (typeof X.default === 'function')
                            return X.default(this);
                        if (X.default instanceof V4)
                            return this._use(X.default);
                        if (X.constructor.name === 'Elysia')
                            return this._use(X.default);
                        if (X.constructor.name === '_Elysia')
                            return this._use(X.default);
                        try {
                            return this._use(X.default);
                        } catch (W) {
                            throw (
                                (console.error(
                                    'Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.',
                                ),
                                W)
                            );
                        }
                    }).then((X) => {
                        if (X && typeof X.compile === 'function') X.compile();
                        return X;
                    }),
                ),
                this
            );
        return this._use($);
    }
    propagatePromiseModules($) {
        if ($.promisedModules.size <= 0) return this;
        for (let X of $.promisedModules.promises)
            this.promisedModules.add(
                X.then((W) => {
                    if (!W) return;
                    let Q = this._use(W);
                    if (Q instanceof Promise)
                        return Q.then((Y) => {
                            if (Y) Y.compile();
                            else W.compile();
                        });
                    return W.compile();
                }),
            );
        return this;
    }
    _use($) {
        if (typeof $ === 'function') {
            let Q = $(this);
            if (Q instanceof Promise)
                return (
                    this.promisedModules.add(
                        Q.then((Y) => {
                            if (Y instanceof V4) {
                                (Y.getServer = () => this.getServer()),
                                    (Y.getGlobalRoutes = () =>
                                        this.getGlobalRoutes()),
                                    (Y.getGlobalDefinitions = () =>
                                        this.getGlobalDefinitions()),
                                    Y.model(this.definitions.type),
                                    Y.error(this.definitions.error);
                                for (let {
                                    method: J,
                                    path: U,
                                    handler: N,
                                    hooks: M,
                                    standaloneValidators: G,
                                } of Object.values(Y.router.history))
                                    this.add(
                                        J,
                                        U,
                                        N,
                                        f$(Y.event.error)
                                            ? x1(M, { error: Y.event.error })
                                            : M,
                                        void 0,
                                        G,
                                    );
                                if (Y === this) return;
                                return this.propagatePromiseModules(Y), Y;
                            }
                            if (typeof Y === 'function') return Y(this);
                            if (typeof Y.default === 'function')
                                return Y.default(this);
                            return this._use(Y);
                        }).then((Y) => {
                            if (Y && typeof Y.compile === 'function')
                                Y.compile();
                            return Y;
                        }),
                    ),
                    this
                );
            return Q;
        }
        this.propagatePromiseModules($);
        let X = $.config.name,
            W = $.config.seed;
        if (
            (($.getParent = () => this),
            ($.getServer = () => this.getServer()),
            ($.getGlobalRoutes = () => this.getGlobalRoutes()),
            ($.getGlobalDefinitions = () => this.getGlobalDefinitions()),
            $.standaloneValidator?.scoped)
        )
            if (this.standaloneValidator.local)
                this.standaloneValidator.local =
                    this.standaloneValidator.local.concat(
                        $.standaloneValidator.scoped,
                    );
            else this.standaloneValidator.local = $.standaloneValidator.scoped;
        if ($.standaloneValidator?.global)
            if (this.standaloneValidator.global)
                this.standaloneValidator.global =
                    this.standaloneValidator.global.concat(
                        $.standaloneValidator.global,
                    );
            else this.standaloneValidator.global = $.standaloneValidator.global;
        if (f$($['~parser']))
            this['~parser'] = { ...$['~parser'], ...this['~parser'] };
        if ($.setHeaders) this.headers($.setHeaders);
        if (X) {
            if (!(X in this.dependencies)) this.dependencies[X] = [];
            let Q = W !== void 0 ? IX(X + JSON.stringify(W)) : 0;
            if (!this.dependencies[X].some(({ checksum: Y }) => Q === Y))
                (this.extender.macros = this.extender.macros.concat(
                    $.extender.macros,
                )),
                    (this.extender.higherOrderFunctions =
                        this.extender.higherOrderFunctions.concat(
                            $.extender.higherOrderFunctions,
                        ));
        } else {
            if ($.extender.macros.length)
                this.extender.macros = this.extender.macros.concat(
                    $.extender.macros,
                );
            if ($.extender.higherOrderFunctions.length)
                this.extender.higherOrderFunctions =
                    this.extender.higherOrderFunctions.concat(
                        $.extender.higherOrderFunctions,
                    );
        }
        if (
            (OZ(this.extender.macros), $.extender.higherOrderFunctions.length)
        ) {
            OZ(this.extender.higherOrderFunctions);
            let Q = [];
            for (
                let Y = 0;
                Y < this.extender.higherOrderFunctions.length;
                Y++
            ) {
                let J = this.extender.higherOrderFunctions[Y];
                if (J.checksum) {
                    if (Q.includes(J.checksum))
                        this.extender.higherOrderFunctions.splice(Y, 1), Y--;
                    Q.push(J.checksum);
                }
            }
            Q.length = 0;
        }
        if (
            ((this.inference = YU(this.inference, $.inference)),
            f$($.singleton.decorator))
        )
            this.decorate($.singleton.decorator);
        if (f$($.singleton.store)) this.state($.singleton.store);
        if (f$($.definitions.type)) this.model($.definitions.type);
        if (f$($.definitions.error)) this.error($.definitions.error);
        if (f$($.definitions.error))
            $.extender.macros = this.extender.macros.concat($.extender.macros);
        for (let {
            method: Q,
            path: Y,
            handler: J,
            hooks: U,
            standaloneValidators: N,
        } of Object.values($.router.history))
            this.add(
                Q,
                Y,
                J,
                f$($.event.error) ? x1(U, { error: $.event.error }) : U,
                void 0,
                N,
            );
        if (X) {
            if (!(X in this.dependencies)) this.dependencies[X] = [];
            let Q = W !== void 0 ? IX(X + JSON.stringify(W)) : 0;
            if (this.dependencies[X].some(({ checksum: Y }) => Q === Y))
                return this;
            if (
                (this.dependencies[X].push(
                    this.config?.analytic
                        ? {
                              name: $.config.name,
                              seed: $.config.seed,
                              checksum: Q,
                              dependencies: $.dependencies,
                              stack: $.telemetry?.stack,
                              routes: $.router.history,
                              decorators: $.singleton,
                              store: $.singleton.store,
                              error: $.definitions.error,
                              derive: $.event.transform
                                  ?.filter((Y) => Y?.subType === 'derive')
                                  .map((Y) => ({
                                      fn: Y.toString(),
                                      stack: new Error().stack ?? '',
                                  })),
                              resolve: $.event.transform
                                  ?.filter((Y) => Y?.subType === 'resolve')
                                  .map((Y) => ({
                                      fn: Y.toString(),
                                      stack: new Error().stack ?? '',
                                  })),
                          }
                        : {
                              name: $.config.name,
                              seed: $.config.seed,
                              checksum: Q,
                              dependencies: $.dependencies,
                          },
                ),
                f$($.event))
            )
                this.event = NZ(this.event, MZ($.event), Q);
        } else if (f$($.event)) this.event = NZ(this.event, MZ($.event));
        if ($.validator.global)
            this.validator.global = x1(this.validator.global, {
                ...$.validator.global,
            });
        if ($.validator.scoped)
            this.validator.local = x1(this.validator.local, {
                ...$.validator.scoped,
            });
        return this;
    }
    macro($) {
        if (typeof $ === 'function') {
            let X = {
                checksum: IX(
                    JSON.stringify({
                        name: this.config.name,
                        seed: this.config.seed,
                        content: $.toString(),
                    }),
                ),
                fn: $,
            };
            this.extender.macros.push(X);
        } else if (typeof $ === 'object') {
            for (let W of Object.keys($))
                if (typeof $[W] === 'object') {
                    let Q = { ...$[W] };
                    $[W] = (Y) => {
                        if (Y === !0) return Q;
                    };
                }
            let X = {
                checksum: IX(
                    JSON.stringify({
                        name: this.config.name,
                        seed: this.config.seed,
                        content: Object.entries($)
                            .map(([W, Q]) => `${W}+${Q}`)
                            .join(','),
                    }),
                ),
                fn: () => $,
            };
            this.extender.macros.push(X);
        }
        return this;
    }
    mount($, X, W) {
        if (
            $ instanceof V4 ||
            typeof $ === 'function' ||
            $.length === 0 ||
            $ === '/'
        ) {
            let U =
                    typeof $ === 'function'
                        ? $
                        : $ instanceof V4
                          ? $.compile().fetch
                          : X instanceof V4
                            ? X.compile().fetch
                            : typeof X === 'function'
                              ? X
                              : (() => {
                                    throw new Error('Invalid handler');
                                })(),
                N = ({ request: M, path: G }) =>
                    U(
                        new Request(UZ(M.url, G), {
                            method: M.method,
                            headers: M.headers,
                            signal: M.signal,
                            credentials: M.credentials,
                            referrerPolicy: M.referrerPolicy,
                            duplex: M.duplex,
                            redirect: M.redirect,
                            mode: M.mode,
                            keepalive: M.keepalive,
                            integrity: M.integrity,
                            body: M.body,
                        }),
                    );
            return (
                this.route('ALL', '/*', N, {
                    parse: 'none',
                    ...W,
                    detail: { ...W?.detail, hide: !0 },
                    config: { mount: U },
                }),
                this
            );
        }
        let Q =
                X instanceof V4
                    ? X.compile().fetch
                    : typeof X === 'function'
                      ? X
                      : (() => {
                            throw new Error('Invalid handler');
                        })(),
            Y = $.length - ($.endsWith('*') ? 1 : 0),
            J = ({ request: U, path: N }) =>
                Q(
                    new Request(UZ(U.url, N.slice(Y) || '/'), {
                        method: U.method,
                        headers: U.headers,
                        signal: U.signal,
                        credentials: U.credentials,
                        referrerPolicy: U.referrerPolicy,
                        duplex: U.duplex,
                        redirect: U.redirect,
                        mode: U.mode,
                        keepalive: U.keepalive,
                        integrity: U.integrity,
                        body: U.body,
                    }),
                );
        return (
            this.route('ALL', $, J, {
                parse: 'none',
                ...W,
                detail: { ...W?.detail, hide: !0 },
                config: { mount: Q },
            }),
            this.route('ALL', $ + ($.endsWith('/') ? '*' : '/*'), J, {
                parse: 'none',
                ...W,
                detail: { ...W?.detail, hide: !0 },
                config: { mount: Q },
            }),
            this
        );
    }
    get($, X, W) {
        return this.add('GET', $, X, W), this;
    }
    post($, X, W) {
        return this.add('POST', $, X, W), this;
    }
    put($, X, W) {
        return this.add('PUT', $, X, W), this;
    }
    patch($, X, W) {
        return this.add('PATCH', $, X, W), this;
    }
    delete($, X, W) {
        return this.add('DELETE', $, X, W), this;
    }
    options($, X, W) {
        return this.add('OPTIONS', $, X, W), this;
    }
    all($, X, W) {
        return this.add('ALL', $, X, W), this;
    }
    head($, X, W) {
        return this.add('HEAD', $, X, W), this;
    }
    connect($, X, W) {
        return this.add('CONNECT', $, X, W), this;
    }
    route($, X, W, Q) {
        return this.add($.toUpperCase(), X, W, Q, Q?.config), this;
    }
    ws($, X) {
        if (this['~adapter'].ws) this['~adapter'].ws(this, $, X);
        else console.warn("Current adapter doesn't support WebSocket");
        return this;
    }
    state($, X, W) {
        if (X === void 0) (W = $), ($ = { as: 'append' }), (X = '');
        else if (W === void 0) {
            if (typeof $ === 'string') (W = X), (X = $), ($ = { as: 'append' });
            else if (typeof $ === 'object') (W = X), (X = '');
        }
        let { as: Q } = $;
        if (typeof X !== 'string') return this;
        switch (typeof W) {
            case 'object':
                if (!W || !f$(W)) return this;
                if (X) {
                    if (X in this.singleton.store)
                        this.singleton.store[X] = t6(
                            this.singleton.store[X],
                            W,
                            { override: Q === 'override' },
                        );
                    else this.singleton.store[X] = W;
                    return this;
                }
                if (W === null) return this;
                return (
                    (this.singleton.store = t6(this.singleton.store, W, {
                        override: Q === 'override',
                    })),
                    this
                );
            case 'function':
                if (X) {
                    if (Q === 'override' || !(X in this.singleton.store))
                        this.singleton.store[X] = W;
                } else this.singleton.store = W(this.singleton.store);
                return this;
            default:
                if (Q === 'override' || !(X in this.singleton.store))
                    this.singleton.store[X] = W;
                return this;
        }
    }
    decorate($, X, W) {
        if (X === void 0) (W = $), ($ = { as: 'append' }), (X = '');
        else if (W === void 0) {
            if (typeof $ === 'string') (W = X), (X = $), ($ = { as: 'append' });
            else if (typeof $ === 'object') (W = X), (X = '');
        }
        let { as: Q } = $;
        if (typeof X !== 'string') return this;
        switch (typeof W) {
            case 'object':
                if (X) {
                    if (X in this.singleton.decorator)
                        this.singleton.decorator[X] = t6(
                            this.singleton.decorator[X],
                            W,
                            { override: Q === 'override' },
                        );
                    else this.singleton.decorator[X] = W;
                    return this;
                }
                if (W === null) return this;
                return (
                    (this.singleton.decorator = t6(
                        this.singleton.decorator,
                        W,
                        { override: Q === 'override' },
                    )),
                    this
                );
            case 'function':
                if (X) {
                    if (Q === 'override' || !(X in this.singleton.decorator))
                        this.singleton.decorator[X] = W;
                } else this.singleton.decorator = W(this.singleton.decorator);
                return this;
            default:
                if (Q === 'override' || !(X in this.singleton.decorator))
                    this.singleton.decorator[X] = W;
                return this;
        }
    }
    derive($, X) {
        if (!X) (X = $), ($ = { as: 'local' });
        let W = { subType: 'derive', fn: X };
        return this.onTransform($, W);
    }
    model($, X) {
        switch (typeof $) {
            case 'object':
                let W = {},
                    Q = Object.entries($);
                if (!Q.length) return this;
                for (let [U, N] of Q) {
                    if (U in this.definitions.type) continue;
                    (W[U] = this.definitions.type[U] = N),
                        (W[U].$id ??= `#/components/schemas/${U}`);
                }
                return (
                    (this.definitions.typebox = c.Module({
                        ...this.definitions.typebox.$defs,
                        ...W,
                    })),
                    this
                );
            case 'function':
                let Y = $(this.definitions.type);
                return (
                    (this.definitions.type = Y),
                    (this.definitions.typebox = c.Module(Y)),
                    this
                );
            case 'string':
                if (!X) break;
                let J = { ...X, id: X.$id ?? `#/components/schemas/${$}` };
                return (
                    (this.definitions.type[$] = X),
                    (this.definitions.typebox = c.Module({
                        ...this.definitions.typebox.$defs,
                        ...J,
                    })),
                    this
                );
        }
        return (
            (this.definitions.type[$] = X),
            (this.definitions.typebox = c.Module({
                ...this.definitions.typebox.$defs,
                [$]: X,
            })),
            this
        );
    }
    Ref($) {
        return c.Ref($);
    }
    mapDerive($, X) {
        if (!X) (X = $), ($ = { as: 'local' });
        let W = { subType: 'mapDerive', fn: X };
        return this.onTransform($, W);
    }
    affix($, X, W) {
        if (W === '') return this;
        let Q = ['_', '-', ' '],
            Y = (M) => M[0].toUpperCase() + M.slice(1),
            J =
                $ === 'prefix'
                    ? (M, G) => (Q.includes(M.at(-1) ?? '') ? M + G : M + Y(G))
                    : Q.includes(W.at(-1) ?? '')
                      ? (M, G) => G + M
                      : (M, G) => G + Y(M),
            U = (M) => {
                let G = {};
                switch (M) {
                    case 'decorator':
                        for (let Z in this.singleton.decorator)
                            G[J(W, Z)] = this.singleton.decorator[Z];
                        this.singleton.decorator = G;
                        break;
                    case 'state':
                        for (let Z in this.singleton.store)
                            G[J(W, Z)] = this.singleton.store[Z];
                        this.singleton.store = G;
                        break;
                    case 'model':
                        for (let Z in this.definitions.type)
                            G[J(W, Z)] = this.definitions.type[Z];
                        this.definitions.type = G;
                        break;
                    case 'error':
                        for (let Z in this.definitions.error)
                            G[J(W, Z)] = this.definitions.error[Z];
                        this.definitions.error = G;
                        break;
                }
            },
            N = Array.isArray(X) ? X : [X];
        for (let M of N.some((G) => G === 'all')
            ? ['decorator', 'state', 'model', 'error']
            : N)
            U(M);
        return this;
    }
    prefix($, X) {
        return this.affix('prefix', $, X);
    }
    suffix($, X) {
        return this.affix('suffix', $, X);
    }
    compile() {
        if (this['~adapter'].isWebStandard) {
            if (
                ((this.fetch = this.config.aot ? tJ(this) : VZ(this)),
                typeof this.server?.reload === 'function')
            )
                this.server.reload({
                    ...(this.server || {}),
                    fetch: this.fetch,
                });
            return this;
        }
        if (typeof this.server?.reload === 'function')
            this.server.reload(this.server || {});
        return (this._handle = tJ(this)), this;
    }
    handle = async ($) => this.fetch($);
    fetch = ($) => {
        return (this.fetch = this.config.aot ? tJ(this) : VZ(this))($);
    };
    handleError = async ($, X) => {
        return (this.handleError = this.config.aot ? Ww(this) : iF(this))($, X);
    };
    listen = ($, X) => {
        if ((this['~adapter'].listen(this)($, X), this.promisedModules.size))
            SZ(5000);
        return (
            this.promisedModules.then(() => {
                SZ(1000);
            }),
            this
        );
    };
    stop = async ($) => {
        if (!this.server)
            throw new Error(
                "Elysia isn't running. Call `app.listen` to start the server.",
            );
        if (this.server) {
            if (
                (this.server.stop($),
                (this.server = null),
                this.event.stop?.length)
            )
                for (let X = 0; X < this.event.stop.length; X++)
                    this.event.stop[X].fn(this);
        }
    };
    get modules() {
        return this.promisedModules;
    }
}
var S6 = {};
k6(S6, {
    xid: () => dC,
    void: () => zR,
    uuidv7: () => vC,
    uuidv6: () => kC,
    uuidv4: () => TC,
    uuid: () => gC,
    url: () => fC,
    uppercase: () => aW,
    unknown: () => KQ,
    union: () => EQ,
    undefined: () => MR,
    ulid: () => uC,
    uint64: () => UR,
    uint32: () => YR,
    tuple: () => qR,
    trim: () => YY,
    treeifyError: () => CU,
    transform: () => v9,
    toUpperCase: () => JY,
    toLowerCase: () => QY,
    toJSONSchema: () => W9,
    templateLiteral: () => IR,
    symbol: () => NR,
    superRefine: () => PD,
    success: () => _R,
    stringbool: () => ER,
    stringFormat: () => eC,
    string: () => Z9,
    strictObject: () => BR,
    startsWith: () => eW,
    size: () => oW,
    setErrorMap: () => TR,
    set: () => SR,
    safeParseAsync: () => z9,
    safeParse: () => G9,
    registry: () => o8,
    regexes: () => m0,
    regex: () => rW,
    refine: () => AD,
    record: () => ow,
    readonly: () => wD,
    property: () => l5,
    promise: () => CR,
    prettifyError: () => RU,
    preprocess: () => bR,
    prefault: () => JD,
    positive: () => d5,
    pipe: () => IQ,
    partialRecord: () => AR,
    parseAsync: () => M9,
    parse: () => N9,
    overwrite: () => u1,
    optional: () => _Q,
    object: () => DR,
    number: () => gw,
    nullish: () => KR,
    nullable: () => FQ,
    null: () => yw,
    normalize: () => WY,
    nonpositive: () => n5,
    nonoptional: () => UD,
    nonnegative: () => p5,
    never: () => CQ,
    negative: () => i5,
    nativeEnum: () => jR,
    nanoid: () => hC,
    nan: () => FR,
    multipleOf: () => d0,
    minSize: () => i0,
    minLength: () => O0,
    mime: () => XY,
    maxSize: () => vX,
    maxLength: () => fX,
    map: () => PR,
    lte: () => E4,
    lt: () => m1,
    lowercase: () => tW,
    looseObject: () => OR,
    locales: () => nW,
    literal: () => ew,
    length: () => yX,
    lazy: () => OD,
    ksuid: () => iC,
    keyof: () => wR,
    jwt: () => sC,
    json: () => xR,
    iso: () => jQ,
    ipv6: () => pC,
    ipv4: () => nC,
    intersection: () => pw,
    int64: () => JR,
    int32: () => WR,
    int: () => w9,
    instanceof: () => VR,
    includes: () => sW,
    guid: () => bC,
    gte: () => X4,
    gt: () => c1,
    globalRegistry: () => z1,
    getErrorMap: () => kR,
    function: () => X9,
    formatError: () => hW,
    float64: () => XR,
    float32: () => $R,
    flattenError: () => yW,
    file: () => LR,
    enum: () => aw,
    endsWith: () => $Y,
    emoji: () => yC,
    email: () => xC,
    e164: () => aC,
    discriminatedUnion: () => HR,
    date: () => ZR,
    custom: () => RR,
    cuid2: () => cC,
    cuid: () => mC,
    core: () => d1,
    config: () => z6,
    coerce: () => c9,
    clone: () => O4,
    cidrv6: () => oC,
    cidrv4: () => lC,
    check: () => qD,
    catch: () => GD,
    boolean: () => Tw,
    bigint: () => QR,
    base64url: () => tC,
    base64: () => rC,
    array: () => b9,
    any: () => GR,
    _default: () => YD,
    _ZodString: () => D9,
    ZodXID: () => j9,
    ZodVoid: () => uw,
    ZodUnknown: () => mw,
    ZodUnion: () => g9,
    ZodUndefined: () => vw,
    ZodUUID: () => i1,
    ZodURL: () => O9,
    ZodULID: () => S9,
    ZodType: () => J$,
    ZodTuple: () => lw,
    ZodTransform: () => k9,
    ZodTemplateLiteral: () => DD,
    ZodSymbol: () => kw,
    ZodSuccess: () => ND,
    ZodStringFormat: () => y$,
    ZodString: () => MY,
    ZodSet: () => tw,
    ZodRecord: () => T9,
    ZodRealError: () => hX,
    ZodReadonly: () => ZD,
    ZodPromise: () => HD,
    ZodPrefault: () => QD,
    ZodPipe: () => h9,
    ZodOptional: () => f9,
    ZodObject: () => VQ,
    ZodNumberFormat: () => mX,
    ZodNumber: () => GY,
    ZodNullable: () => XD,
    ZodNull: () => fw,
    ZodNonOptional: () => y9,
    ZodNever: () => cw,
    ZodNanoID: () => q9,
    ZodNaN: () => zD,
    ZodMap: () => rw,
    ZodLiteral: () => sw,
    ZodLazy: () => BD,
    ZodKSUID: () => L9,
    ZodJWT: () => E9,
    ZodIssueCode: () => gR,
    ZodIntersection: () => nw,
    ZodISOTime: () => PQ,
    ZodISODuration: () => SQ,
    ZodISODateTime: () => qQ,
    ZodISODate: () => AQ,
    ZodIPv6: () => _9,
    ZodIPv4: () => K9,
    ZodGUID: () => LQ,
    ZodFirstPartyTypeKind: () => m9,
    ZodFile: () => $D,
    ZodError: () => VC,
    ZodEnum: () => NY,
    ZodEmoji: () => H9,
    ZodEmail: () => B9,
    ZodE164: () => V9,
    ZodDiscriminatedUnion: () => iw,
    ZodDefault: () => WD,
    ZodDate: () => RQ,
    ZodCustomStringFormat: () => bw,
    ZodCustom: () => xQ,
    ZodCatch: () => MD,
    ZodCUID2: () => P9,
    ZodCUID: () => A9,
    ZodCIDRv6: () => I9,
    ZodCIDRv4: () => F9,
    ZodBoolean: () => zY,
    ZodBigIntFormat: () => x9,
    ZodBigInt: () => ZY,
    ZodBase64URL: () => R9,
    ZodBase64: () => C9,
    ZodArray: () => dw,
    ZodAny: () => hw,
    TimePrecision: () => H5,
    NEVER: () => OU,
    $output: () => w5,
    $input: () => D5,
    $brand: () => HU,
});
var d1 = {};
k6(d1, {
    version: () => _N,
    util: () => m,
    treeifyError: () => CU,
    toJSONSchema: () => W9,
    toDotPath: () => Nw,
    safeParseAsync: () => EU,
    safeParse: () => VU,
    registry: () => o8,
    regexes: () => m0,
    prettifyError: () => RU,
    parseAsync: () => v8,
    parse: () => T8,
    locales: () => nW,
    isValidJWT: () => Fw,
    isValidBase64URL: () => _w,
    isValidBase64: () => nN,
    globalRegistry: () => z1,
    globalConfig: () => VW,
    function: () => X9,
    formatError: () => hW,
    flattenError: () => yW,
    config: () => z6,
    clone: () => O4,
    _xid: () => UQ,
    _void: () => h5,
    _uuidv7: () => e8,
    _uuidv6: () => s8,
    _uuidv4: () => a8,
    _uuid: () => t8,
    _url: () => $Q,
    _uppercase: () => aW,
    _unknown: () => kX,
    _union: () => NC,
    _undefined: () => k5,
    _ulid: () => JQ,
    _uint64: () => g5,
    _uint32: () => C5,
    _tuple: () => o5,
    _trim: () => YY,
    _transform: () => HC,
    _toUpperCase: () => JY,
    _toLowerCase: () => QY,
    _templateLiteral: () => FC,
    _symbol: () => T5,
    _success: () => jC,
    _stringbool: () => s5,
    _stringFormat: () => e5,
    _string: () => B5,
    _startsWith: () => eW,
    _size: () => oW,
    _set: () => wC,
    _safeParseAsync: () => y8,
    _safeParse: () => f8,
    _regex: () => rW,
    _refine: () => a5,
    _record: () => zC,
    _readonly: () => _C,
    _property: () => l5,
    _promise: () => CC,
    _positive: () => d5,
    _pipe: () => KC,
    _parseAsync: () => k8,
    _parse: () => g8,
    _overwrite: () => u1,
    _optional: () => qC,
    _number: () => j5,
    _nullable: () => AC,
    _null: () => v5,
    _normalize: () => WY,
    _nonpositive: () => n5,
    _nonoptional: () => SC,
    _nonnegative: () => p5,
    _never: () => y5,
    _negative: () => i5,
    _nativeEnum: () => BC,
    _nanoid: () => WQ,
    _nan: () => u5,
    _multipleOf: () => d0,
    _minSize: () => i0,
    _minLength: () => O0,
    _min: () => X4,
    _mime: () => XY,
    _maxSize: () => vX,
    _maxLength: () => fX,
    _max: () => E4,
    _map: () => ZC,
    _lte: () => E4,
    _lt: () => m1,
    _lowercase: () => tW,
    _literal: () => OC,
    _length: () => yX,
    _lazy: () => IC,
    _ksuid: () => NQ,
    _jwt: () => OQ,
    _isoTime: () => P5,
    _isoDuration: () => S5,
    _isoDateTime: () => q5,
    _isoDate: () => A5,
    _ipv6: () => GQ,
    _ipv4: () => MQ,
    _intersection: () => GC,
    _int64: () => b5,
    _int32: () => I5,
    _int: () => K5,
    _includes: () => sW,
    _guid: () => lW,
    _gte: () => X4,
    _gt: () => c1,
    _float64: () => F5,
    _float32: () => _5,
    _file: () => r5,
    _enum: () => DC,
    _endsWith: () => $Y,
    _emoji: () => XQ,
    _email: () => r8,
    _e164: () => BQ,
    _discriminatedUnion: () => MC,
    _default: () => PC,
    _date: () => m5,
    _custom: () => t5,
    _cuid2: () => QQ,
    _cuid: () => YQ,
    _coercedString: () => O5,
    _coercedNumber: () => L5,
    _coercedDate: () => c5,
    _coercedBoolean: () => V5,
    _coercedBigint: () => x5,
    _cidrv6: () => ZQ,
    _cidrv4: () => zQ,
    _catch: () => LC,
    _boolean: () => R5,
    _bigint: () => E5,
    _base64url: () => DQ,
    _base64: () => wQ,
    _array: () => UY,
    _any: () => f5,
    TimePrecision: () => H5,
    NEVER: () => OU,
    JSONSchemaGenerator: () => HQ,
    JSONSchema: () => Vw,
    Doc: () => u8,
    $output: () => w5,
    $input: () => D5,
    $constructor: () => L,
    $brand: () => HU,
    $ZodXID: () => kN,
    $ZodVoid: () => Q7,
    $ZodUnknown: () => TX,
    $ZodUnion: () => l8,
    $ZodUndefined: () => $7,
    $ZodUUID: () => CN,
    $ZodURL: () => VN,
    $ZodULID: () => TN,
    $ZodType: () => s,
    $ZodTuple: () => u0,
    $ZodTransform: () => uW,
    $ZodTemplateLiteral: () => _7,
    $ZodSymbol: () => eN,
    $ZodSuccess: () => S7,
    $ZodStringFormat: () => T$,
    $ZodString: () => c0,
    $ZodSet: () => Z7,
    $ZodRegistry: () => pW,
    $ZodRecord: () => G7,
    $ZodRealError: () => bX,
    $ZodReadonly: () => K7,
    $ZodPromise: () => F7,
    $ZodPrefault: () => A7,
    $ZodPipe: () => dW,
    $ZodOptional: () => O7,
    $ZodObject: () => U7,
    $ZodNumberFormat: () => aN,
    $ZodNumber: () => n8,
    $ZodNullable: () => H7,
    $ZodNull: () => X7,
    $ZodNonOptional: () => P7,
    $ZodNever: () => Y7,
    $ZodNanoID: () => xN,
    $ZodNaN: () => L7,
    $ZodMap: () => z7,
    $ZodLiteral: () => D7,
    $ZodLazy: () => I7,
    $ZodKSUID: () => vN,
    $ZodJWT: () => rN,
    $ZodIntersection: () => M7,
    $ZodISOTime: () => hN,
    $ZodISODuration: () => mN,
    $ZodISODateTime: () => fN,
    $ZodISODate: () => yN,
    $ZodIPv6: () => uN,
    $ZodIPv4: () => cN,
    $ZodGUID: () => IN,
    $ZodFunction: () => $9,
    $ZodFile: () => B7,
    $ZodError: () => fW,
    $ZodEnum: () => w7,
    $ZodEmoji: () => EN,
    $ZodEmail: () => RN,
    $ZodE164: () => oN,
    $ZodDiscriminatedUnion: () => N7,
    $ZodDefault: () => q7,
    $ZodDate: () => J7,
    $ZodCustomStringFormat: () => tN,
    $ZodCustom: () => C7,
    $ZodCheckUpperCase: () => qN,
    $ZodCheckStringFormat: () => gX,
    $ZodCheckStartsWith: () => PN,
    $ZodCheckSizeEquals: () => ZN,
    $ZodCheckRegex: () => ON,
    $ZodCheckProperty: () => jN,
    $ZodCheckOverwrite: () => KN,
    $ZodCheckNumberFormat: () => NN,
    $ZodCheckMultipleOf: () => UN,
    $ZodCheckMinSize: () => zN,
    $ZodCheckMinLength: () => DN,
    $ZodCheckMimeType: () => LN,
    $ZodCheckMaxSize: () => GN,
    $ZodCheckMaxLength: () => wN,
    $ZodCheckLowerCase: () => HN,
    $ZodCheckLessThan: () => m8,
    $ZodCheckLengthEquals: () => BN,
    $ZodCheckIncludes: () => AN,
    $ZodCheckGreaterThan: () => c8,
    $ZodCheckEndsWith: () => SN,
    $ZodCheckBigIntFormat: () => MN,
    $ZodCheck: () => a$,
    $ZodCatch: () => j7,
    $ZodCUID2: () => gN,
    $ZodCUID: () => bN,
    $ZodCIDRv6: () => iN,
    $ZodCIDRv4: () => dN,
    $ZodBoolean: () => mW,
    $ZodBigIntFormat: () => sN,
    $ZodBigInt: () => p8,
    $ZodBase64URL: () => lN,
    $ZodBase64: () => pN,
    $ZodAsyncError: () => y1,
    $ZodArray: () => cW,
    $ZodAny: () => W7,
});
var OU = Object.freeze({ status: 'aborted' });
function L($, X, W) {
    function Q(N, M) {
        var G;
        Object.defineProperty(N, '_zod', {
            value: N._zod ?? {},
            enumerable: !1,
        }),
            (G = N._zod).traits ?? (G.traits = new Set()),
            N._zod.traits.add($),
            X(N, M);
        for (let Z in U.prototype)
            if (!(Z in N))
                Object.defineProperty(N, Z, { value: U.prototype[Z].bind(N) });
        (N._zod.constr = U), (N._zod.def = M);
    }
    let Y = W?.Parent ?? Object;
    class J extends Y {}
    Object.defineProperty(J, 'name', { value: $ });
    function U(N) {
        var M;
        let G = W?.Parent ? new J() : this;
        Q(G, N), (M = G._zod).deferred ?? (M.deferred = []);
        for (let Z of G._zod.deferred) Z();
        return G;
    }
    return (
        Object.defineProperty(U, 'init', { value: Q }),
        Object.defineProperty(U, Symbol.hasInstance, {
            value: (N) => {
                if (W?.Parent && N instanceof W.Parent) return !0;
                return N?._zod?.traits?.has($);
            },
        }),
        Object.defineProperty(U, 'name', { value: $ }),
        U
    );
}
var HU = Symbol('zod_brand');
class y1 extends Error {
    constructor() {
        super(
            'Encountered Promise during synchronous parse. Use .parseAsync() instead.',
        );
    }
}
var VW = {};
function z6($) {
    if ($) Object.assign(VW, $);
    return VW;
}
var m = {};
k6(m, {
    unwrapMessage: () => EW,
    stringifyPrimitive: () => h,
    required: () => NI,
    randomString: () => sF,
    propertyKeyTypes: () => TW,
    promiseAllObject: () => aF,
    primitiveTypes: () => LU,
    prefixIssues: () => $4,
    pick: () => WI,
    partial: () => UI,
    optionalKeys: () => KU,
    omit: () => YI,
    numKeys: () => eF,
    nullish: () => B0,
    normalizeParams: () => v,
    merge: () => JI,
    jsonStringifyReplacer: () => AU,
    joinValues: () => C,
    issue: () => IU,
    isPlainObject: () => xX,
    isObject: () => EX,
    getSizableOrigin: () => kW,
    getParsedType: () => $I,
    getLengthableOrigin: () => vW,
    getEnumValues: () => xW,
    getElementAtPath: () => tF,
    floatSafeRemainder: () => PU,
    finalizeIssue: () => H4,
    extend: () => QI,
    escapeRegex: () => h1,
    esc: () => f0,
    defineLazy: () => K$,
    createTransparentProxy: () => XI,
    clone: () => O4,
    cleanRegex: () => gW,
    cleanEnum: () => MI,
    captureStackTrace: () => b8,
    cached: () => bW,
    assignProp: () => SU,
    assertNotEqual: () => pF,
    assertNever: () => oF,
    assertIs: () => lF,
    assertEqual: () => nF,
    assert: () => rF,
    allowsEval: () => jU,
    aborted: () => y0,
    NUMBER_FORMAT_RANGES: () => _U,
    Class: () => Jw,
    BIGINT_FORMAT_RANGES: () => FU,
});
function nF($) {
    return $;
}
function pF($) {
    return $;
}
function lF($) {}
function oF($) {
    throw new Error();
}
function rF($) {}
function xW($) {
    let X = Object.values($).filter((Q) => typeof Q === 'number');
    return Object.entries($)
        .filter(([Q, Y]) => X.indexOf(+Q) === -1)
        .map(([Q, Y]) => Y);
}
function C($, X = '|') {
    return $.map((W) => h(W)).join(X);
}
function AU($, X) {
    if (typeof X === 'bigint') return X.toString();
    return X;
}
function bW($) {
    return {
        get value() {
            {
                let W = $();
                return Object.defineProperty(this, 'value', { value: W }), W;
            }
            throw new Error('cached value already set');
        },
    };
}
function B0($) {
    return $ === null || $ === void 0;
}
function gW($) {
    let X = $.startsWith('^') ? 1 : 0,
        W = $.endsWith('$') ? $.length - 1 : $.length;
    return $.slice(X, W);
}
function PU($, X) {
    let W = ($.toString().split('.')[1] || '').length,
        Q = (X.toString().split('.')[1] || '').length,
        Y = W > Q ? W : Q,
        J = Number.parseInt($.toFixed(Y).replace('.', '')),
        U = Number.parseInt(X.toFixed(Y).replace('.', ''));
    return (J % U) / 10 ** Y;
}
function K$($, X, W) {
    Object.defineProperty($, X, {
        get() {
            {
                let Y = W();
                return ($[X] = Y), Y;
            }
            throw new Error('cached value already set');
        },
        set(Y) {
            Object.defineProperty($, X, { value: Y });
        },
        configurable: !0,
    });
}
function SU($, X, W) {
    Object.defineProperty($, X, {
        value: W,
        writable: !0,
        enumerable: !0,
        configurable: !0,
    });
}
function tF($, X) {
    if (!X) return $;
    return X.reduce((W, Q) => W?.[Q], $);
}
function aF($) {
    let X = Object.keys($),
        W = X.map((Q) => $[Q]);
    return Promise.all(W).then((Q) => {
        let Y = {};
        for (let J = 0; J < X.length; J++) Y[X[J]] = Q[J];
        return Y;
    });
}
function sF($ = 10) {
    let W = '';
    for (let Q = 0; Q < $; Q++)
        W += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
    return W;
}
function f0($) {
    return JSON.stringify($);
}
var b8 = Error.captureStackTrace ? Error.captureStackTrace : (...$) => {};
function EX($) {
    return typeof $ === 'object' && $ !== null && !Array.isArray($);
}
var jU = bW(() => {
    if (
        typeof navigator !== 'undefined' &&
        navigator?.userAgent?.includes('Cloudflare')
    )
        return !1;
    try {
        return new Function(''), !0;
    } catch ($) {
        return !1;
    }
});
function xX($) {
    if (EX($) === !1) return !1;
    let X = $.constructor;
    if (X === void 0) return !0;
    let W = X.prototype;
    if (EX(W) === !1) return !1;
    if (Object.prototype.hasOwnProperty.call(W, 'isPrototypeOf') === !1)
        return !1;
    return !0;
}
function eF($) {
    let X = 0;
    for (let W in $) if (Object.prototype.hasOwnProperty.call($, W)) X++;
    return X;
}
var $I = ($) => {
        let X = typeof $;
        switch (X) {
            case 'undefined':
                return 'undefined';
            case 'string':
                return 'string';
            case 'number':
                return Number.isNaN($) ? 'nan' : 'number';
            case 'boolean':
                return 'boolean';
            case 'function':
                return 'function';
            case 'bigint':
                return 'bigint';
            case 'symbol':
                return 'symbol';
            case 'object':
                if (Array.isArray($)) return 'array';
                if ($ === null) return 'null';
                if (
                    $.then &&
                    typeof $.then === 'function' &&
                    $.catch &&
                    typeof $.catch === 'function'
                )
                    return 'promise';
                if (typeof Map !== 'undefined' && $ instanceof Map)
                    return 'map';
                if (typeof Set !== 'undefined' && $ instanceof Set)
                    return 'set';
                if (typeof Date !== 'undefined' && $ instanceof Date)
                    return 'date';
                if (typeof File !== 'undefined' && $ instanceof File)
                    return 'file';
                return 'object';
            default:
                throw new Error(`Unknown data type: ${X}`);
        }
    },
    TW = new Set(['string', 'number', 'symbol']),
    LU = new Set([
        'string',
        'number',
        'bigint',
        'boolean',
        'symbol',
        'undefined',
    ]);
function h1($) {
    return $.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function O4($, X, W) {
    let Q = new $._zod.constr(X ?? $._zod.def);
    if (!X || W?.parent) Q._zod.parent = $;
    return Q;
}
function v($) {
    let X = $;
    if (!X) return {};
    if (typeof X === 'string') return { error: () => X };
    if (X?.message !== void 0) {
        if (X?.error !== void 0)
            throw new Error('Cannot specify both `message` and `error` params');
        X.error = X.message;
    }
    if ((delete X.message, typeof X.error === 'string'))
        return { ...X, error: () => X.error };
    return X;
}
function XI($) {
    let X;
    return new Proxy(
        {},
        {
            get(W, Q, Y) {
                return X ?? (X = $()), Reflect.get(X, Q, Y);
            },
            set(W, Q, Y, J) {
                return X ?? (X = $()), Reflect.set(X, Q, Y, J);
            },
            has(W, Q) {
                return X ?? (X = $()), Reflect.has(X, Q);
            },
            deleteProperty(W, Q) {
                return X ?? (X = $()), Reflect.deleteProperty(X, Q);
            },
            ownKeys(W) {
                return X ?? (X = $()), Reflect.ownKeys(X);
            },
            getOwnPropertyDescriptor(W, Q) {
                return X ?? (X = $()), Reflect.getOwnPropertyDescriptor(X, Q);
            },
            defineProperty(W, Q, Y) {
                return X ?? (X = $()), Reflect.defineProperty(X, Q, Y);
            },
        },
    );
}
function h($) {
    if (typeof $ === 'bigint') return $.toString() + 'n';
    if (typeof $ === 'string') return `"${$}"`;
    return `${$}`;
}
function KU($) {
    return Object.keys($).filter((X) => {
        return (
            $[X]._zod.optin === 'optional' && $[X]._zod.optout === 'optional'
        );
    });
}
var _U = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-2147483648, 2147483647],
        uint32: [0, 4294967295],
        float32: [
            -340282346638528860000000000000000000000,
            340282346638528860000000000000000000000,
        ],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
    },
    FU = {
        int64: [BigInt('-9223372036854775808'), BigInt('9223372036854775807')],
        uint64: [BigInt(0), BigInt('18446744073709551615')],
    };
function WI($, X) {
    let W = {},
        Q = $._zod.def;
    for (let Y in X) {
        if (!(Y in Q.shape)) throw new Error(`Unrecognized key: "${Y}"`);
        if (!X[Y]) continue;
        W[Y] = Q.shape[Y];
    }
    return O4($, { ...$._zod.def, shape: W, checks: [] });
}
function YI($, X) {
    let W = { ...$._zod.def.shape },
        Q = $._zod.def;
    for (let Y in X) {
        if (!(Y in Q.shape)) throw new Error(`Unrecognized key: "${Y}"`);
        if (!X[Y]) continue;
        delete W[Y];
    }
    return O4($, { ...$._zod.def, shape: W, checks: [] });
}
function QI($, X) {
    if (!xX(X))
        throw new Error('Invalid input to extend: expected a plain object');
    let W = {
        ...$._zod.def,
        get shape() {
            let Q = { ...$._zod.def.shape, ...X };
            return SU(this, 'shape', Q), Q;
        },
        checks: [],
    };
    return O4($, W);
}
function JI($, X) {
    return O4($, {
        ...$._zod.def,
        get shape() {
            let W = { ...$._zod.def.shape, ...X._zod.def.shape };
            return SU(this, 'shape', W), W;
        },
        catchall: X._zod.def.catchall,
        checks: [],
    });
}
function UI($, X, W) {
    let Q = X._zod.def.shape,
        Y = { ...Q };
    if (W)
        for (let J in W) {
            if (!(J in Q)) throw new Error(`Unrecognized key: "${J}"`);
            if (!W[J]) continue;
            Y[J] = $ ? new $({ type: 'optional', innerType: Q[J] }) : Q[J];
        }
    else
        for (let J in Q)
            Y[J] = $ ? new $({ type: 'optional', innerType: Q[J] }) : Q[J];
    return O4(X, { ...X._zod.def, shape: Y, checks: [] });
}
function NI($, X, W) {
    let Q = X._zod.def.shape,
        Y = { ...Q };
    if (W)
        for (let J in W) {
            if (!(J in Y)) throw new Error(`Unrecognized key: "${J}"`);
            if (!W[J]) continue;
            Y[J] = new $({ type: 'nonoptional', innerType: Q[J] });
        }
    else
        for (let J in Q) Y[J] = new $({ type: 'nonoptional', innerType: Q[J] });
    return O4(X, { ...X._zod.def, shape: Y, checks: [] });
}
function y0($, X = 0) {
    for (let W = X; W < $.issues.length; W++)
        if ($.issues[W]?.continue !== !0) return !0;
    return !1;
}
function $4($, X) {
    return X.map((W) => {
        var Q;
        return (Q = W).path ?? (Q.path = []), W.path.unshift($), W;
    });
}
function EW($) {
    return typeof $ === 'string' ? $ : $?.message;
}
function H4($, X, W) {
    let Q = { ...$, path: $.path ?? [] };
    if (!$.message) {
        let Y =
            EW($.inst?._zod.def?.error?.($)) ??
            EW(X?.error?.($)) ??
            EW(W.customError?.($)) ??
            EW(W.localeError?.($)) ??
            'Invalid input';
        Q.message = Y;
    }
    if ((delete Q.inst, delete Q.continue, !X?.reportInput)) delete Q.input;
    return Q;
}
function kW($) {
    if ($ instanceof Set) return 'set';
    if ($ instanceof Map) return 'map';
    if ($ instanceof File) return 'file';
    return 'unknown';
}
function vW($) {
    if (Array.isArray($)) return 'array';
    if (typeof $ === 'string') return 'string';
    return 'unknown';
}
function IU(...$) {
    let [X, W, Q] = $;
    if (typeof X === 'string')
        return { message: X, code: 'custom', input: W, inst: Q };
    return { ...X };
}
function MI($) {
    return Object.entries($)
        .filter(([X, W]) => {
            return Number.isNaN(Number.parseInt(X, 10));
        })
        .map((X) => X[1]);
}
class Jw {
    constructor(...$) {}
}
var Uw = ($, X) => {
        ($.name = '$ZodError'),
            Object.defineProperty($, '_zod', { value: $._zod, enumerable: !1 }),
            Object.defineProperty($, 'issues', { value: X, enumerable: !1 }),
            Object.defineProperty($, 'message', {
                get() {
                    return JSON.stringify(X, AU, 2);
                },
                enumerable: !0,
            }),
            Object.defineProperty($, 'toString', {
                value: () => $.message,
                enumerable: !1,
            });
    },
    fW = L('$ZodError', Uw),
    bX = L('$ZodError', Uw, { Parent: Error });
function yW($, X = (W) => W.message) {
    let W = {},
        Q = [];
    for (let Y of $.issues)
        if (Y.path.length > 0)
            (W[Y.path[0]] = W[Y.path[0]] || []), W[Y.path[0]].push(X(Y));
        else Q.push(X(Y));
    return { formErrors: Q, fieldErrors: W };
}
function hW($, X) {
    let W =
            X ||
            function (J) {
                return J.message;
            },
        Q = { _errors: [] },
        Y = (J) => {
            for (let U of J.issues)
                if (U.code === 'invalid_union' && U.errors.length)
                    U.errors.map((N) => Y({ issues: N }));
                else if (U.code === 'invalid_key') Y({ issues: U.issues });
                else if (U.code === 'invalid_element') Y({ issues: U.issues });
                else if (U.path.length === 0) Q._errors.push(W(U));
                else {
                    let N = Q,
                        M = 0;
                    while (M < U.path.length) {
                        let G = U.path[M];
                        if (M !== U.path.length - 1)
                            N[G] = N[G] || { _errors: [] };
                        else
                            (N[G] = N[G] || { _errors: [] }),
                                N[G]._errors.push(W(U));
                        (N = N[G]), M++;
                    }
                }
        };
    return Y($), Q;
}
function CU($, X) {
    let W =
            X ||
            function (J) {
                return J.message;
            },
        Q = { errors: [] },
        Y = (J, U = []) => {
            var N, M;
            for (let G of J.issues)
                if (G.code === 'invalid_union' && G.errors.length)
                    G.errors.map((Z) => Y({ issues: Z }, G.path));
                else if (G.code === 'invalid_key')
                    Y({ issues: G.issues }, G.path);
                else if (G.code === 'invalid_element')
                    Y({ issues: G.issues }, G.path);
                else {
                    let Z = [...U, ...G.path];
                    if (Z.length === 0) {
                        Q.errors.push(W(G));
                        continue;
                    }
                    let B = Q,
                        O = 0;
                    while (O < Z.length) {
                        let w = Z[O],
                            z = O === Z.length - 1;
                        if (typeof w === 'string')
                            B.properties ?? (B.properties = {}),
                                (N = B.properties)[w] ??
                                    (N[w] = { errors: [] }),
                                (B = B.properties[w]);
                        else
                            B.items ?? (B.items = []),
                                (M = B.items)[w] ?? (M[w] = { errors: [] }),
                                (B = B.items[w]);
                        if (z) B.errors.push(W(G));
                        O++;
                    }
                }
        };
    return Y($), Q;
}
function Nw($) {
    let X = [];
    for (let W of $)
        if (typeof W === 'number') X.push(`[${W}]`);
        else if (typeof W === 'symbol')
            X.push(`[${JSON.stringify(String(W))}]`);
        else if (/[^\w$]/.test(W)) X.push(`[${JSON.stringify(W)}]`);
        else {
            if (X.length) X.push('.');
            X.push(W);
        }
    return X.join('');
}
function RU($) {
    let X = [],
        W = [...$.issues].sort((Q, Y) => Q.path.length - Y.path.length);
    for (let Q of W)
        if ((X.push(`\u2716 ${Q.message}`), Q.path?.length))
            X.push(`  \u2192 at ${Nw(Q.path)}`);
    return X.join(`
`);
}
var g8 = ($) => (X, W, Q, Y) => {
        let J = Q ? Object.assign(Q, { async: !1 }) : { async: !1 },
            U = X._zod.run({ value: W, issues: [] }, J);
        if (U instanceof Promise) throw new y1();
        if (U.issues.length) {
            let N = new (Y?.Err ?? $)(U.issues.map((M) => H4(M, J, z6())));
            throw (b8(N, Y?.callee), N);
        }
        return U.value;
    },
    T8 = g8(bX),
    k8 = ($) => async (X, W, Q, Y) => {
        let J = Q ? Object.assign(Q, { async: !0 }) : { async: !0 },
            U = X._zod.run({ value: W, issues: [] }, J);
        if (U instanceof Promise) U = await U;
        if (U.issues.length) {
            let N = new (Y?.Err ?? $)(U.issues.map((M) => H4(M, J, z6())));
            throw (b8(N, Y?.callee), N);
        }
        return U.value;
    },
    v8 = k8(bX),
    f8 = ($) => (X, W, Q) => {
        let Y = Q ? { ...Q, async: !1 } : { async: !1 },
            J = X._zod.run({ value: W, issues: [] }, Y);
        if (J instanceof Promise) throw new y1();
        return J.issues.length
            ? {
                  success: !1,
                  error: new ($ ?? fW)(J.issues.map((U) => H4(U, Y, z6()))),
              }
            : { success: !0, data: J.value };
    },
    VU = f8(bX),
    y8 = ($) => async (X, W, Q) => {
        let Y = Q ? Object.assign(Q, { async: !0 }) : { async: !0 },
            J = X._zod.run({ value: W, issues: [] }, Y);
        if (J instanceof Promise) J = await J;
        return J.issues.length
            ? { success: !1, error: new $(J.issues.map((U) => H4(U, Y, z6()))) }
            : { success: !0, data: J.value };
    },
    EU = y8(bX);
var m0 = {};
k6(m0, {
    xid: () => TU,
    uuid7: () => DI,
    uuid6: () => wI,
    uuid4: () => ZI,
    uuid: () => h0,
    uppercase: () => JN,
    unicodeEmail: () => HI,
    undefined: () => YN,
    ulid: () => gU,
    time: () => rU,
    string: () => aU,
    rfc5322Email: () => OI,
    number: () => $N,
    null: () => WN,
    nanoid: () => vU,
    lowercase: () => QN,
    ksuid: () => kU,
    ipv6: () => uU,
    ipv4: () => cU,
    integer: () => eU,
    html5Email: () => BI,
    hostname: () => pU,
    guid: () => yU,
    extendedDuration: () => zI,
    emoji: () => mU,
    email: () => hU,
    e164: () => lU,
    duration: () => fU,
    domain: () => AI,
    datetime: () => tU,
    date: () => oU,
    cuid2: () => bU,
    cuid: () => xU,
    cidrv6: () => iU,
    cidrv4: () => dU,
    browserEmail: () => qI,
    boolean: () => XN,
    bigint: () => sU,
    base64url: () => h8,
    base64: () => nU,
});
var xU = /^[cC][^\s-]{8,}$/,
    bU = /^[0-9a-z]+$/,
    gU = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
    TU = /^[0-9a-vA-V]{20}$/,
    kU = /^[A-Za-z0-9]{27}$/,
    vU = /^[a-zA-Z0-9_-]{21}$/,
    fU =
        /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
    zI =
        /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    yU =
        /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
    h0 = ($) => {
        if (!$)
            return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
        return new RegExp(
            `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${$}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
        );
    },
    ZI = h0(4),
    wI = h0(6),
    DI = h0(7),
    hU =
        /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
    BI =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    OI =
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    HI = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
    qI =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function mU() {
    return new RegExp(
        '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$',
        'u',
    );
}
var cU =
        /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    uU =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
    dU =
        /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
    iU =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    nU =
        /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
    h8 = /^[A-Za-z0-9_-]*$/,
    pU = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
    AI = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
    lU = /^\+(?:[0-9]){6,14}[0-9]$/,
    Mw =
        '(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))',
    oU = new RegExp(`^${Mw}$`);
function Gw($) {
    return typeof $.precision === 'number'
        ? $.precision === -1
            ? '(?:[01]\\d|2[0-3]):[0-5]\\d'
            : $.precision === 0
              ? '(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d'
              : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${$.precision}}`
        : '(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?';
}
function rU($) {
    return new RegExp(`^${Gw($)}$`);
}
function tU($) {
    let X = Gw({ precision: $.precision }),
        W = ['Z'];
    if ($.local) W.push('');
    if ($.offset) W.push('([+-]\\d{2}:\\d{2})');
    let Q = `${X}(?:${W.join('|')})`;
    return new RegExp(`^${Mw}T(?:${Q})$`);
}
var aU = ($) => {
        let X = $
            ? `[\\s\\S]{${$?.minimum ?? 0},${$?.maximum ?? ''}}`
            : '[\\s\\S]*';
        return new RegExp(`^${X}$`);
    },
    sU = /^\d+n?$/,
    eU = /^\d+$/,
    $N = /^-?\d+(?:\.\d+)?/i,
    XN = /true|false/i,
    WN = /null/i;
var YN = /undefined/i;
var QN = /^[^A-Z]*$/,
    JN = /^[^a-z]*$/;
var a$ = L('$ZodCheck', ($, X) => {
        var W;
        $._zod ?? ($._zod = {}),
            ($._zod.def = X),
            (W = $._zod).onattach ?? (W.onattach = []);
    }),
    Zw = { number: 'number', bigint: 'bigint', object: 'date' },
    m8 = L('$ZodCheckLessThan', ($, X) => {
        a$.init($, X);
        let W = Zw[typeof X.value];
        $._zod.onattach.push((Q) => {
            let Y = Q._zod.bag,
                J =
                    (X.inclusive ? Y.maximum : Y.exclusiveMaximum) ??
                    Number.POSITIVE_INFINITY;
            if (X.value < J)
                if (X.inclusive) Y.maximum = X.value;
                else Y.exclusiveMaximum = X.value;
        }),
            ($._zod.check = (Q) => {
                if (X.inclusive ? Q.value <= X.value : Q.value < X.value)
                    return;
                Q.issues.push({
                    origin: W,
                    code: 'too_big',
                    maximum: X.value,
                    input: Q.value,
                    inclusive: X.inclusive,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    c8 = L('$ZodCheckGreaterThan', ($, X) => {
        a$.init($, X);
        let W = Zw[typeof X.value];
        $._zod.onattach.push((Q) => {
            let Y = Q._zod.bag,
                J =
                    (X.inclusive ? Y.minimum : Y.exclusiveMinimum) ??
                    Number.NEGATIVE_INFINITY;
            if (X.value > J)
                if (X.inclusive) Y.minimum = X.value;
                else Y.exclusiveMinimum = X.value;
        }),
            ($._zod.check = (Q) => {
                if (X.inclusive ? Q.value >= X.value : Q.value > X.value)
                    return;
                Q.issues.push({
                    origin: W,
                    code: 'too_small',
                    minimum: X.value,
                    input: Q.value,
                    inclusive: X.inclusive,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    UN = L('$ZodCheckMultipleOf', ($, X) => {
        a$.init($, X),
            $._zod.onattach.push((W) => {
                var Q;
                (Q = W._zod.bag).multipleOf ?? (Q.multipleOf = X.value);
            }),
            ($._zod.check = (W) => {
                if (typeof W.value !== typeof X.value)
                    throw new Error(
                        'Cannot mix number and bigint in multiple_of check.',
                    );
                if (
                    typeof W.value === 'bigint'
                        ? W.value % X.value === BigInt(0)
                        : PU(W.value, X.value) === 0
                )
                    return;
                W.issues.push({
                    origin: typeof W.value,
                    code: 'not_multiple_of',
                    divisor: X.value,
                    input: W.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    NN = L('$ZodCheckNumberFormat', ($, X) => {
        a$.init($, X), (X.format = X.format || 'float64');
        let W = X.format?.includes('int'),
            Q = W ? 'int' : 'number',
            [Y, J] = _U[X.format];
        $._zod.onattach.push((U) => {
            let N = U._zod.bag;
            if (((N.format = X.format), (N.minimum = Y), (N.maximum = J), W))
                N.pattern = eU;
        }),
            ($._zod.check = (U) => {
                let N = U.value;
                if (W) {
                    if (!Number.isInteger(N)) {
                        U.issues.push({
                            expected: Q,
                            format: X.format,
                            code: 'invalid_type',
                            input: N,
                            inst: $,
                        });
                        return;
                    }
                    if (!Number.isSafeInteger(N)) {
                        if (N > 0)
                            U.issues.push({
                                input: N,
                                code: 'too_big',
                                maximum: Number.MAX_SAFE_INTEGER,
                                note: 'Integers must be within the safe integer range.',
                                inst: $,
                                origin: Q,
                                continue: !X.abort,
                            });
                        else
                            U.issues.push({
                                input: N,
                                code: 'too_small',
                                minimum: Number.MIN_SAFE_INTEGER,
                                note: 'Integers must be within the safe integer range.',
                                inst: $,
                                origin: Q,
                                continue: !X.abort,
                            });
                        return;
                    }
                }
                if (N < Y)
                    U.issues.push({
                        origin: 'number',
                        input: N,
                        code: 'too_small',
                        minimum: Y,
                        inclusive: !0,
                        inst: $,
                        continue: !X.abort,
                    });
                if (N > J)
                    U.issues.push({
                        origin: 'number',
                        input: N,
                        code: 'too_big',
                        maximum: J,
                        inst: $,
                    });
            });
    }),
    MN = L('$ZodCheckBigIntFormat', ($, X) => {
        a$.init($, X);
        let [W, Q] = FU[X.format];
        $._zod.onattach.push((Y) => {
            let J = Y._zod.bag;
            (J.format = X.format), (J.minimum = W), (J.maximum = Q);
        }),
            ($._zod.check = (Y) => {
                let J = Y.value;
                if (J < W)
                    Y.issues.push({
                        origin: 'bigint',
                        input: J,
                        code: 'too_small',
                        minimum: W,
                        inclusive: !0,
                        inst: $,
                        continue: !X.abort,
                    });
                if (J > Q)
                    Y.issues.push({
                        origin: 'bigint',
                        input: J,
                        code: 'too_big',
                        maximum: Q,
                        inst: $,
                    });
            });
    }),
    GN = L('$ZodCheckMaxSize', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.size !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
                if (X.maximum < Y) Q._zod.bag.maximum = X.maximum;
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value;
                if (Y.size <= X.maximum) return;
                Q.issues.push({
                    origin: kW(Y),
                    code: 'too_big',
                    maximum: X.maximum,
                    input: Y,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    zN = L('$ZodCheckMinSize', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.size !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
                if (X.minimum > Y) Q._zod.bag.minimum = X.minimum;
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value;
                if (Y.size >= X.minimum) return;
                Q.issues.push({
                    origin: kW(Y),
                    code: 'too_small',
                    minimum: X.minimum,
                    input: Y,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    ZN = L('$ZodCheckSizeEquals', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.size !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag;
                (Y.minimum = X.size), (Y.maximum = X.size), (Y.size = X.size);
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value,
                    J = Y.size;
                if (J === X.size) return;
                let U = J > X.size;
                Q.issues.push({
                    origin: kW(Y),
                    ...(U
                        ? { code: 'too_big', maximum: X.size }
                        : { code: 'too_small', minimum: X.size }),
                    inclusive: !0,
                    exact: !0,
                    input: Q.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    wN = L('$ZodCheckMaxLength', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.length !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
                if (X.maximum < Y) Q._zod.bag.maximum = X.maximum;
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value;
                if (Y.length <= X.maximum) return;
                let U = vW(Y);
                Q.issues.push({
                    origin: U,
                    code: 'too_big',
                    maximum: X.maximum,
                    inclusive: !0,
                    input: Y,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    DN = L('$ZodCheckMinLength', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.length !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
                if (X.minimum > Y) Q._zod.bag.minimum = X.minimum;
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value;
                if (Y.length >= X.minimum) return;
                let U = vW(Y);
                Q.issues.push({
                    origin: U,
                    code: 'too_small',
                    minimum: X.minimum,
                    inclusive: !0,
                    input: Y,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    BN = L('$ZodCheckLengthEquals', ($, X) => {
        var W;
        a$.init($, X),
            (W = $._zod.def).when ??
                (W.when = (Q) => {
                    let Y = Q.value;
                    return !B0(Y) && Y.length !== void 0;
                }),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag;
                (Y.minimum = X.length),
                    (Y.maximum = X.length),
                    (Y.length = X.length);
            }),
            ($._zod.check = (Q) => {
                let Y = Q.value,
                    J = Y.length;
                if (J === X.length) return;
                let U = vW(Y),
                    N = J > X.length;
                Q.issues.push({
                    origin: U,
                    ...(N
                        ? { code: 'too_big', maximum: X.length }
                        : { code: 'too_small', minimum: X.length }),
                    inclusive: !0,
                    exact: !0,
                    input: Q.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    gX = L('$ZodCheckStringFormat', ($, X) => {
        var W, Q;
        if (
            (a$.init($, X),
            $._zod.onattach.push((Y) => {
                let J = Y._zod.bag;
                if (((J.format = X.format), X.pattern))
                    J.patterns ?? (J.patterns = new Set()),
                        J.patterns.add(X.pattern);
            }),
            X.pattern)
        )
            (W = $._zod).check ??
                (W.check = (Y) => {
                    if (((X.pattern.lastIndex = 0), X.pattern.test(Y.value)))
                        return;
                    Y.issues.push({
                        origin: 'string',
                        code: 'invalid_format',
                        format: X.format,
                        input: Y.value,
                        ...(X.pattern ? { pattern: X.pattern.toString() } : {}),
                        inst: $,
                        continue: !X.abort,
                    });
                });
        else (Q = $._zod).check ?? (Q.check = () => {});
    }),
    ON = L('$ZodCheckRegex', ($, X) => {
        gX.init($, X),
            ($._zod.check = (W) => {
                if (((X.pattern.lastIndex = 0), X.pattern.test(W.value)))
                    return;
                W.issues.push({
                    origin: 'string',
                    code: 'invalid_format',
                    format: 'regex',
                    input: W.value,
                    pattern: X.pattern.toString(),
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    HN = L('$ZodCheckLowerCase', ($, X) => {
        X.pattern ?? (X.pattern = QN), gX.init($, X);
    }),
    qN = L('$ZodCheckUpperCase', ($, X) => {
        X.pattern ?? (X.pattern = JN), gX.init($, X);
    }),
    AN = L('$ZodCheckIncludes', ($, X) => {
        a$.init($, X);
        let W = h1(X.includes),
            Q = new RegExp(
                typeof X.position === 'number' ? `^.{${X.position}}${W}` : W,
            );
        (X.pattern = Q),
            $._zod.onattach.push((Y) => {
                let J = Y._zod.bag;
                J.patterns ?? (J.patterns = new Set()), J.patterns.add(Q);
            }),
            ($._zod.check = (Y) => {
                if (Y.value.includes(X.includes, X.position)) return;
                Y.issues.push({
                    origin: 'string',
                    code: 'invalid_format',
                    format: 'includes',
                    includes: X.includes,
                    input: Y.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    PN = L('$ZodCheckStartsWith', ($, X) => {
        a$.init($, X);
        let W = new RegExp(`^${h1(X.prefix)}.*`);
        X.pattern ?? (X.pattern = W),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag;
                Y.patterns ?? (Y.patterns = new Set()), Y.patterns.add(W);
            }),
            ($._zod.check = (Q) => {
                if (Q.value.startsWith(X.prefix)) return;
                Q.issues.push({
                    origin: 'string',
                    code: 'invalid_format',
                    format: 'starts_with',
                    prefix: X.prefix,
                    input: Q.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    SN = L('$ZodCheckEndsWith', ($, X) => {
        a$.init($, X);
        let W = new RegExp(`.*${h1(X.suffix)}$`);
        X.pattern ?? (X.pattern = W),
            $._zod.onattach.push((Q) => {
                let Y = Q._zod.bag;
                Y.patterns ?? (Y.patterns = new Set()), Y.patterns.add(W);
            }),
            ($._zod.check = (Q) => {
                if (Q.value.endsWith(X.suffix)) return;
                Q.issues.push({
                    origin: 'string',
                    code: 'invalid_format',
                    format: 'ends_with',
                    suffix: X.suffix,
                    input: Q.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    });
function zw($, X, W) {
    if ($.issues.length) X.issues.push(...$4(W, $.issues));
}
var jN = L('$ZodCheckProperty', ($, X) => {
        a$.init($, X),
            ($._zod.check = (W) => {
                let Q = X.schema._zod.run(
                    { value: W.value[X.property], issues: [] },
                    {},
                );
                if (Q instanceof Promise)
                    return Q.then((Y) => zw(Y, W, X.property));
                zw(Q, W, X.property);
                return;
            });
    }),
    LN = L('$ZodCheckMimeType', ($, X) => {
        a$.init($, X);
        let W = new Set(X.mime);
        $._zod.onattach.push((Q) => {
            Q._zod.bag.mime = X.mime;
        }),
            ($._zod.check = (Q) => {
                if (W.has(Q.value.type)) return;
                Q.issues.push({
                    code: 'invalid_value',
                    values: X.mime,
                    input: Q.value.type,
                    inst: $,
                });
            });
    }),
    KN = L('$ZodCheckOverwrite', ($, X) => {
        a$.init($, X),
            ($._zod.check = (W) => {
                W.value = X.tx(W.value);
            });
    });
class u8 {
    constructor($ = []) {
        if (((this.content = []), (this.indent = 0), this)) this.args = $;
    }
    indented($) {
        (this.indent += 1), $(this), (this.indent -= 1);
    }
    write($) {
        if (typeof $ === 'function') {
            $(this, { execution: 'sync' }), $(this, { execution: 'async' });
            return;
        }
        let W = $.split(`
`).filter((J) => J),
            Q = Math.min(...W.map((J) => J.length - J.trimStart().length)),
            Y = W.map((J) => J.slice(Q)).map(
                (J) => ' '.repeat(this.indent * 2) + J,
            );
        for (let J of Y) this.content.push(J);
    }
    compile() {
        let $ = Function,
            X = this?.args,
            Q = [...(this?.content ?? ['']).map((Y) => `  ${Y}`)];
        return new $(
            ...X,
            Q.join(`
`),
        );
    }
}
var _N = { major: 4, minor: 0, patch: 5 };
var s = L('$ZodType', ($, X) => {
        var W;
        $ ?? ($ = {}),
            ($._zod.def = X),
            ($._zod.bag = $._zod.bag || {}),
            ($._zod.version = _N);
        let Q = [...($._zod.def.checks ?? [])];
        if ($._zod.traits.has('$ZodCheck')) Q.unshift($);
        for (let Y of Q) for (let J of Y._zod.onattach) J($);
        if (Q.length === 0)
            (W = $._zod).deferred ?? (W.deferred = []),
                $._zod.deferred?.push(() => {
                    $._zod.run = $._zod.parse;
                });
        else {
            let Y = (J, U, N) => {
                let M = y0(J),
                    G;
                for (let Z of U) {
                    if (Z._zod.def.when) {
                        if (!Z._zod.def.when(J)) continue;
                    } else if (M) continue;
                    let B = J.issues.length,
                        O = Z._zod.check(J);
                    if (O instanceof Promise && N?.async === !1) throw new y1();
                    if (G || O instanceof Promise)
                        G = (G ?? Promise.resolve()).then(async () => {
                            if ((await O, J.issues.length === B)) return;
                            if (!M) M = y0(J, B);
                        });
                    else {
                        if (J.issues.length === B) continue;
                        if (!M) M = y0(J, B);
                    }
                }
                if (G)
                    return G.then(() => {
                        return J;
                    });
                return J;
            };
            $._zod.run = (J, U) => {
                let N = $._zod.parse(J, U);
                if (N instanceof Promise) {
                    if (U.async === !1) throw new y1();
                    return N.then((M) => Y(M, Q, U));
                }
                return Y(N, Q, U);
            };
        }
        $['~standard'] = {
            validate: (Y) => {
                try {
                    let J = VU($, Y);
                    return J.success
                        ? { value: J.data }
                        : { issues: J.error?.issues };
                } catch (J) {
                    return EU($, Y).then((U) =>
                        U.success
                            ? { value: U.data }
                            : { issues: U.error?.issues },
                    );
                }
            },
            vendor: 'zod',
            version: 1,
        };
    }),
    c0 = L('$ZodString', ($, X) => {
        s.init($, X),
            ($._zod.pattern =
                [...($?._zod.bag?.patterns ?? [])].pop() ?? aU($._zod.bag)),
            ($._zod.parse = (W, Q) => {
                if (X.coerce)
                    try {
                        W.value = String(W.value);
                    } catch (Y) {}
                if (typeof W.value === 'string') return W;
                return (
                    W.issues.push({
                        expected: 'string',
                        code: 'invalid_type',
                        input: W.value,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    T$ = L('$ZodStringFormat', ($, X) => {
        gX.init($, X), c0.init($, X);
    }),
    IN = L('$ZodGUID', ($, X) => {
        X.pattern ?? (X.pattern = yU), T$.init($, X);
    }),
    CN = L('$ZodUUID', ($, X) => {
        if (X.version) {
            let Q = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
                X.version
            ];
            if (Q === void 0)
                throw new Error(`Invalid UUID version: "${X.version}"`);
            X.pattern ?? (X.pattern = h0(Q));
        } else X.pattern ?? (X.pattern = h0());
        T$.init($, X);
    }),
    RN = L('$ZodEmail', ($, X) => {
        X.pattern ?? (X.pattern = hU), T$.init($, X);
    }),
    VN = L('$ZodURL', ($, X) => {
        T$.init($, X),
            ($._zod.check = (W) => {
                try {
                    let Q = W.value,
                        Y = new URL(Q),
                        J = Y.href;
                    if (X.hostname) {
                        if (
                            ((X.hostname.lastIndex = 0),
                            !X.hostname.test(Y.hostname))
                        )
                            W.issues.push({
                                code: 'invalid_format',
                                format: 'url',
                                note: 'Invalid hostname',
                                pattern: pU.source,
                                input: W.value,
                                inst: $,
                                continue: !X.abort,
                            });
                    }
                    if (X.protocol) {
                        if (
                            ((X.protocol.lastIndex = 0),
                            !X.protocol.test(
                                Y.protocol.endsWith(':')
                                    ? Y.protocol.slice(0, -1)
                                    : Y.protocol,
                            ))
                        )
                            W.issues.push({
                                code: 'invalid_format',
                                format: 'url',
                                note: 'Invalid protocol',
                                pattern: X.protocol.source,
                                input: W.value,
                                inst: $,
                                continue: !X.abort,
                            });
                    }
                    if (!Q.endsWith('/') && J.endsWith('/'))
                        W.value = J.slice(0, -1);
                    else W.value = J;
                    return;
                } catch (Q) {
                    W.issues.push({
                        code: 'invalid_format',
                        format: 'url',
                        input: W.value,
                        inst: $,
                        continue: !X.abort,
                    });
                }
            });
    }),
    EN = L('$ZodEmoji', ($, X) => {
        X.pattern ?? (X.pattern = mU()), T$.init($, X);
    }),
    xN = L('$ZodNanoID', ($, X) => {
        X.pattern ?? (X.pattern = vU), T$.init($, X);
    }),
    bN = L('$ZodCUID', ($, X) => {
        X.pattern ?? (X.pattern = xU), T$.init($, X);
    }),
    gN = L('$ZodCUID2', ($, X) => {
        X.pattern ?? (X.pattern = bU), T$.init($, X);
    }),
    TN = L('$ZodULID', ($, X) => {
        X.pattern ?? (X.pattern = gU), T$.init($, X);
    }),
    kN = L('$ZodXID', ($, X) => {
        X.pattern ?? (X.pattern = TU), T$.init($, X);
    }),
    vN = L('$ZodKSUID', ($, X) => {
        X.pattern ?? (X.pattern = kU), T$.init($, X);
    }),
    fN = L('$ZodISODateTime', ($, X) => {
        X.pattern ?? (X.pattern = tU(X)), T$.init($, X);
    }),
    yN = L('$ZodISODate', ($, X) => {
        X.pattern ?? (X.pattern = oU), T$.init($, X);
    }),
    hN = L('$ZodISOTime', ($, X) => {
        X.pattern ?? (X.pattern = rU(X)), T$.init($, X);
    }),
    mN = L('$ZodISODuration', ($, X) => {
        X.pattern ?? (X.pattern = fU), T$.init($, X);
    }),
    cN = L('$ZodIPv4', ($, X) => {
        X.pattern ?? (X.pattern = cU),
            T$.init($, X),
            $._zod.onattach.push((W) => {
                let Q = W._zod.bag;
                Q.format = 'ipv4';
            });
    }),
    uN = L('$ZodIPv6', ($, X) => {
        X.pattern ?? (X.pattern = uU),
            T$.init($, X),
            $._zod.onattach.push((W) => {
                let Q = W._zod.bag;
                Q.format = 'ipv6';
            }),
            ($._zod.check = (W) => {
                try {
                    new URL(`http://[${W.value}]`);
                } catch {
                    W.issues.push({
                        code: 'invalid_format',
                        format: 'ipv6',
                        input: W.value,
                        inst: $,
                        continue: !X.abort,
                    });
                }
            });
    }),
    dN = L('$ZodCIDRv4', ($, X) => {
        X.pattern ?? (X.pattern = dU), T$.init($, X);
    }),
    iN = L('$ZodCIDRv6', ($, X) => {
        X.pattern ?? (X.pattern = iU),
            T$.init($, X),
            ($._zod.check = (W) => {
                let [Q, Y] = W.value.split('/');
                try {
                    if (!Y) throw new Error();
                    let J = Number(Y);
                    if (`${J}` !== Y) throw new Error();
                    if (J < 0 || J > 128) throw new Error();
                    new URL(`http://[${Q}]`);
                } catch {
                    W.issues.push({
                        code: 'invalid_format',
                        format: 'cidrv6',
                        input: W.value,
                        inst: $,
                        continue: !X.abort,
                    });
                }
            });
    });
function nN($) {
    if ($ === '') return !0;
    if ($.length % 4 !== 0) return !1;
    try {
        return atob($), !0;
    } catch {
        return !1;
    }
}
var pN = L('$ZodBase64', ($, X) => {
    X.pattern ?? (X.pattern = nU),
        T$.init($, X),
        $._zod.onattach.push((W) => {
            W._zod.bag.contentEncoding = 'base64';
        }),
        ($._zod.check = (W) => {
            if (nN(W.value)) return;
            W.issues.push({
                code: 'invalid_format',
                format: 'base64',
                input: W.value,
                inst: $,
                continue: !X.abort,
            });
        });
});
function _w($) {
    if (!h8.test($)) return !1;
    let X = $.replace(/[-_]/g, (Q) => (Q === '-' ? '+' : '/')),
        W = X.padEnd(Math.ceil(X.length / 4) * 4, '=');
    return nN(W);
}
var lN = L('$ZodBase64URL', ($, X) => {
        X.pattern ?? (X.pattern = h8),
            T$.init($, X),
            $._zod.onattach.push((W) => {
                W._zod.bag.contentEncoding = 'base64url';
            }),
            ($._zod.check = (W) => {
                if (_w(W.value)) return;
                W.issues.push({
                    code: 'invalid_format',
                    format: 'base64url',
                    input: W.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    oN = L('$ZodE164', ($, X) => {
        X.pattern ?? (X.pattern = lU), T$.init($, X);
    });
function Fw($, X = null) {
    try {
        let W = $.split('.');
        if (W.length !== 3) return !1;
        let [Q] = W;
        if (!Q) return !1;
        let Y = JSON.parse(atob(Q));
        if ('typ' in Y && Y?.typ !== 'JWT') return !1;
        if (!Y.alg) return !1;
        if (X && (!('alg' in Y) || Y.alg !== X)) return !1;
        return !0;
    } catch {
        return !1;
    }
}
var rN = L('$ZodJWT', ($, X) => {
        T$.init($, X),
            ($._zod.check = (W) => {
                if (Fw(W.value, X.alg)) return;
                W.issues.push({
                    code: 'invalid_format',
                    format: 'jwt',
                    input: W.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    tN = L('$ZodCustomStringFormat', ($, X) => {
        T$.init($, X),
            ($._zod.check = (W) => {
                if (X.fn(W.value)) return;
                W.issues.push({
                    code: 'invalid_format',
                    format: X.format,
                    input: W.value,
                    inst: $,
                    continue: !X.abort,
                });
            });
    }),
    n8 = L('$ZodNumber', ($, X) => {
        s.init($, X),
            ($._zod.pattern = $._zod.bag.pattern ?? $N),
            ($._zod.parse = (W, Q) => {
                if (X.coerce)
                    try {
                        W.value = Number(W.value);
                    } catch (U) {}
                let Y = W.value;
                if (
                    typeof Y === 'number' &&
                    !Number.isNaN(Y) &&
                    Number.isFinite(Y)
                )
                    return W;
                let J =
                    typeof Y === 'number'
                        ? Number.isNaN(Y)
                            ? 'NaN'
                            : !Number.isFinite(Y)
                              ? 'Infinity'
                              : void 0
                        : void 0;
                return (
                    W.issues.push({
                        expected: 'number',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                        ...(J ? { received: J } : {}),
                    }),
                    W
                );
            });
    }),
    aN = L('$ZodNumber', ($, X) => {
        NN.init($, X), n8.init($, X);
    }),
    mW = L('$ZodBoolean', ($, X) => {
        s.init($, X),
            ($._zod.pattern = XN),
            ($._zod.parse = (W, Q) => {
                if (X.coerce)
                    try {
                        W.value = Boolean(W.value);
                    } catch (J) {}
                let Y = W.value;
                if (typeof Y === 'boolean') return W;
                return (
                    W.issues.push({
                        expected: 'boolean',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    p8 = L('$ZodBigInt', ($, X) => {
        s.init($, X),
            ($._zod.pattern = sU),
            ($._zod.parse = (W, Q) => {
                if (X.coerce)
                    try {
                        W.value = BigInt(W.value);
                    } catch (Y) {}
                if (typeof W.value === 'bigint') return W;
                return (
                    W.issues.push({
                        expected: 'bigint',
                        code: 'invalid_type',
                        input: W.value,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    sN = L('$ZodBigInt', ($, X) => {
        MN.init($, X), p8.init($, X);
    }),
    eN = L('$ZodSymbol', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (typeof Y === 'symbol') return W;
                return (
                    W.issues.push({
                        expected: 'symbol',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    $7 = L('$ZodUndefined', ($, X) => {
        s.init($, X),
            ($._zod.pattern = YN),
            ($._zod.values = new Set([void 0])),
            ($._zod.optin = 'optional'),
            ($._zod.optout = 'optional'),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (typeof Y === 'undefined') return W;
                return (
                    W.issues.push({
                        expected: 'undefined',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    X7 = L('$ZodNull', ($, X) => {
        s.init($, X),
            ($._zod.pattern = WN),
            ($._zod.values = new Set([null])),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (Y === null) return W;
                return (
                    W.issues.push({
                        expected: 'null',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    W7 = L('$ZodAny', ($, X) => {
        s.init($, X), ($._zod.parse = (W) => W);
    }),
    TX = L('$ZodUnknown', ($, X) => {
        s.init($, X), ($._zod.parse = (W) => W);
    }),
    Y7 = L('$ZodNever', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                return (
                    W.issues.push({
                        expected: 'never',
                        code: 'invalid_type',
                        input: W.value,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    Q7 = L('$ZodVoid', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (typeof Y === 'undefined') return W;
                return (
                    W.issues.push({
                        expected: 'void',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    J7 = L('$ZodDate', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                if (X.coerce)
                    try {
                        W.value = new Date(W.value);
                    } catch (N) {}
                let Y = W.value,
                    J = Y instanceof Date;
                if (J && !Number.isNaN(Y.getTime())) return W;
                return (
                    W.issues.push({
                        expected: 'date',
                        code: 'invalid_type',
                        input: Y,
                        ...(J ? { received: 'Invalid Date' } : {}),
                        inst: $,
                    }),
                    W
                );
            });
    });
function Dw($, X, W) {
    if ($.issues.length) X.issues.push(...$4(W, $.issues));
    X.value[W] = $.value;
}
var cW = L('$ZodArray', ($, X) => {
    s.init($, X),
        ($._zod.parse = (W, Q) => {
            let Y = W.value;
            if (!Array.isArray(Y))
                return (
                    W.issues.push({
                        expected: 'array',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            W.value = Array(Y.length);
            let J = [];
            for (let U = 0; U < Y.length; U++) {
                let N = Y[U],
                    M = X.element._zod.run({ value: N, issues: [] }, Q);
                if (M instanceof Promise) J.push(M.then((G) => Dw(G, W, U)));
                else Dw(M, W, U);
            }
            if (J.length) return Promise.all(J).then(() => W);
            return W;
        });
});
function d8($, X, W) {
    if ($.issues.length) X.issues.push(...$4(W, $.issues));
    X.value[W] = $.value;
}
function Bw($, X, W, Q) {
    if ($.issues.length)
        if (Q[W] === void 0)
            if (W in Q) X.value[W] = void 0;
            else X.value[W] = $.value;
        else X.issues.push(...$4(W, $.issues));
    else if ($.value === void 0) {
        if (W in Q) X.value[W] = void 0;
    } else X.value[W] = $.value;
}
var U7 = L('$ZodObject', ($, X) => {
    s.init($, X);
    let W = bW(() => {
        let B = Object.keys(X.shape);
        for (let w of B)
            if (!(X.shape[w] instanceof s))
                throw new Error(
                    `Invalid element at key "${w}": expected a Zod schema`,
                );
        let O = KU(X.shape);
        return {
            shape: X.shape,
            keys: B,
            keySet: new Set(B),
            numKeys: B.length,
            optionalKeys: new Set(O),
        };
    });
    K$($._zod, 'propValues', () => {
        let B = X.shape,
            O = {};
        for (let w in B) {
            let z = B[w]._zod;
            if (z.values) {
                O[w] ?? (O[w] = new Set());
                for (let H of z.values) O[w].add(H);
            }
        }
        return O;
    });
    let Q = (B) => {
            let O = new u8(['shape', 'payload', 'ctx']),
                w = W.value,
                z = (j) => {
                    let V = f0(j);
                    return `shape[${V}]._zod.run({ value: input[${V}], issues: [] }, ctx)`;
                };
            O.write('const input = payload.value;');
            let H = Object.create(null),
                P = 0;
            for (let j of w.keys) H[j] = `key_${P++}`;
            O.write('const newResult = {}');
            for (let j of w.keys)
                if (w.optionalKeys.has(j)) {
                    let V = H[j];
                    O.write(`const ${V} = ${z(j)};`);
                    let i = f0(j);
                    O.write(`
        if (${V}.issues.length) {
          if (input[${i}] === undefined) {
            if (${i} in input) {
              newResult[${i}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${V}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${i}, ...iss.path] : [${i}],
              }))
            );
          }
        } else if (${V}.value === undefined) {
          if (${i} in input) newResult[${i}] = undefined;
        } else {
          newResult[${i}] = ${V}.value;
        }
        `);
                } else {
                    let V = H[j];
                    O.write(`const ${V} = ${z(j)};`),
                        O.write(`
          if (${V}.issues.length) payload.issues = payload.issues.concat(${V}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${f0(j)}, ...iss.path] : [${f0(j)}]
          })));`),
                        O.write(`newResult[${f0(j)}] = ${V}.value`);
                }
            O.write('payload.value = newResult;'), O.write('return payload;');
            let E = O.compile();
            return (j, V) => E(B, j, V);
        },
        Y,
        J = EX,
        U = !VW.jitless,
        M = U && jU.value,
        G = X.catchall,
        Z;
    $._zod.parse = (B, O) => {
        Z ?? (Z = W.value);
        let w = B.value;
        if (!J(w))
            return (
                B.issues.push({
                    expected: 'object',
                    code: 'invalid_type',
                    input: w,
                    inst: $,
                }),
                B
            );
        let z = [];
        if (U && M && O?.async === !1 && O.jitless !== !0) {
            if (!Y) Y = Q(X.shape);
            B = Y(B, O);
        } else {
            B.value = {};
            let V = Z.shape;
            for (let i of Z.keys) {
                let $$ = V[i],
                    y = $$._zod.run({ value: w[i], issues: [] }, O),
                    n =
                        $$._zod.optin === 'optional' &&
                        $$._zod.optout === 'optional';
                if (y instanceof Promise)
                    z.push(y.then((k) => (n ? Bw(k, B, i, w) : d8(k, B, i))));
                else if (n) Bw(y, B, i, w);
                else d8(y, B, i);
            }
        }
        if (!G) return z.length ? Promise.all(z).then(() => B) : B;
        let H = [],
            P = Z.keySet,
            E = G._zod,
            j = E.def.type;
        for (let V of Object.keys(w)) {
            if (P.has(V)) continue;
            if (j === 'never') {
                H.push(V);
                continue;
            }
            let i = E.run({ value: w[V], issues: [] }, O);
            if (i instanceof Promise) z.push(i.then(($$) => d8($$, B, V)));
            else d8(i, B, V);
        }
        if (H.length)
            B.issues.push({
                code: 'unrecognized_keys',
                keys: H,
                input: w,
                inst: $,
            });
        if (!z.length) return B;
        return Promise.all(z).then(() => {
            return B;
        });
    };
});
function Ow($, X, W, Q) {
    for (let Y of $) if (Y.issues.length === 0) return (X.value = Y.value), X;
    return (
        X.issues.push({
            code: 'invalid_union',
            input: X.value,
            inst: W,
            errors: $.map((Y) => Y.issues.map((J) => H4(J, Q, z6()))),
        }),
        X
    );
}
var l8 = L('$ZodUnion', ($, X) => {
        s.init($, X),
            K$($._zod, 'optin', () =>
                X.options.some((W) => W._zod.optin === 'optional')
                    ? 'optional'
                    : void 0,
            ),
            K$($._zod, 'optout', () =>
                X.options.some((W) => W._zod.optout === 'optional')
                    ? 'optional'
                    : void 0,
            ),
            K$($._zod, 'values', () => {
                if (X.options.every((W) => W._zod.values))
                    return new Set(
                        X.options.flatMap((W) => Array.from(W._zod.values)),
                    );
                return;
            }),
            K$($._zod, 'pattern', () => {
                if (X.options.every((W) => W._zod.pattern)) {
                    let W = X.options.map((Q) => Q._zod.pattern);
                    return new RegExp(
                        `^(${W.map((Q) => gW(Q.source)).join('|')})$`,
                    );
                }
                return;
            }),
            ($._zod.parse = (W, Q) => {
                let Y = !1,
                    J = [];
                for (let U of X.options) {
                    let N = U._zod.run({ value: W.value, issues: [] }, Q);
                    if (N instanceof Promise) J.push(N), (Y = !0);
                    else {
                        if (N.issues.length === 0) return N;
                        J.push(N);
                    }
                }
                if (!Y) return Ow(J, W, $, Q);
                return Promise.all(J).then((U) => {
                    return Ow(U, W, $, Q);
                });
            });
    }),
    N7 = L('$ZodDiscriminatedUnion', ($, X) => {
        l8.init($, X);
        let W = $._zod.parse;
        K$($._zod, 'propValues', () => {
            let Y = {};
            for (let J of X.options) {
                let U = J._zod.propValues;
                if (!U || Object.keys(U).length === 0)
                    throw new Error(
                        `Invalid discriminated union option at index "${X.options.indexOf(J)}"`,
                    );
                for (let [N, M] of Object.entries(U)) {
                    if (!Y[N]) Y[N] = new Set();
                    for (let G of M) Y[N].add(G);
                }
            }
            return Y;
        });
        let Q = bW(() => {
            let Y = X.options,
                J = new Map();
            for (let U of Y) {
                let N = U._zod.propValues?.[X.discriminator];
                if (!N || N.size === 0)
                    throw new Error(
                        `Invalid discriminated union option at index "${X.options.indexOf(U)}"`,
                    );
                for (let M of N) {
                    if (J.has(M))
                        throw new Error(
                            `Duplicate discriminator value "${String(M)}"`,
                        );
                    J.set(M, U);
                }
            }
            return J;
        });
        $._zod.parse = (Y, J) => {
            let U = Y.value;
            if (!EX(U))
                return (
                    Y.issues.push({
                        code: 'invalid_type',
                        expected: 'object',
                        input: U,
                        inst: $,
                    }),
                    Y
                );
            let N = Q.value.get(U?.[X.discriminator]);
            if (N) return N._zod.run(Y, J);
            if (X.unionFallback) return W(Y, J);
            return (
                Y.issues.push({
                    code: 'invalid_union',
                    errors: [],
                    note: 'No matching discriminator',
                    input: U,
                    path: [X.discriminator],
                    inst: $,
                }),
                Y
            );
        };
    }),
    M7 = L('$ZodIntersection', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value,
                    J = X.left._zod.run({ value: Y, issues: [] }, Q),
                    U = X.right._zod.run({ value: Y, issues: [] }, Q);
                if (J instanceof Promise || U instanceof Promise)
                    return Promise.all([J, U]).then(([M, G]) => {
                        return Hw(W, M, G);
                    });
                return Hw(W, J, U);
            });
    });
function FN($, X) {
    if ($ === X) return { valid: !0, data: $ };
    if ($ instanceof Date && X instanceof Date && +$ === +X)
        return { valid: !0, data: $ };
    if (xX($) && xX(X)) {
        let W = Object.keys(X),
            Q = Object.keys($).filter((J) => W.indexOf(J) !== -1),
            Y = { ...$, ...X };
        for (let J of Q) {
            let U = FN($[J], X[J]);
            if (!U.valid)
                return { valid: !1, mergeErrorPath: [J, ...U.mergeErrorPath] };
            Y[J] = U.data;
        }
        return { valid: !0, data: Y };
    }
    if (Array.isArray($) && Array.isArray(X)) {
        if ($.length !== X.length) return { valid: !1, mergeErrorPath: [] };
        let W = [];
        for (let Q = 0; Q < $.length; Q++) {
            let Y = $[Q],
                J = X[Q],
                U = FN(Y, J);
            if (!U.valid)
                return { valid: !1, mergeErrorPath: [Q, ...U.mergeErrorPath] };
            W.push(U.data);
        }
        return { valid: !0, data: W };
    }
    return { valid: !1, mergeErrorPath: [] };
}
function Hw($, X, W) {
    if (X.issues.length) $.issues.push(...X.issues);
    if (W.issues.length) $.issues.push(...W.issues);
    if (y0($)) return $;
    let Q = FN(X.value, W.value);
    if (!Q.valid)
        throw new Error(
            `Unmergable intersection. Error path: ${JSON.stringify(Q.mergeErrorPath)}`,
        );
    return ($.value = Q.data), $;
}
var u0 = L('$ZodTuple', ($, X) => {
    s.init($, X);
    let W = X.items,
        Q =
            W.length -
            [...W].reverse().findIndex((Y) => Y._zod.optin !== 'optional');
    $._zod.parse = (Y, J) => {
        let U = Y.value;
        if (!Array.isArray(U))
            return (
                Y.issues.push({
                    input: U,
                    inst: $,
                    expected: 'tuple',
                    code: 'invalid_type',
                }),
                Y
            );
        Y.value = [];
        let N = [];
        if (!X.rest) {
            let G = U.length > W.length,
                Z = U.length < Q - 1;
            if (G || Z)
                return (
                    Y.issues.push({
                        input: U,
                        inst: $,
                        origin: 'array',
                        ...(G
                            ? { code: 'too_big', maximum: W.length }
                            : { code: 'too_small', minimum: W.length }),
                    }),
                    Y
                );
        }
        let M = -1;
        for (let G of W) {
            if ((M++, M >= U.length)) {
                if (M >= Q) continue;
            }
            let Z = G._zod.run({ value: U[M], issues: [] }, J);
            if (Z instanceof Promise) N.push(Z.then((B) => i8(B, Y, M)));
            else i8(Z, Y, M);
        }
        if (X.rest) {
            let G = U.slice(W.length);
            for (let Z of G) {
                M++;
                let B = X.rest._zod.run({ value: Z, issues: [] }, J);
                if (B instanceof Promise) N.push(B.then((O) => i8(O, Y, M)));
                else i8(B, Y, M);
            }
        }
        if (N.length) return Promise.all(N).then(() => Y);
        return Y;
    };
});
function i8($, X, W) {
    if ($.issues.length) X.issues.push(...$4(W, $.issues));
    X.value[W] = $.value;
}
var G7 = L('$ZodRecord', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (!xX(Y))
                    return (
                        W.issues.push({
                            expected: 'record',
                            code: 'invalid_type',
                            input: Y,
                            inst: $,
                        }),
                        W
                    );
                let J = [];
                if (X.keyType._zod.values) {
                    let U = X.keyType._zod.values;
                    W.value = {};
                    for (let M of U)
                        if (
                            typeof M === 'string' ||
                            typeof M === 'number' ||
                            typeof M === 'symbol'
                        ) {
                            let G = X.valueType._zod.run(
                                { value: Y[M], issues: [] },
                                Q,
                            );
                            if (G instanceof Promise)
                                J.push(
                                    G.then((Z) => {
                                        if (Z.issues.length)
                                            W.issues.push(...$4(M, Z.issues));
                                        W.value[M] = Z.value;
                                    }),
                                );
                            else {
                                if (G.issues.length)
                                    W.issues.push(...$4(M, G.issues));
                                W.value[M] = G.value;
                            }
                        }
                    let N;
                    for (let M in Y) if (!U.has(M)) (N = N ?? []), N.push(M);
                    if (N && N.length > 0)
                        W.issues.push({
                            code: 'unrecognized_keys',
                            input: Y,
                            inst: $,
                            keys: N,
                        });
                } else {
                    W.value = {};
                    for (let U of Reflect.ownKeys(Y)) {
                        if (U === '__proto__') continue;
                        let N = X.keyType._zod.run({ value: U, issues: [] }, Q);
                        if (N instanceof Promise)
                            throw new Error(
                                'Async schemas not supported in object keys currently',
                            );
                        if (N.issues.length) {
                            W.issues.push({
                                origin: 'record',
                                code: 'invalid_key',
                                issues: N.issues.map((G) => H4(G, Q, z6())),
                                input: U,
                                path: [U],
                                inst: $,
                            }),
                                (W.value[N.value] = N.value);
                            continue;
                        }
                        let M = X.valueType._zod.run(
                            { value: Y[U], issues: [] },
                            Q,
                        );
                        if (M instanceof Promise)
                            J.push(
                                M.then((G) => {
                                    if (G.issues.length)
                                        W.issues.push(...$4(U, G.issues));
                                    W.value[N.value] = G.value;
                                }),
                            );
                        else {
                            if (M.issues.length)
                                W.issues.push(...$4(U, M.issues));
                            W.value[N.value] = M.value;
                        }
                    }
                }
                if (J.length) return Promise.all(J).then(() => W);
                return W;
            });
    }),
    z7 = L('$ZodMap', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (!(Y instanceof Map))
                    return (
                        W.issues.push({
                            expected: 'map',
                            code: 'invalid_type',
                            input: Y,
                            inst: $,
                        }),
                        W
                    );
                let J = [];
                W.value = new Map();
                for (let [U, N] of Y) {
                    let M = X.keyType._zod.run({ value: U, issues: [] }, Q),
                        G = X.valueType._zod.run({ value: N, issues: [] }, Q);
                    if (M instanceof Promise || G instanceof Promise)
                        J.push(
                            Promise.all([M, G]).then(([Z, B]) => {
                                qw(Z, B, W, U, Y, $, Q);
                            }),
                        );
                    else qw(M, G, W, U, Y, $, Q);
                }
                if (J.length) return Promise.all(J).then(() => W);
                return W;
            });
    });
function qw($, X, W, Q, Y, J, U) {
    if ($.issues.length)
        if (TW.has(typeof Q)) W.issues.push(...$4(Q, $.issues));
        else
            W.issues.push({
                origin: 'map',
                code: 'invalid_key',
                input: Y,
                inst: J,
                issues: $.issues.map((N) => H4(N, U, z6())),
            });
    if (X.issues.length)
        if (TW.has(typeof Q)) W.issues.push(...$4(Q, X.issues));
        else
            W.issues.push({
                origin: 'map',
                code: 'invalid_element',
                input: Y,
                inst: J,
                key: Q,
                issues: X.issues.map((N) => H4(N, U, z6())),
            });
    W.value.set($.value, X.value);
}
var Z7 = L('$ZodSet', ($, X) => {
    s.init($, X),
        ($._zod.parse = (W, Q) => {
            let Y = W.value;
            if (!(Y instanceof Set))
                return (
                    W.issues.push({
                        input: Y,
                        inst: $,
                        expected: 'set',
                        code: 'invalid_type',
                    }),
                    W
                );
            let J = [];
            W.value = new Set();
            for (let U of Y) {
                let N = X.valueType._zod.run({ value: U, issues: [] }, Q);
                if (N instanceof Promise) J.push(N.then((M) => Aw(M, W)));
                else Aw(N, W);
            }
            if (J.length) return Promise.all(J).then(() => W);
            return W;
        });
});
function Aw($, X) {
    if ($.issues.length) X.issues.push(...$.issues);
    X.value.add($.value);
}
var w7 = L('$ZodEnum', ($, X) => {
        s.init($, X);
        let W = xW(X.entries);
        ($._zod.values = new Set(W)),
            ($._zod.pattern = new RegExp(
                `^(${W.filter((Q) => TW.has(typeof Q))
                    .map((Q) => (typeof Q === 'string' ? h1(Q) : Q.toString()))
                    .join('|')})$`,
            )),
            ($._zod.parse = (Q, Y) => {
                let J = Q.value;
                if ($._zod.values.has(J)) return Q;
                return (
                    Q.issues.push({
                        code: 'invalid_value',
                        values: W,
                        input: J,
                        inst: $,
                    }),
                    Q
                );
            });
    }),
    D7 = L('$ZodLiteral', ($, X) => {
        s.init($, X),
            ($._zod.values = new Set(X.values)),
            ($._zod.pattern = new RegExp(
                `^(${X.values.map((W) => (typeof W === 'string' ? h1(W) : W ? W.toString() : String(W))).join('|')})$`,
            )),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if ($._zod.values.has(Y)) return W;
                return (
                    W.issues.push({
                        code: 'invalid_value',
                        values: X.values,
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    B7 = L('$ZodFile', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = W.value;
                if (Y instanceof File) return W;
                return (
                    W.issues.push({
                        expected: 'file',
                        code: 'invalid_type',
                        input: Y,
                        inst: $,
                    }),
                    W
                );
            });
    }),
    uW = L('$ZodTransform', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = X.transform(W.value, W);
                if (Q.async)
                    return (Y instanceof Promise ? Y : Promise.resolve(Y)).then(
                        (U) => {
                            return (W.value = U), W;
                        },
                    );
                if (Y instanceof Promise) throw new y1();
                return (W.value = Y), W;
            });
    }),
    O7 = L('$ZodOptional', ($, X) => {
        s.init($, X),
            ($._zod.optin = 'optional'),
            ($._zod.optout = 'optional'),
            K$($._zod, 'values', () => {
                return X.innerType._zod.values
                    ? new Set([...X.innerType._zod.values, void 0])
                    : void 0;
            }),
            K$($._zod, 'pattern', () => {
                let W = X.innerType._zod.pattern;
                return W ? new RegExp(`^(${gW(W.source)})?$`) : void 0;
            }),
            ($._zod.parse = (W, Q) => {
                if (X.innerType._zod.optin === 'optional')
                    return X.innerType._zod.run(W, Q);
                if (W.value === void 0) return W;
                return X.innerType._zod.run(W, Q);
            });
    }),
    H7 = L('$ZodNullable', ($, X) => {
        s.init($, X),
            K$($._zod, 'optin', () => X.innerType._zod.optin),
            K$($._zod, 'optout', () => X.innerType._zod.optout),
            K$($._zod, 'pattern', () => {
                let W = X.innerType._zod.pattern;
                return W ? new RegExp(`^(${gW(W.source)}|null)$`) : void 0;
            }),
            K$($._zod, 'values', () => {
                return X.innerType._zod.values
                    ? new Set([...X.innerType._zod.values, null])
                    : void 0;
            }),
            ($._zod.parse = (W, Q) => {
                if (W.value === null) return W;
                return X.innerType._zod.run(W, Q);
            });
    }),
    q7 = L('$ZodDefault', ($, X) => {
        s.init($, X),
            ($._zod.optin = 'optional'),
            K$($._zod, 'values', () => X.innerType._zod.values),
            ($._zod.parse = (W, Q) => {
                if (W.value === void 0) return (W.value = X.defaultValue), W;
                let Y = X.innerType._zod.run(W, Q);
                if (Y instanceof Promise) return Y.then((J) => Pw(J, X));
                return Pw(Y, X);
            });
    });
function Pw($, X) {
    if ($.value === void 0) $.value = X.defaultValue;
    return $;
}
var A7 = L('$ZodPrefault', ($, X) => {
        s.init($, X),
            ($._zod.optin = 'optional'),
            K$($._zod, 'values', () => X.innerType._zod.values),
            ($._zod.parse = (W, Q) => {
                if (W.value === void 0) W.value = X.defaultValue;
                return X.innerType._zod.run(W, Q);
            });
    }),
    P7 = L('$ZodNonOptional', ($, X) => {
        s.init($, X),
            K$($._zod, 'values', () => {
                let W = X.innerType._zod.values;
                return W ? new Set([...W].filter((Q) => Q !== void 0)) : void 0;
            }),
            ($._zod.parse = (W, Q) => {
                let Y = X.innerType._zod.run(W, Q);
                if (Y instanceof Promise) return Y.then((J) => Sw(J, $));
                return Sw(Y, $);
            });
    });
function Sw($, X) {
    if (!$.issues.length && $.value === void 0)
        $.issues.push({
            code: 'invalid_type',
            expected: 'nonoptional',
            input: $.value,
            inst: X,
        });
    return $;
}
var S7 = L('$ZodSuccess', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                let Y = X.innerType._zod.run(W, Q);
                if (Y instanceof Promise)
                    return Y.then((J) => {
                        return (W.value = J.issues.length === 0), W;
                    });
                return (W.value = Y.issues.length === 0), W;
            });
    }),
    j7 = L('$ZodCatch', ($, X) => {
        s.init($, X),
            ($._zod.optin = 'optional'),
            K$($._zod, 'optout', () => X.innerType._zod.optout),
            K$($._zod, 'values', () => X.innerType._zod.values),
            ($._zod.parse = (W, Q) => {
                let Y = X.innerType._zod.run(W, Q);
                if (Y instanceof Promise)
                    return Y.then((J) => {
                        if (((W.value = J.value), J.issues.length))
                            (W.value = X.catchValue({
                                ...W,
                                error: {
                                    issues: J.issues.map((U) => H4(U, Q, z6())),
                                },
                                input: W.value,
                            })),
                                (W.issues = []);
                        return W;
                    });
                if (((W.value = Y.value), Y.issues.length))
                    (W.value = X.catchValue({
                        ...W,
                        error: { issues: Y.issues.map((J) => H4(J, Q, z6())) },
                        input: W.value,
                    })),
                        (W.issues = []);
                return W;
            });
    }),
    L7 = L('$ZodNaN', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                if (typeof W.value !== 'number' || !Number.isNaN(W.value))
                    return (
                        W.issues.push({
                            input: W.value,
                            inst: $,
                            expected: 'nan',
                            code: 'invalid_type',
                        }),
                        W
                    );
                return W;
            });
    }),
    dW = L('$ZodPipe', ($, X) => {
        s.init($, X),
            K$($._zod, 'values', () => X.in._zod.values),
            K$($._zod, 'optin', () => X.in._zod.optin),
            K$($._zod, 'optout', () => X.out._zod.optout),
            K$($._zod, 'propValues', () => X.in._zod.propValues),
            ($._zod.parse = (W, Q) => {
                let Y = X.in._zod.run(W, Q);
                if (Y instanceof Promise) return Y.then((J) => jw(J, X, Q));
                return jw(Y, X, Q);
            });
    });
function jw($, X, W) {
    if (y0($)) return $;
    return X.out._zod.run({ value: $.value, issues: $.issues }, W);
}
var K7 = L('$ZodReadonly', ($, X) => {
    s.init($, X),
        K$($._zod, 'propValues', () => X.innerType._zod.propValues),
        K$($._zod, 'values', () => X.innerType._zod.values),
        K$($._zod, 'optin', () => X.innerType._zod.optin),
        K$($._zod, 'optout', () => X.innerType._zod.optout),
        ($._zod.parse = (W, Q) => {
            let Y = X.innerType._zod.run(W, Q);
            if (Y instanceof Promise) return Y.then(Lw);
            return Lw(Y);
        });
});
function Lw($) {
    return ($.value = Object.freeze($.value)), $;
}
var _7 = L('$ZodTemplateLiteral', ($, X) => {
        s.init($, X);
        let W = [];
        for (let Q of X.parts)
            if (Q instanceof s) {
                if (!Q._zod.pattern)
                    throw new Error(
                        `Invalid template literal part, no pattern found: ${[...Q._zod.traits].shift()}`,
                    );
                let Y =
                    Q._zod.pattern instanceof RegExp
                        ? Q._zod.pattern.source
                        : Q._zod.pattern;
                if (!Y)
                    throw new Error(
                        `Invalid template literal part: ${Q._zod.traits}`,
                    );
                let J = Y.startsWith('^') ? 1 : 0,
                    U = Y.endsWith('$') ? Y.length - 1 : Y.length;
                W.push(Y.slice(J, U));
            } else if (Q === null || LU.has(typeof Q)) W.push(h1(`${Q}`));
            else throw new Error(`Invalid template literal part: ${Q}`);
        ($._zod.pattern = new RegExp(`^${W.join('')}$`)),
            ($._zod.parse = (Q, Y) => {
                if (typeof Q.value !== 'string')
                    return (
                        Q.issues.push({
                            input: Q.value,
                            inst: $,
                            expected: 'template_literal',
                            code: 'invalid_type',
                        }),
                        Q
                    );
                if (
                    (($._zod.pattern.lastIndex = 0),
                    !$._zod.pattern.test(Q.value))
                )
                    return (
                        Q.issues.push({
                            input: Q.value,
                            inst: $,
                            code: 'invalid_format',
                            format: X.format ?? 'template_literal',
                            pattern: $._zod.pattern.source,
                        }),
                        Q
                    );
                return Q;
            });
    }),
    F7 = L('$ZodPromise', ($, X) => {
        s.init($, X),
            ($._zod.parse = (W, Q) => {
                return Promise.resolve(W.value).then((Y) =>
                    X.innerType._zod.run({ value: Y, issues: [] }, Q),
                );
            });
    }),
    I7 = L('$ZodLazy', ($, X) => {
        s.init($, X),
            K$($._zod, 'innerType', () => X.getter()),
            K$($._zod, 'pattern', () => $._zod.innerType._zod.pattern),
            K$($._zod, 'propValues', () => $._zod.innerType._zod.propValues),
            K$($._zod, 'optin', () => $._zod.innerType._zod.optin),
            K$($._zod, 'optout', () => $._zod.innerType._zod.optout),
            ($._zod.parse = (W, Q) => {
                return $._zod.innerType._zod.run(W, Q);
            });
    }),
    C7 = L('$ZodCustom', ($, X) => {
        a$.init($, X),
            s.init($, X),
            ($._zod.parse = (W, Q) => {
                return W;
            }),
            ($._zod.check = (W) => {
                let Q = W.value,
                    Y = X.fn(Q);
                if (Y instanceof Promise) return Y.then((J) => Kw(J, W, Q, $));
                Kw(Y, W, Q, $);
                return;
            });
    });
function Kw($, X, W, Q) {
    if (!$) {
        let Y = {
            code: 'custom',
            input: W,
            inst: Q,
            path: [...(Q._zod.def.path ?? [])],
            continue: !Q._zod.def.abort,
        };
        if (Q._zod.def.params) Y.params = Q._zod.def.params;
        X.issues.push(IU(Y));
    }
}
var nW = {};
k6(nW, {
    zhTW: () => Z5,
    zhCN: () => z5,
    vi: () => G5,
    ur: () => M5,
    ua: () => N5,
    tr: () => U5,
    th: () => J5,
    ta: () => Q5,
    sv: () => Y5,
    sl: () => W5,
    ru: () => X5,
    pt: () => $5,
    ps: () => s7,
    pl: () => e7,
    ota: () => a7,
    no: () => t7,
    nl: () => r7,
    ms: () => o7,
    mk: () => l7,
    ko: () => p7,
    kh: () => n7,
    ja: () => i7,
    it: () => d7,
    id: () => u7,
    hu: () => c7,
    he: () => m7,
    frCA: () => h7,
    fr: () => y7,
    fi: () => f7,
    fa: () => v7,
    es: () => k7,
    eo: () => T7,
    en: () => iW,
    de: () => g7,
    cs: () => b7,
    ca: () => x7,
    be: () => E7,
    az: () => V7,
    ar: () => R7,
});
var PI = () => {
    let $ = {
        string: {
            unit: '\u062D\u0631\u0641',
            verb: '\u0623\u0646 \u064A\u062D\u0648\u064A',
        },
        file: {
            unit: '\u0628\u0627\u064A\u062A',
            verb: '\u0623\u0646 \u064A\u062D\u0648\u064A',
        },
        array: {
            unit: '\u0639\u0646\u0635\u0631',
            verb: '\u0623\u0646 \u064A\u062D\u0648\u064A',
        },
        set: {
            unit: '\u0639\u0646\u0635\u0631',
            verb: '\u0623\u0646 \u064A\u062D\u0648\u064A',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0645\u062F\u062E\u0644',
            email: '\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A',
            url: '\u0631\u0627\u0628\u0637',
            emoji: '\u0625\u064A\u0645\u0648\u062C\u064A',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO',
            date: '\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO',
            time: '\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO',
            duration:
                '\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO',
            ipv4: '\u0639\u0646\u0648\u0627\u0646 IPv4',
            ipv6: '\u0639\u0646\u0648\u0627\u0646 IPv6',
            cidrv4: '\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4',
            cidrv6: '\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6',
            base64: '\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded',
            base64url:
                '\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded',
            json_string:
                '\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON',
            e164: '\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164',
            jwt: 'JWT',
            template_literal: '\u0645\u062F\u062E\u0644',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${Y.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${h(Y.values[0])}`;
                return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${Y.origin ?? '\u0627\u0644\u0642\u064A\u0645\u0629'} ${J} ${Y.maximum.toString()} ${U.unit ?? '\u0639\u0646\u0635\u0631'}`;
                return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${Y.origin ?? '\u0627\u0644\u0642\u064A\u0645\u0629'} ${J} ${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${Y.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${J} ${Y.minimum.toString()} ${U.unit}`;
                return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${Y.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${J} ${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${Y.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
            }
            case 'not_multiple_of':
                return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u0645\u0639\u0631\u0641${Y.keys.length > 1 ? '\u0627\u062A' : ''} \u063A\u0631\u064A\u0628${Y.keys.length > 1 ? '\u0629' : ''}: ${C(Y.keys, '\u060C ')}`;
            case 'invalid_key':
                return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${Y.origin}`;
            case 'invalid_union':
                return '\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644';
            case 'invalid_element':
                return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${Y.origin}`;
            default:
                return '\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644';
        }
    };
};
function R7() {
    return { localeError: PI() };
}
var SI = () => {
    let $ = {
        string: { unit: 'simvol', verb: 'olmal\u0131d\u0131r' },
        file: { unit: 'bayt', verb: 'olmal\u0131d\u0131r' },
        array: { unit: 'element', verb: 'olmal\u0131d\u0131r' },
        set: { unit: 'element', verb: 'olmal\u0131d\u0131r' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'input',
            email: 'email address',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO datetime',
            date: 'ISO date',
            time: 'ISO time',
            duration: 'ISO duration',
            ipv4: 'IPv4 address',
            ipv6: 'IPv6 address',
            cidrv4: 'IPv4 range',
            cidrv6: 'IPv6 range',
            base64: 'base64-encoded string',
            base64url: 'base64url-encoded string',
            json_string: 'JSON string',
            e164: 'E.164 number',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${Y.expected}, daxil olan ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${h(Y.values[0])}`;
                return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${Y.origin ?? 'd\u0259y\u0259r'} ${J}${Y.maximum.toString()} ${U.unit ?? 'element'}`;
                return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${Y.origin ?? 'd\u0259y\u0259r'} ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${Y.origin} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${Y.origin} ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Yanl\u0131\u015F m\u0259tn: "${J.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
                if (J.format === 'ends_with')
                    return `Yanl\u0131\u015F m\u0259tn: "${J.suffix}" il\u0259 bitm\u0259lidir`;
                if (J.format === 'includes')
                    return `Yanl\u0131\u015F m\u0259tn: "${J.includes}" daxil olmal\u0131d\u0131r`;
                if (J.format === 'regex')
                    return `Yanl\u0131\u015F m\u0259tn: ${J.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
                return `Yanl\u0131\u015F ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Yanl\u0131\u015F \u0259d\u0259d: ${Y.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
            case 'unrecognized_keys':
                return `Tan\u0131nmayan a\xE7ar${Y.keys.length > 1 ? 'lar' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `${Y.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
            case 'invalid_union':
                return 'Yanl\u0131\u015F d\u0259y\u0259r';
            case 'invalid_element':
                return `${Y.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
            default:
                return 'Yanl\u0131\u015F d\u0259y\u0259r';
        }
    };
};
function V7() {
    return { localeError: SI() };
}
function Cw($, X, W, Q) {
    let Y = Math.abs($),
        J = Y % 10,
        U = Y % 100;
    if (U >= 11 && U <= 19) return Q;
    if (J === 1) return X;
    if (J >= 2 && J <= 4) return W;
    return Q;
}
var jI = () => {
    let $ = {
        string: {
            unit: {
                one: '\u0441\u0456\u043C\u0432\u0430\u043B',
                few: '\u0441\u0456\u043C\u0432\u0430\u043B\u044B',
                many: '\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E',
            },
            verb: '\u043C\u0435\u0446\u044C',
        },
        array: {
            unit: {
                one: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442',
                few: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B',
                many: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E',
            },
            verb: '\u043C\u0435\u0446\u044C',
        },
        set: {
            unit: {
                one: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442',
                few: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B',
                many: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E',
            },
            verb: '\u043C\u0435\u0446\u044C',
        },
        file: {
            unit: {
                one: '\u0431\u0430\u0439\u0442',
                few: '\u0431\u0430\u0439\u0442\u044B',
                many: '\u0431\u0430\u0439\u0442\u0430\u045E',
            },
            verb: '\u043C\u0435\u0446\u044C',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u043B\u0456\u043A';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u043C\u0430\u0441\u0456\u045E';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0443\u0432\u043E\u0434',
            email: 'email \u0430\u0434\u0440\u0430\u0441',
            url: 'URL',
            emoji: '\u044D\u043C\u043E\u0434\u0437\u0456',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441',
            date: 'ISO \u0434\u0430\u0442\u0430',
            time: 'ISO \u0447\u0430\u0441',
            duration:
                'ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C',
            ipv4: 'IPv4 \u0430\u0434\u0440\u0430\u0441',
            ipv6: 'IPv6 \u0430\u0434\u0440\u0430\u0441',
            cidrv4: 'IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D',
            cidrv6: 'IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D',
            base64: '\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64',
            base64url:
                '\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url',
            json_string: 'JSON \u0440\u0430\u0434\u043E\u043A',
            e164: '\u043D\u0443\u043C\u0430\u0440 E.164',
            jwt: 'JWT',
            template_literal: '\u0443\u0432\u043E\u0434',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${Y.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${h(Y.values[0])}`;
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U) {
                    let N = Number(Y.maximum),
                        M = Cw(N, U.unit.one, U.unit.few, U.unit.many);
                    return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435'} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${U.verb} ${J}${Y.maximum.toString()} ${M}`;
                }
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435'} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U) {
                    let N = Number(Y.minimum),
                        M = Cw(N, U.unit.one, U.unit.few, U.unit.many);
                    return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${Y.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${U.verb} ${J}${Y.minimum.toString()} ${M}`;
                }
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${Y.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${J.pattern}`;
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${Y.keys.length > 1 ? '\u043A\u043B\u044E\u0447\u044B' : '\u043A\u043B\u044E\u0447'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${Y.origin}`;
            case 'invalid_union':
                return '\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434';
            case 'invalid_element':
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${Y.origin}`;
            default:
                return '\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434';
        }
    };
};
function E7() {
    return { localeError: jI() };
}
var LI = () => {
    let $ = {
        string: { unit: 'car\xE0cters', verb: 'contenir' },
        file: { unit: 'bytes', verb: 'contenir' },
        array: { unit: 'elements', verb: 'contenir' },
        set: { unit: 'elements', verb: 'contenir' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'entrada',
            email: 'adre\xE7a electr\xF2nica',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'data i hora ISO',
            date: 'data ISO',
            time: 'hora ISO',
            duration: 'durada ISO',
            ipv4: 'adre\xE7a IPv4',
            ipv6: 'adre\xE7a IPv6',
            cidrv4: 'rang IPv4',
            cidrv6: 'rang IPv6',
            base64: 'cadena codificada en base64',
            base64url: 'cadena codificada en base64url',
            json_string: 'cadena JSON',
            e164: 'n\xFAmero E.164',
            jwt: 'JWT',
            template_literal: 'entrada',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Tipus inv\xE0lid: s'esperava ${Y.expected}, s'ha rebut ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Valor inv\xE0lid: s'esperava ${h(Y.values[0])}`;
                return `Opci\xF3 inv\xE0lida: s'esperava una de ${C(Y.values, ' o ')}`;
            case 'too_big': {
                let J = Y.inclusive ? 'com a m\xE0xim' : 'menys de',
                    U = X(Y.origin);
                if (U)
                    return `Massa gran: s'esperava que ${Y.origin ?? 'el valor'} contingu\xE9s ${J} ${Y.maximum.toString()} ${U.unit ?? 'elements'}`;
                return `Massa gran: s'esperava que ${Y.origin ?? 'el valor'} fos ${J} ${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? 'com a m\xEDnim' : 'm\xE9s de',
                    U = X(Y.origin);
                if (U)
                    return `Massa petit: s'esperava que ${Y.origin} contingu\xE9s ${J} ${Y.minimum.toString()} ${U.unit}`;
                return `Massa petit: s'esperava que ${Y.origin} fos ${J} ${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Format inv\xE0lid: ha de comen\xE7ar amb "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Format inv\xE0lid: ha d'acabar amb "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Format inv\xE0lid: ha d'incloure "${J.includes}"`;
                if (J.format === 'regex')
                    return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${J.pattern}`;
                return `Format inv\xE0lid per a ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Clau${Y.keys.length > 1 ? 's' : ''} no reconeguda${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Clau inv\xE0lida a ${Y.origin}`;
            case 'invalid_union':
                return 'Entrada inv\xE0lida';
            case 'invalid_element':
                return `Element inv\xE0lid a ${Y.origin}`;
            default:
                return 'Entrada inv\xE0lida';
        }
    };
};
function x7() {
    return { localeError: LI() };
}
var KI = () => {
    let $ = {
        string: { unit: 'znak\u016F', verb: 'm\xEDt' },
        file: { unit: 'bajt\u016F', verb: 'm\xEDt' },
        array: { unit: 'prvk\u016F', verb: 'm\xEDt' },
        set: { unit: 'prvk\u016F', verb: 'm\xEDt' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u010D\xEDslo';
                case 'string':
                    return '\u0159et\u011Bzec';
                case 'boolean':
                    return 'boolean';
                case 'bigint':
                    return 'bigint';
                case 'function':
                    return 'funkce';
                case 'symbol':
                    return 'symbol';
                case 'undefined':
                    return 'undefined';
                case 'object': {
                    if (Array.isArray(Y)) return 'pole';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'regul\xE1rn\xED v\xFDraz',
            email: 'e-mailov\xE1 adresa',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'datum a \u010Das ve form\xE1tu ISO',
            date: 'datum ve form\xE1tu ISO',
            time: '\u010Das ve form\xE1tu ISO',
            duration: 'doba trv\xE1n\xED ISO',
            ipv4: 'IPv4 adresa',
            ipv6: 'IPv6 adresa',
            cidrv4: 'rozsah IPv4',
            cidrv6: 'rozsah IPv6',
            base64: '\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64',
            base64url:
                '\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url',
            json_string: '\u0159et\u011Bzec ve form\xE1tu JSON',
            e164: '\u010D\xEDslo E.164',
            jwt: 'JWT',
            template_literal: 'vstup',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${Y.expected}, obdr\u017Eeno ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${h(Y.values[0])}`;
                return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${Y.origin ?? 'hodnota'} mus\xED m\xEDt ${J}${Y.maximum.toString()} ${U.unit ?? 'prvk\u016F'}`;
                return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${Y.origin ?? 'hodnota'} mus\xED b\xFDt ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${Y.origin ?? 'hodnota'} mus\xED m\xEDt ${J}${Y.minimum.toString()} ${U.unit ?? 'prvk\u016F'}`;
                return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${Y.origin ?? 'hodnota'} mus\xED b\xFDt ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${J.includes}"`;
                if (J.format === 'regex')
                    return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${J.pattern}`;
                return `Neplatn\xFD form\xE1t ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Nezn\xE1m\xE9 kl\xED\u010De: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Neplatn\xFD kl\xED\u010D v ${Y.origin}`;
            case 'invalid_union':
                return 'Neplatn\xFD vstup';
            case 'invalid_element':
                return `Neplatn\xE1 hodnota v ${Y.origin}`;
            default:
                return 'Neplatn\xFD vstup';
        }
    };
};
function b7() {
    return { localeError: KI() };
}
var _I = () => {
    let $ = {
        string: { unit: 'Zeichen', verb: 'zu haben' },
        file: { unit: 'Bytes', verb: 'zu haben' },
        array: { unit: 'Elemente', verb: 'zu haben' },
        set: { unit: 'Elemente', verb: 'zu haben' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'Zahl';
                case 'object': {
                    if (Array.isArray(Y)) return 'Array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'Eingabe',
            email: 'E-Mail-Adresse',
            url: 'URL',
            emoji: 'Emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO-Datum und -Uhrzeit',
            date: 'ISO-Datum',
            time: 'ISO-Uhrzeit',
            duration: 'ISO-Dauer',
            ipv4: 'IPv4-Adresse',
            ipv6: 'IPv6-Adresse',
            cidrv4: 'IPv4-Bereich',
            cidrv6: 'IPv6-Bereich',
            base64: 'Base64-codierter String',
            base64url: 'Base64-URL-codierter String',
            json_string: 'JSON-String',
            e164: 'E.164-Nummer',
            jwt: 'JWT',
            template_literal: 'Eingabe',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Ung\xFCltige Eingabe: erwartet ${Y.expected}, erhalten ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Ung\xFCltige Eingabe: erwartet ${h(Y.values[0])}`;
                return `Ung\xFCltige Option: erwartet eine von ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Zu gro\xDF: erwartet, dass ${Y.origin ?? 'Wert'} ${J}${Y.maximum.toString()} ${U.unit ?? 'Elemente'} hat`;
                return `Zu gro\xDF: erwartet, dass ${Y.origin ?? 'Wert'} ${J}${Y.maximum.toString()} ist`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Zu klein: erwartet, dass ${Y.origin} ${J}${Y.minimum.toString()} ${U.unit} hat`;
                return `Zu klein: erwartet, dass ${Y.origin} ${J}${Y.minimum.toString()} ist`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Ung\xFCltiger String: muss mit "${J.prefix}" beginnen`;
                if (J.format === 'ends_with')
                    return `Ung\xFCltiger String: muss mit "${J.suffix}" enden`;
                if (J.format === 'includes')
                    return `Ung\xFCltiger String: muss "${J.includes}" enthalten`;
                if (J.format === 'regex')
                    return `Ung\xFCltiger String: muss dem Muster ${J.pattern} entsprechen`;
                return `Ung\xFCltig: ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Ung\xFCltige Zahl: muss ein Vielfaches von ${Y.divisor} sein`;
            case 'unrecognized_keys':
                return `${Y.keys.length > 1 ? 'Unbekannte Schl\xFCssel' : 'Unbekannter Schl\xFCssel'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Ung\xFCltiger Schl\xFCssel in ${Y.origin}`;
            case 'invalid_union':
                return 'Ung\xFCltige Eingabe';
            case 'invalid_element':
                return `Ung\xFCltiger Wert in ${Y.origin}`;
            default:
                return 'Ung\xFCltige Eingabe';
        }
    };
};
function g7() {
    return { localeError: _I() };
}
var FI = ($) => {
        let X = typeof $;
        switch (X) {
            case 'number':
                return Number.isNaN($) ? 'NaN' : 'number';
            case 'object': {
                if (Array.isArray($)) return 'array';
                if ($ === null) return 'null';
                if (
                    Object.getPrototypeOf($) !== Object.prototype &&
                    $.constructor
                )
                    return $.constructor.name;
            }
        }
        return X;
    },
    II = () => {
        let $ = {
            string: { unit: 'characters', verb: 'to have' },
            file: { unit: 'bytes', verb: 'to have' },
            array: { unit: 'items', verb: 'to have' },
            set: { unit: 'items', verb: 'to have' },
        };
        function X(Q) {
            return $[Q] ?? null;
        }
        let W = {
            regex: 'input',
            email: 'email address',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO datetime',
            date: 'ISO date',
            time: 'ISO time',
            duration: 'ISO duration',
            ipv4: 'IPv4 address',
            ipv6: 'IPv6 address',
            cidrv4: 'IPv4 range',
            cidrv6: 'IPv6 range',
            base64: 'base64-encoded string',
            base64url: 'base64url-encoded string',
            json_string: 'JSON string',
            e164: 'E.164 number',
            jwt: 'JWT',
            template_literal: 'input',
        };
        return (Q) => {
            switch (Q.code) {
                case 'invalid_type':
                    return `Invalid input: expected ${Q.expected}, received ${FI(Q.input)}`;
                case 'invalid_value':
                    if (Q.values.length === 1)
                        return `Invalid input: expected ${h(Q.values[0])}`;
                    return `Invalid option: expected one of ${C(Q.values, '|')}`;
                case 'too_big': {
                    let Y = Q.inclusive ? '<=' : '<',
                        J = X(Q.origin);
                    if (J)
                        return `Too big: expected ${Q.origin ?? 'value'} to have ${Y}${Q.maximum.toString()} ${J.unit ?? 'elements'}`;
                    return `Too big: expected ${Q.origin ?? 'value'} to be ${Y}${Q.maximum.toString()}`;
                }
                case 'too_small': {
                    let Y = Q.inclusive ? '>=' : '>',
                        J = X(Q.origin);
                    if (J)
                        return `Too small: expected ${Q.origin} to have ${Y}${Q.minimum.toString()} ${J.unit}`;
                    return `Too small: expected ${Q.origin} to be ${Y}${Q.minimum.toString()}`;
                }
                case 'invalid_format': {
                    let Y = Q;
                    if (Y.format === 'starts_with')
                        return `Invalid string: must start with "${Y.prefix}"`;
                    if (Y.format === 'ends_with')
                        return `Invalid string: must end with "${Y.suffix}"`;
                    if (Y.format === 'includes')
                        return `Invalid string: must include "${Y.includes}"`;
                    if (Y.format === 'regex')
                        return `Invalid string: must match pattern ${Y.pattern}`;
                    return `Invalid ${W[Y.format] ?? Q.format}`;
                }
                case 'not_multiple_of':
                    return `Invalid number: must be a multiple of ${Q.divisor}`;
                case 'unrecognized_keys':
                    return `Unrecognized key${Q.keys.length > 1 ? 's' : ''}: ${C(Q.keys, ', ')}`;
                case 'invalid_key':
                    return `Invalid key in ${Q.origin}`;
                case 'invalid_union':
                    return 'Invalid input';
                case 'invalid_element':
                    return `Invalid value in ${Q.origin}`;
                default:
                    return 'Invalid input';
            }
        };
    };
function iW() {
    return { localeError: II() };
}
var CI = ($) => {
        let X = typeof $;
        switch (X) {
            case 'number':
                return Number.isNaN($) ? 'NaN' : 'nombro';
            case 'object': {
                if (Array.isArray($)) return 'tabelo';
                if ($ === null) return 'senvalora';
                if (
                    Object.getPrototypeOf($) !== Object.prototype &&
                    $.constructor
                )
                    return $.constructor.name;
            }
        }
        return X;
    },
    RI = () => {
        let $ = {
            string: { unit: 'karaktrojn', verb: 'havi' },
            file: { unit: 'bajtojn', verb: 'havi' },
            array: { unit: 'elementojn', verb: 'havi' },
            set: { unit: 'elementojn', verb: 'havi' },
        };
        function X(Q) {
            return $[Q] ?? null;
        }
        let W = {
            regex: 'enigo',
            email: 'retadreso',
            url: 'URL',
            emoji: 'emo\u011Dio',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO-datotempo',
            date: 'ISO-dato',
            time: 'ISO-tempo',
            duration: 'ISO-da\u016Dro',
            ipv4: 'IPv4-adreso',
            ipv6: 'IPv6-adreso',
            cidrv4: 'IPv4-rango',
            cidrv6: 'IPv6-rango',
            base64: '64-ume kodita karaktraro',
            base64url: 'URL-64-ume kodita karaktraro',
            json_string: 'JSON-karaktraro',
            e164: 'E.164-nombro',
            jwt: 'JWT',
            template_literal: 'enigo',
        };
        return (Q) => {
            switch (Q.code) {
                case 'invalid_type':
                    return `Nevalida enigo: atendi\u011Dis ${Q.expected}, ricevi\u011Dis ${CI(Q.input)}`;
                case 'invalid_value':
                    if (Q.values.length === 1)
                        return `Nevalida enigo: atendi\u011Dis ${h(Q.values[0])}`;
                    return `Nevalida opcio: atendi\u011Dis unu el ${C(Q.values, '|')}`;
                case 'too_big': {
                    let Y = Q.inclusive ? '<=' : '<',
                        J = X(Q.origin);
                    if (J)
                        return `Tro granda: atendi\u011Dis ke ${Q.origin ?? 'valoro'} havu ${Y}${Q.maximum.toString()} ${J.unit ?? 'elementojn'}`;
                    return `Tro granda: atendi\u011Dis ke ${Q.origin ?? 'valoro'} havu ${Y}${Q.maximum.toString()}`;
                }
                case 'too_small': {
                    let Y = Q.inclusive ? '>=' : '>',
                        J = X(Q.origin);
                    if (J)
                        return `Tro malgranda: atendi\u011Dis ke ${Q.origin} havu ${Y}${Q.minimum.toString()} ${J.unit}`;
                    return `Tro malgranda: atendi\u011Dis ke ${Q.origin} estu ${Y}${Q.minimum.toString()}`;
                }
                case 'invalid_format': {
                    let Y = Q;
                    if (Y.format === 'starts_with')
                        return `Nevalida karaktraro: devas komenci\u011Di per "${Y.prefix}"`;
                    if (Y.format === 'ends_with')
                        return `Nevalida karaktraro: devas fini\u011Di per "${Y.suffix}"`;
                    if (Y.format === 'includes')
                        return `Nevalida karaktraro: devas inkluzivi "${Y.includes}"`;
                    if (Y.format === 'regex')
                        return `Nevalida karaktraro: devas kongrui kun la modelo ${Y.pattern}`;
                    return `Nevalida ${W[Y.format] ?? Q.format}`;
                }
                case 'not_multiple_of':
                    return `Nevalida nombro: devas esti oblo de ${Q.divisor}`;
                case 'unrecognized_keys':
                    return `Nekonata${Q.keys.length > 1 ? 'j' : ''} \u015Dlosilo${Q.keys.length > 1 ? 'j' : ''}: ${C(Q.keys, ', ')}`;
                case 'invalid_key':
                    return `Nevalida \u015Dlosilo en ${Q.origin}`;
                case 'invalid_union':
                    return 'Nevalida enigo';
                case 'invalid_element':
                    return `Nevalida valoro en ${Q.origin}`;
                default:
                    return 'Nevalida enigo';
            }
        };
    };
function T7() {
    return { localeError: RI() };
}
var VI = () => {
    let $ = {
        string: { unit: 'caracteres', verb: 'tener' },
        file: { unit: 'bytes', verb: 'tener' },
        array: { unit: 'elementos', verb: 'tener' },
        set: { unit: 'elementos', verb: 'tener' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'n\xFAmero';
                case 'object': {
                    if (Array.isArray(Y)) return 'arreglo';
                    if (Y === null) return 'nulo';
                    if (Object.getPrototypeOf(Y) !== Object.prototype)
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'entrada',
            email: 'direcci\xF3n de correo electr\xF3nico',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'fecha y hora ISO',
            date: 'fecha ISO',
            time: 'hora ISO',
            duration: 'duraci\xF3n ISO',
            ipv4: 'direcci\xF3n IPv4',
            ipv6: 'direcci\xF3n IPv6',
            cidrv4: 'rango IPv4',
            cidrv6: 'rango IPv6',
            base64: 'cadena codificada en base64',
            base64url: 'URL codificada en base64',
            json_string: 'cadena JSON',
            e164: 'n\xFAmero E.164',
            jwt: 'JWT',
            template_literal: 'entrada',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Entrada inv\xE1lida: se esperaba ${Y.expected}, recibido ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Entrada inv\xE1lida: se esperaba ${h(Y.values[0])}`;
                return `Opci\xF3n inv\xE1lida: se esperaba una de ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Demasiado grande: se esperaba que ${Y.origin ?? 'valor'} tuviera ${J}${Y.maximum.toString()} ${U.unit ?? 'elementos'}`;
                return `Demasiado grande: se esperaba que ${Y.origin ?? 'valor'} fuera ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Demasiado peque\xF1o: se esperaba que ${Y.origin} tuviera ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Demasiado peque\xF1o: se esperaba que ${Y.origin} fuera ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Cadena inv\xE1lida: debe comenzar con "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Cadena inv\xE1lida: debe terminar en "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Cadena inv\xE1lida: debe incluir "${J.includes}"`;
                if (J.format === 'regex')
                    return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${J.pattern}`;
                return `Inv\xE1lido ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Llave${Y.keys.length > 1 ? 's' : ''} desconocida${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Llave inv\xE1lida en ${Y.origin}`;
            case 'invalid_union':
                return 'Entrada inv\xE1lida';
            case 'invalid_element':
                return `Valor inv\xE1lido en ${Y.origin}`;
            default:
                return 'Entrada inv\xE1lida';
        }
    };
};
function k7() {
    return { localeError: VI() };
}
var EI = () => {
    let $ = {
        string: {
            unit: '\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631',
            verb: '\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F',
        },
        file: {
            unit: '\u0628\u0627\u06CC\u062A',
            verb: '\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F',
        },
        array: {
            unit: '\u0622\u06CC\u062A\u0645',
            verb: '\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F',
        },
        set: {
            unit: '\u0622\u06CC\u062A\u0645',
            verb: '\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u0639\u062F\u062F';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u0622\u0631\u0627\u06CC\u0647';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0648\u0631\u0648\u062F\u06CC',
            email: '\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644',
            url: 'URL',
            emoji: '\u0627\u06CC\u0645\u0648\u062C\u06CC',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648',
            date: '\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648',
            time: '\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648',
            duration:
                '\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648',
            ipv4: 'IPv4 \u0622\u062F\u0631\u0633',
            ipv6: 'IPv6 \u0622\u062F\u0631\u0633',
            cidrv4: 'IPv4 \u062F\u0627\u0645\u0646\u0647',
            cidrv6: 'IPv6 \u062F\u0627\u0645\u0646\u0647',
            base64: 'base64-encoded \u0631\u0634\u062A\u0647',
            base64url: 'base64url-encoded \u0631\u0634\u062A\u0647',
            json_string: 'JSON \u0631\u0634\u062A\u0647',
            e164: 'E.164 \u0639\u062F\u062F',
            jwt: 'JWT',
            template_literal: '\u0648\u0631\u0648\u062F\u06CC',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${Y.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${W(Y.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${h(Y.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
                return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${C(Y.values, '|')} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${Y.origin ?? '\u0645\u0642\u062F\u0627\u0631'} \u0628\u0627\u06CC\u062F ${J}${Y.maximum.toString()} ${U.unit ?? '\u0639\u0646\u0635\u0631'} \u0628\u0627\u0634\u062F`;
                return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${Y.origin ?? '\u0645\u0642\u062F\u0627\u0631'} \u0628\u0627\u06CC\u062F ${J}${Y.maximum.toString()} \u0628\u0627\u0634\u062F`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${Y.origin} \u0628\u0627\u06CC\u062F ${J}${Y.minimum.toString()} ${U.unit} \u0628\u0627\u0634\u062F`;
                return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${Y.origin} \u0628\u0627\u06CC\u062F ${J}${Y.minimum.toString()} \u0628\u0627\u0634\u062F`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${J.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
                if (J.format === 'ends_with')
                    return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${J.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
                if (J.format === 'includes')
                    return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${J.includes}" \u0628\u0627\u0634\u062F`;
                if (J.format === 'regex')
                    return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${J.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
                return `${Q[J.format] ?? Y.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
            }
            case 'not_multiple_of':
                return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${Y.divisor} \u0628\u0627\u0634\u062F`;
            case 'unrecognized_keys':
                return `\u06A9\u0644\u06CC\u062F${Y.keys.length > 1 ? '\u0647\u0627\u06CC' : ''} \u0646\u0627\u0634\u0646\u0627\u0633: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${Y.origin}`;
            case 'invalid_union':
                return '\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631';
            case 'invalid_element':
                return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${Y.origin}`;
            default:
                return '\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631';
        }
    };
};
function v7() {
    return { localeError: EI() };
}
var xI = () => {
    let $ = {
        string: { unit: 'merkki\xE4', subject: 'merkkijonon' },
        file: { unit: 'tavua', subject: 'tiedoston' },
        array: { unit: 'alkiota', subject: 'listan' },
        set: { unit: 'alkiota', subject: 'joukon' },
        number: { unit: '', subject: 'luvun' },
        bigint: { unit: '', subject: 'suuren kokonaisluvun' },
        int: { unit: '', subject: 'kokonaisluvun' },
        date: { unit: '', subject: 'p\xE4iv\xE4m\xE4\xE4r\xE4n' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 's\xE4\xE4nn\xF6llinen lauseke',
            email: 's\xE4hk\xF6postiosoite',
            url: 'URL-osoite',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO-aikaleima',
            date: 'ISO-p\xE4iv\xE4m\xE4\xE4r\xE4',
            time: 'ISO-aika',
            duration: 'ISO-kesto',
            ipv4: 'IPv4-osoite',
            ipv6: 'IPv6-osoite',
            cidrv4: 'IPv4-alue',
            cidrv6: 'IPv6-alue',
            base64: 'base64-koodattu merkkijono',
            base64url: 'base64url-koodattu merkkijono',
            json_string: 'JSON-merkkijono',
            e164: 'E.164-luku',
            jwt: 'JWT',
            template_literal: 'templaattimerkkijono',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Virheellinen tyyppi: odotettiin ${Y.expected}, oli ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Virheellinen sy\xF6te: t\xE4ytyy olla ${h(Y.values[0])}`;
                return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Liian suuri: ${U.subject} t\xE4ytyy olla ${J}${Y.maximum.toString()} ${U.unit}`.trim();
                return `Liian suuri: arvon t\xE4ytyy olla ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Liian pieni: ${U.subject} t\xE4ytyy olla ${J}${Y.minimum.toString()} ${U.unit}`.trim();
                return `Liian pieni: arvon t\xE4ytyy olla ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${J.includes}"`;
                if (J.format === 'regex')
                    return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${J.pattern}`;
                return `Virheellinen ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Virheellinen luku: t\xE4ytyy olla luvun ${Y.divisor} monikerta`;
            case 'unrecognized_keys':
                return `${Y.keys.length > 1 ? 'Tuntemattomat avaimet' : 'Tuntematon avain'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return 'Virheellinen avain tietueessa';
            case 'invalid_union':
                return 'Virheellinen unioni';
            case 'invalid_element':
                return 'Virheellinen arvo joukossa';
            default:
                return 'Virheellinen sy\xF6te';
        }
    };
};
function f7() {
    return { localeError: xI() };
}
var bI = () => {
    let $ = {
        string: { unit: 'caract\xE8res', verb: 'avoir' },
        file: { unit: 'octets', verb: 'avoir' },
        array: { unit: '\xE9l\xE9ments', verb: 'avoir' },
        set: { unit: '\xE9l\xE9ments', verb: 'avoir' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'nombre';
                case 'object': {
                    if (Array.isArray(Y)) return 'tableau';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'entr\xE9e',
            email: 'adresse e-mail',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'date et heure ISO',
            date: 'date ISO',
            time: 'heure ISO',
            duration: 'dur\xE9e ISO',
            ipv4: 'adresse IPv4',
            ipv6: 'adresse IPv6',
            cidrv4: 'plage IPv4',
            cidrv6: 'plage IPv6',
            base64: 'cha\xEEne encod\xE9e en base64',
            base64url: 'cha\xEEne encod\xE9e en base64url',
            json_string: 'cha\xEEne JSON',
            e164: 'num\xE9ro E.164',
            jwt: 'JWT',
            template_literal: 'entr\xE9e',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Entr\xE9e invalide : ${Y.expected} attendu, ${W(Y.input)} re\xE7u`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Entr\xE9e invalide : ${h(Y.values[0])} attendu`;
                return `Option invalide : une valeur parmi ${C(Y.values, '|')} attendue`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Trop grand : ${Y.origin ?? 'valeur'} doit ${U.verb} ${J}${Y.maximum.toString()} ${U.unit ?? '\xE9l\xE9ment(s)'}`;
                return `Trop grand : ${Y.origin ?? 'valeur'} doit \xEAtre ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Trop petit : ${Y.origin} doit ${U.verb} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Trop petit : ${Y.origin} doit \xEAtre ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Cha\xEEne invalide : doit commencer par "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Cha\xEEne invalide : doit se terminer par "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Cha\xEEne invalide : doit inclure "${J.includes}"`;
                if (J.format === 'regex')
                    return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} invalide`;
            }
            case 'not_multiple_of':
                return `Nombre invalide : doit \xEAtre un multiple de ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Cl\xE9${Y.keys.length > 1 ? 's' : ''} non reconnue${Y.keys.length > 1 ? 's' : ''} : ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Cl\xE9 invalide dans ${Y.origin}`;
            case 'invalid_union':
                return 'Entr\xE9e invalide';
            case 'invalid_element':
                return `Valeur invalide dans ${Y.origin}`;
            default:
                return 'Entr\xE9e invalide';
        }
    };
};
function y7() {
    return { localeError: bI() };
}
var gI = () => {
    let $ = {
        string: { unit: 'caract\xE8res', verb: 'avoir' },
        file: { unit: 'octets', verb: 'avoir' },
        array: { unit: '\xE9l\xE9ments', verb: 'avoir' },
        set: { unit: '\xE9l\xE9ments', verb: 'avoir' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'entr\xE9e',
            email: 'adresse courriel',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'date-heure ISO',
            date: 'date ISO',
            time: 'heure ISO',
            duration: 'dur\xE9e ISO',
            ipv4: 'adresse IPv4',
            ipv6: 'adresse IPv6',
            cidrv4: 'plage IPv4',
            cidrv6: 'plage IPv6',
            base64: 'cha\xEEne encod\xE9e en base64',
            base64url: 'cha\xEEne encod\xE9e en base64url',
            json_string: 'cha\xEEne JSON',
            e164: 'num\xE9ro E.164',
            jwt: 'JWT',
            template_literal: 'entr\xE9e',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Entr\xE9e invalide : attendu ${Y.expected}, re\xE7u ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Entr\xE9e invalide : attendu ${h(Y.values[0])}`;
                return `Option invalide : attendu l'une des valeurs suivantes ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '\u2264' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Trop grand : attendu que ${Y.origin ?? 'la valeur'} ait ${J}${Y.maximum.toString()} ${U.unit}`;
                return `Trop grand : attendu que ${Y.origin ?? 'la valeur'} soit ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '\u2265' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Trop petit : attendu que ${Y.origin} ait ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Trop petit : attendu que ${Y.origin} soit ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Cha\xEEne invalide : doit commencer par "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Cha\xEEne invalide : doit se terminer par "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Cha\xEEne invalide : doit inclure "${J.includes}"`;
                if (J.format === 'regex')
                    return `Cha\xEEne invalide : doit correspondre au motif ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} invalide`;
            }
            case 'not_multiple_of':
                return `Nombre invalide : doit \xEAtre un multiple de ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Cl\xE9${Y.keys.length > 1 ? 's' : ''} non reconnue${Y.keys.length > 1 ? 's' : ''} : ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Cl\xE9 invalide dans ${Y.origin}`;
            case 'invalid_union':
                return 'Entr\xE9e invalide';
            case 'invalid_element':
                return `Valeur invalide dans ${Y.origin}`;
            default:
                return 'Entr\xE9e invalide';
        }
    };
};
function h7() {
    return { localeError: gI() };
}
var TI = () => {
    let $ = {
        string: {
            unit: '\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA',
            verb: '\u05DC\u05DB\u05DC\u05D5\u05DC',
        },
        file: {
            unit: '\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD',
            verb: '\u05DC\u05DB\u05DC\u05D5\u05DC',
        },
        array: {
            unit: '\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD',
            verb: '\u05DC\u05DB\u05DC\u05D5\u05DC',
        },
        set: {
            unit: '\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD',
            verb: '\u05DC\u05DB\u05DC\u05D5\u05DC',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u05E7\u05DC\u05D8',
            email: '\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC',
            url: '\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA',
            emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO',
            date: '\u05EA\u05D0\u05E8\u05D9\u05DA ISO',
            time: '\u05D6\u05DE\u05DF ISO',
            duration: '\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO',
            ipv4: '\u05DB\u05EA\u05D5\u05D1\u05EA IPv4',
            ipv6: '\u05DB\u05EA\u05D5\u05D1\u05EA IPv6',
            cidrv4: '\u05D8\u05D5\u05D5\u05D7 IPv4',
            cidrv6: '\u05D8\u05D5\u05D5\u05D7 IPv6',
            base64: '\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64',
            base64url:
                '\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA',
            json_string: '\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON',
            e164: '\u05DE\u05E1\u05E4\u05E8 E.164',
            jwt: 'JWT',
            template_literal: '\u05E7\u05DC\u05D8',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${Y.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${h(Y.values[0])}`;
                return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${Y.origin ?? 'value'} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${J}${Y.maximum.toString()} ${U.unit ?? 'elements'}`;
                return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${Y.origin ?? 'value'} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${Y.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${Y.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
            }
            case 'not_multiple_of':
                return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u05DE\u05E4\u05EA\u05D7${Y.keys.length > 1 ? '\u05D5\u05EA' : ''} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${Y.keys.length > 1 ? '\u05D9\u05DD' : '\u05D4'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${Y.origin}`;
            case 'invalid_union':
                return '\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF';
            case 'invalid_element':
                return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${Y.origin}`;
            default:
                return '\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF';
        }
    };
};
function m7() {
    return { localeError: TI() };
}
var kI = () => {
    let $ = {
        string: { unit: 'karakter', verb: 'legyen' },
        file: { unit: 'byte', verb: 'legyen' },
        array: { unit: 'elem', verb: 'legyen' },
        set: { unit: 'elem', verb: 'legyen' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'sz\xE1m';
                case 'object': {
                    if (Array.isArray(Y)) return 't\xF6mb';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'bemenet',
            email: 'email c\xEDm',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO id\u0151b\xE9lyeg',
            date: 'ISO d\xE1tum',
            time: 'ISO id\u0151',
            duration: 'ISO id\u0151intervallum',
            ipv4: 'IPv4 c\xEDm',
            ipv6: 'IPv6 c\xEDm',
            cidrv4: 'IPv4 tartom\xE1ny',
            cidrv6: 'IPv6 tartom\xE1ny',
            base64: 'base64-k\xF3dolt string',
            base64url: 'base64url-k\xF3dolt string',
            json_string: 'JSON string',
            e164: 'E.164 sz\xE1m',
            jwt: 'JWT',
            template_literal: 'bemenet',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${Y.expected}, a kapott \xE9rt\xE9k ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${h(Y.values[0])}`;
                return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `T\xFAl nagy: ${Y.origin ?? '\xE9rt\xE9k'} m\xE9rete t\xFAl nagy ${J}${Y.maximum.toString()} ${U.unit ?? 'elem'}`;
                return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${Y.origin ?? '\xE9rt\xE9k'} t\xFAl nagy: ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${Y.origin} m\xE9rete t\xFAl kicsi ${J}${Y.minimum.toString()} ${U.unit}`;
                return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${Y.origin} t\xFAl kicsi ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\xC9rv\xE9nytelen string: "${J.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
                if (J.format === 'ends_with')
                    return `\xC9rv\xE9nytelen string: "${J.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
                if (J.format === 'includes')
                    return `\xC9rv\xE9nytelen string: "${J.includes}" \xE9rt\xE9ket kell tartalmaznia`;
                if (J.format === 'regex')
                    return `\xC9rv\xE9nytelen string: ${J.pattern} mint\xE1nak kell megfelelnie`;
                return `\xC9rv\xE9nytelen ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\xC9rv\xE9nytelen sz\xE1m: ${Y.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
            case 'unrecognized_keys':
                return `Ismeretlen kulcs${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\xC9rv\xE9nytelen kulcs ${Y.origin}`;
            case 'invalid_union':
                return '\xC9rv\xE9nytelen bemenet';
            case 'invalid_element':
                return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${Y.origin}`;
            default:
                return '\xC9rv\xE9nytelen bemenet';
        }
    };
};
function c7() {
    return { localeError: kI() };
}
var vI = () => {
    let $ = {
        string: { unit: 'karakter', verb: 'memiliki' },
        file: { unit: 'byte', verb: 'memiliki' },
        array: { unit: 'item', verb: 'memiliki' },
        set: { unit: 'item', verb: 'memiliki' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'input',
            email: 'alamat email',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'tanggal dan waktu format ISO',
            date: 'tanggal format ISO',
            time: 'jam format ISO',
            duration: 'durasi format ISO',
            ipv4: 'alamat IPv4',
            ipv6: 'alamat IPv6',
            cidrv4: 'rentang alamat IPv4',
            cidrv6: 'rentang alamat IPv6',
            base64: 'string dengan enkode base64',
            base64url: 'string dengan enkode base64url',
            json_string: 'string JSON',
            e164: 'angka E.164',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Input tidak valid: diharapkan ${Y.expected}, diterima ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Input tidak valid: diharapkan ${h(Y.values[0])}`;
                return `Pilihan tidak valid: diharapkan salah satu dari ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Terlalu besar: diharapkan ${Y.origin ?? 'value'} memiliki ${J}${Y.maximum.toString()} ${U.unit ?? 'elemen'}`;
                return `Terlalu besar: diharapkan ${Y.origin ?? 'value'} menjadi ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Terlalu kecil: diharapkan ${Y.origin} memiliki ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Terlalu kecil: diharapkan ${Y.origin} menjadi ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `String tidak valid: harus dimulai dengan "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `String tidak valid: harus berakhir dengan "${J.suffix}"`;
                if (J.format === 'includes')
                    return `String tidak valid: harus menyertakan "${J.includes}"`;
                if (J.format === 'regex')
                    return `String tidak valid: harus sesuai pola ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} tidak valid`;
            }
            case 'not_multiple_of':
                return `Angka tidak valid: harus kelipatan dari ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Kunci tidak dikenali ${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Kunci tidak valid di ${Y.origin}`;
            case 'invalid_union':
                return 'Input tidak valid';
            case 'invalid_element':
                return `Nilai tidak valid di ${Y.origin}`;
            default:
                return 'Input tidak valid';
        }
    };
};
function u7() {
    return { localeError: vI() };
}
var fI = () => {
    let $ = {
        string: { unit: 'caratteri', verb: 'avere' },
        file: { unit: 'byte', verb: 'avere' },
        array: { unit: 'elementi', verb: 'avere' },
        set: { unit: 'elementi', verb: 'avere' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'numero';
                case 'object': {
                    if (Array.isArray(Y)) return 'vettore';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'input',
            email: 'indirizzo email',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'data e ora ISO',
            date: 'data ISO',
            time: 'ora ISO',
            duration: 'durata ISO',
            ipv4: 'indirizzo IPv4',
            ipv6: 'indirizzo IPv6',
            cidrv4: 'intervallo IPv4',
            cidrv6: 'intervallo IPv6',
            base64: 'stringa codificata in base64',
            base64url: 'URL codificata in base64',
            json_string: 'stringa JSON',
            e164: 'numero E.164',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Input non valido: atteso ${Y.expected}, ricevuto ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Input non valido: atteso ${h(Y.values[0])}`;
                return `Opzione non valida: atteso uno tra ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Troppo grande: ${Y.origin ?? 'valore'} deve avere ${J}${Y.maximum.toString()} ${U.unit ?? 'elementi'}`;
                return `Troppo grande: ${Y.origin ?? 'valore'} deve essere ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Troppo piccolo: ${Y.origin} deve avere ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Troppo piccolo: ${Y.origin} deve essere ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Stringa non valida: deve iniziare con "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Stringa non valida: deve terminare con "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Stringa non valida: deve includere "${J.includes}"`;
                if (J.format === 'regex')
                    return `Stringa non valida: deve corrispondere al pattern ${J.pattern}`;
                return `Invalid ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Numero non valido: deve essere un multiplo di ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Chiav${Y.keys.length > 1 ? 'i' : 'e'} non riconosciut${Y.keys.length > 1 ? 'e' : 'a'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Chiave non valida in ${Y.origin}`;
            case 'invalid_union':
                return 'Input non valido';
            case 'invalid_element':
                return `Valore non valido in ${Y.origin}`;
            default:
                return 'Input non valido';
        }
    };
};
function d7() {
    return { localeError: fI() };
}
var yI = () => {
    let $ = {
        string: { unit: '\u6587\u5B57', verb: '\u3067\u3042\u308B' },
        file: { unit: '\u30D0\u30A4\u30C8', verb: '\u3067\u3042\u308B' },
        array: { unit: '\u8981\u7D20', verb: '\u3067\u3042\u308B' },
        set: { unit: '\u8981\u7D20', verb: '\u3067\u3042\u308B' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u6570\u5024';
                case 'object': {
                    if (Array.isArray(Y)) return '\u914D\u5217';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u5165\u529B\u5024',
            email: '\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9',
            url: 'URL',
            emoji: '\u7D75\u6587\u5B57',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO\u65E5\u6642',
            date: 'ISO\u65E5\u4ED8',
            time: 'ISO\u6642\u523B',
            duration: 'ISO\u671F\u9593',
            ipv4: 'IPv4\u30A2\u30C9\u30EC\u30B9',
            ipv6: 'IPv6\u30A2\u30C9\u30EC\u30B9',
            cidrv4: 'IPv4\u7BC4\u56F2',
            cidrv6: 'IPv6\u7BC4\u56F2',
            base64: 'base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217',
            base64url:
                'base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217',
            json_string: 'JSON\u6587\u5B57\u5217',
            e164: 'E.164\u756A\u53F7',
            jwt: 'JWT',
            template_literal: '\u5165\u529B\u5024',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u7121\u52B9\u306A\u5165\u529B: ${Y.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${W(Y.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u7121\u52B9\u306A\u5165\u529B: ${h(Y.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
                return `\u7121\u52B9\u306A\u9078\u629E: ${C(Y.values, '\u3001')}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            case 'too_big': {
                let J = Y.inclusive
                        ? '\u4EE5\u4E0B\u3067\u3042\u308B'
                        : '\u3088\u308A\u5C0F\u3055\u3044',
                    U = X(Y.origin);
                if (U)
                    return `\u5927\u304D\u3059\u304E\u308B\u5024: ${Y.origin ?? '\u5024'}\u306F${Y.maximum.toString()}${U.unit ?? '\u8981\u7D20'}${J}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                return `\u5927\u304D\u3059\u304E\u308B\u5024: ${Y.origin ?? '\u5024'}\u306F${Y.maximum.toString()}${J}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            }
            case 'too_small': {
                let J = Y.inclusive
                        ? '\u4EE5\u4E0A\u3067\u3042\u308B'
                        : '\u3088\u308A\u5927\u304D\u3044',
                    U = X(Y.origin);
                if (U)
                    return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${Y.origin}\u306F${Y.minimum.toString()}${U.unit}${J}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${Y.origin}\u306F${Y.minimum.toString()}${J}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${J.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                if (J.format === 'ends_with')
                    return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${J.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                if (J.format === 'includes')
                    return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${J.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                if (J.format === 'regex')
                    return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${J.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
                return `\u7121\u52B9\u306A${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u7121\u52B9\u306A\u6570\u5024: ${Y.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            case 'unrecognized_keys':
                return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${Y.keys.length > 1 ? '\u7FA4' : ''}: ${C(Y.keys, '\u3001')}`;
            case 'invalid_key':
                return `${Y.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
            case 'invalid_union':
                return '\u7121\u52B9\u306A\u5165\u529B';
            case 'invalid_element':
                return `${Y.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
            default:
                return '\u7121\u52B9\u306A\u5165\u529B';
        }
    };
};
function i7() {
    return { localeError: yI() };
}
var hI = () => {
    let $ = {
        string: {
            unit: '\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A',
            verb: '\u1782\u17BD\u179A\u1798\u17B6\u1793',
        },
        file: {
            unit: '\u1794\u17C3',
            verb: '\u1782\u17BD\u179A\u1798\u17B6\u1793',
        },
        array: {
            unit: '\u1792\u17B6\u178F\u17BB',
            verb: '\u1782\u17BD\u179A\u1798\u17B6\u1793',
        },
        set: {
            unit: '\u1792\u17B6\u178F\u17BB',
            verb: '\u1782\u17BD\u179A\u1798\u17B6\u1793',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? '\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)'
                        : '\u179B\u17C1\u1781';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u17A2\u17B6\u179A\u17C1 (Array)';
                    if (Y === null)
                        return '\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B',
            email: '\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B',
            url: 'URL',
            emoji: '\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO',
            date: '\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO',
            time: '\u1798\u17C9\u17C4\u1784 ISO',
            duration: '\u179A\u1799\u17C8\u1796\u17C1\u179B ISO',
            ipv4: '\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4',
            ipv6: '\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6',
            cidrv4: '\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4',
            cidrv6: '\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6',
            base64: '\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64',
            base64url:
                '\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url',
            json_string:
                '\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON',
            e164: '\u179B\u17C1\u1781 E.164',
            jwt: 'JWT',
            template_literal:
                '\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${Y.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${h(Y.values[0])}`;
                return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${Y.origin ?? '\u178F\u1798\u17D2\u179B\u17C3'} ${J} ${Y.maximum.toString()} ${U.unit ?? '\u1792\u17B6\u178F\u17BB'}`;
                return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${Y.origin ?? '\u178F\u1798\u17D2\u179B\u17C3'} ${J} ${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${Y.origin} ${J} ${Y.minimum.toString()} ${U.unit}`;
                return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${Y.origin} ${J} ${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${J.pattern}`;
                return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${Y.origin}`;
            case 'invalid_union':
                return '\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C';
            case 'invalid_element':
                return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${Y.origin}`;
            default:
                return '\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C';
        }
    };
};
function n7() {
    return { localeError: hI() };
}
var mI = () => {
    let $ = {
        string: { unit: '\uBB38\uC790', verb: 'to have' },
        file: { unit: '\uBC14\uC774\uD2B8', verb: 'to have' },
        array: { unit: '\uAC1C', verb: 'to have' },
        set: { unit: '\uAC1C', verb: 'to have' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\uC785\uB825',
            email: '\uC774\uBA54\uC77C \uC8FC\uC18C',
            url: 'URL',
            emoji: '\uC774\uBAA8\uC9C0',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO \uB0A0\uC9DC\uC2DC\uAC04',
            date: 'ISO \uB0A0\uC9DC',
            time: 'ISO \uC2DC\uAC04',
            duration: 'ISO \uAE30\uAC04',
            ipv4: 'IPv4 \uC8FC\uC18C',
            ipv6: 'IPv6 \uC8FC\uC18C',
            cidrv4: 'IPv4 \uBC94\uC704',
            cidrv6: 'IPv6 \uBC94\uC704',
            base64: 'base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4',
            base64url: 'base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4',
            json_string: 'JSON \uBB38\uC790\uC5F4',
            e164: 'E.164 \uBC88\uD638',
            jwt: 'JWT',
            template_literal: '\uC785\uB825',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${Y.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${W(Y.input)}\uC785\uB2C8\uB2E4`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${h(Y.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
                return `\uC798\uBABB\uB41C \uC635\uC158: ${C(Y.values, '\uB610\uB294 ')} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
            case 'too_big': {
                let J = Y.inclusive ? '\uC774\uD558' : '\uBBF8\uB9CC',
                    U =
                        J === '\uBBF8\uB9CC'
                            ? '\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4'
                            : '\uC5EC\uC57C \uD569\uB2C8\uB2E4',
                    N = X(Y.origin),
                    M = N?.unit ?? '\uC694\uC18C';
                if (N)
                    return `${Y.origin ?? '\uAC12'}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${Y.maximum.toString()}${M} ${J}${U}`;
                return `${Y.origin ?? '\uAC12'}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${Y.maximum.toString()} ${J}${U}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '\uC774\uC0C1' : '\uCD08\uACFC',
                    U =
                        J === '\uC774\uC0C1'
                            ? '\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4'
                            : '\uC5EC\uC57C \uD569\uB2C8\uB2E4',
                    N = X(Y.origin),
                    M = N?.unit ?? '\uC694\uC18C';
                if (N)
                    return `${Y.origin ?? '\uAC12'}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${Y.minimum.toString()}${M} ${J}${U}`;
                return `${Y.origin ?? '\uAC12'}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${Y.minimum.toString()} ${J}${U}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${J.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
                if (J.format === 'ends_with')
                    return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${J.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
                if (J.format === 'includes')
                    return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${J.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
                if (J.format === 'regex')
                    return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${J.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
                return `\uC798\uBABB\uB41C ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\uC798\uBABB\uB41C \uC22B\uC790: ${Y.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
            case 'unrecognized_keys':
                return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\uC798\uBABB\uB41C \uD0A4: ${Y.origin}`;
            case 'invalid_union':
                return '\uC798\uBABB\uB41C \uC785\uB825';
            case 'invalid_element':
                return `\uC798\uBABB\uB41C \uAC12: ${Y.origin}`;
            default:
                return '\uC798\uBABB\uB41C \uC785\uB825';
        }
    };
};
function p7() {
    return { localeError: mI() };
}
var cI = () => {
    let $ = {
        string: {
            unit: '\u0437\u043D\u0430\u0446\u0438',
            verb: '\u0434\u0430 \u0438\u043C\u0430\u0430\u0442',
        },
        file: {
            unit: '\u0431\u0430\u0458\u0442\u0438',
            verb: '\u0434\u0430 \u0438\u043C\u0430\u0430\u0442',
        },
        array: {
            unit: '\u0441\u0442\u0430\u0432\u043A\u0438',
            verb: '\u0434\u0430 \u0438\u043C\u0430\u0430\u0442',
        },
        set: {
            unit: '\u0441\u0442\u0430\u0432\u043A\u0438',
            verb: '\u0434\u0430 \u0438\u043C\u0430\u0430\u0442',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u0431\u0440\u043E\u0458';
                case 'object': {
                    if (Array.isArray(Y)) return '\u043D\u0438\u0437\u0430';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0432\u043D\u0435\u0441',
            email: '\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430',
            url: 'URL',
            emoji: '\u0435\u043C\u043E\u045F\u0438',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                'ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435',
            date: 'ISO \u0434\u0430\u0442\u0443\u043C',
            time: 'ISO \u0432\u0440\u0435\u043C\u0435',
            duration:
                'ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435',
            ipv4: 'IPv4 \u0430\u0434\u0440\u0435\u0441\u0430',
            ipv6: 'IPv6 \u0430\u0434\u0440\u0435\u0441\u0430',
            cidrv4: 'IPv4 \u043E\u043F\u0441\u0435\u0433',
            cidrv6: 'IPv6 \u043E\u043F\u0441\u0435\u0433',
            base64: 'base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430',
            base64url:
                'base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430',
            json_string: 'JSON \u043D\u0438\u0437\u0430',
            e164: 'E.164 \u0431\u0440\u043E\u0458',
            jwt: 'JWT',
            template_literal: '\u0432\u043D\u0435\u0441',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${Y.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Invalid input: expected ${h(Y.values[0])}`;
                return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${Y.origin ?? '\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430'} \u0434\u0430 \u0438\u043C\u0430 ${J}${Y.maximum.toString()} ${U.unit ?? '\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438'}`;
                return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${Y.origin ?? '\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430'} \u0434\u0430 \u0431\u0438\u0434\u0435 ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${Y.origin} \u0434\u0430 \u0438\u043C\u0430 ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${Y.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${J.pattern}`;
                return `Invalid ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${Y.divisor}`;
            case 'unrecognized_keys':
                return `${Y.keys.length > 1 ? '\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438' : '\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${Y.origin}`;
            case 'invalid_union':
                return '\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441';
            case 'invalid_element':
                return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${Y.origin}`;
            default:
                return '\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441';
        }
    };
};
function l7() {
    return { localeError: cI() };
}
var uI = () => {
    let $ = {
        string: { unit: 'aksara', verb: 'mempunyai' },
        file: { unit: 'bait', verb: 'mempunyai' },
        array: { unit: 'elemen', verb: 'mempunyai' },
        set: { unit: 'elemen', verb: 'mempunyai' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'nombor';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'input',
            email: 'alamat e-mel',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'tarikh masa ISO',
            date: 'tarikh ISO',
            time: 'masa ISO',
            duration: 'tempoh ISO',
            ipv4: 'alamat IPv4',
            ipv6: 'alamat IPv6',
            cidrv4: 'julat IPv4',
            cidrv6: 'julat IPv6',
            base64: 'string dikodkan base64',
            base64url: 'string dikodkan base64url',
            json_string: 'string JSON',
            e164: 'nombor E.164',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Input tidak sah: dijangka ${Y.expected}, diterima ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Input tidak sah: dijangka ${h(Y.values[0])}`;
                return `Pilihan tidak sah: dijangka salah satu daripada ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Terlalu besar: dijangka ${Y.origin ?? 'nilai'} ${U.verb} ${J}${Y.maximum.toString()} ${U.unit ?? 'elemen'}`;
                return `Terlalu besar: dijangka ${Y.origin ?? 'nilai'} adalah ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Terlalu kecil: dijangka ${Y.origin} ${U.verb} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Terlalu kecil: dijangka ${Y.origin} adalah ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `String tidak sah: mesti bermula dengan "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `String tidak sah: mesti berakhir dengan "${J.suffix}"`;
                if (J.format === 'includes')
                    return `String tidak sah: mesti mengandungi "${J.includes}"`;
                if (J.format === 'regex')
                    return `String tidak sah: mesti sepadan dengan corak ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} tidak sah`;
            }
            case 'not_multiple_of':
                return `Nombor tidak sah: perlu gandaan ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Kunci tidak dikenali: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Kunci tidak sah dalam ${Y.origin}`;
            case 'invalid_union':
                return 'Input tidak sah';
            case 'invalid_element':
                return `Nilai tidak sah dalam ${Y.origin}`;
            default:
                return 'Input tidak sah';
        }
    };
};
function o7() {
    return { localeError: uI() };
}
var dI = () => {
    let $ = {
        string: { unit: 'tekens' },
        file: { unit: 'bytes' },
        array: { unit: 'elementen' },
        set: { unit: 'elementen' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'getal';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'invoer',
            email: 'emailadres',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO datum en tijd',
            date: 'ISO datum',
            time: 'ISO tijd',
            duration: 'ISO duur',
            ipv4: 'IPv4-adres',
            ipv6: 'IPv6-adres',
            cidrv4: 'IPv4-bereik',
            cidrv6: 'IPv6-bereik',
            base64: 'base64-gecodeerde tekst',
            base64url: 'base64 URL-gecodeerde tekst',
            json_string: 'JSON string',
            e164: 'E.164-nummer',
            jwt: 'JWT',
            template_literal: 'invoer',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Ongeldige invoer: verwacht ${Y.expected}, ontving ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Ongeldige invoer: verwacht ${h(Y.values[0])}`;
                return `Ongeldige optie: verwacht \xE9\xE9n van ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Te lang: verwacht dat ${Y.origin ?? 'waarde'} ${J}${Y.maximum.toString()} ${U.unit ?? 'elementen'} bevat`;
                return `Te lang: verwacht dat ${Y.origin ?? 'waarde'} ${J}${Y.maximum.toString()} is`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Te kort: verwacht dat ${Y.origin} ${J}${Y.minimum.toString()} ${U.unit} bevat`;
                return `Te kort: verwacht dat ${Y.origin} ${J}${Y.minimum.toString()} is`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Ongeldige tekst: moet met "${J.prefix}" beginnen`;
                if (J.format === 'ends_with')
                    return `Ongeldige tekst: moet op "${J.suffix}" eindigen`;
                if (J.format === 'includes')
                    return `Ongeldige tekst: moet "${J.includes}" bevatten`;
                if (J.format === 'regex')
                    return `Ongeldige tekst: moet overeenkomen met patroon ${J.pattern}`;
                return `Ongeldig: ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Ongeldig getal: moet een veelvoud van ${Y.divisor} zijn`;
            case 'unrecognized_keys':
                return `Onbekende key${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Ongeldige key in ${Y.origin}`;
            case 'invalid_union':
                return 'Ongeldige invoer';
            case 'invalid_element':
                return `Ongeldige waarde in ${Y.origin}`;
            default:
                return 'Ongeldige invoer';
        }
    };
};
function r7() {
    return { localeError: dI() };
}
var iI = () => {
    let $ = {
        string: { unit: 'tegn', verb: '\xE5 ha' },
        file: { unit: 'bytes', verb: '\xE5 ha' },
        array: { unit: 'elementer', verb: '\xE5 inneholde' },
        set: { unit: 'elementer', verb: '\xE5 inneholde' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'tall';
                case 'object': {
                    if (Array.isArray(Y)) return 'liste';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'input',
            email: 'e-postadresse',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO dato- og klokkeslett',
            date: 'ISO-dato',
            time: 'ISO-klokkeslett',
            duration: 'ISO-varighet',
            ipv4: 'IPv4-omr\xE5de',
            ipv6: 'IPv6-omr\xE5de',
            cidrv4: 'IPv4-spekter',
            cidrv6: 'IPv6-spekter',
            base64: 'base64-enkodet streng',
            base64url: 'base64url-enkodet streng',
            json_string: 'JSON-streng',
            e164: 'E.164-nummer',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Ugyldig input: forventet ${Y.expected}, fikk ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Ugyldig verdi: forventet ${h(Y.values[0])}`;
                return `Ugyldig valg: forventet en av ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `For stor(t): forventet ${Y.origin ?? 'value'} til \xE5 ha ${J}${Y.maximum.toString()} ${U.unit ?? 'elementer'}`;
                return `For stor(t): forventet ${Y.origin ?? 'value'} til \xE5 ha ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `For lite(n): forventet ${Y.origin} til \xE5 ha ${J}${Y.minimum.toString()} ${U.unit}`;
                return `For lite(n): forventet ${Y.origin} til \xE5 ha ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Ugyldig streng: m\xE5 starte med "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Ugyldig streng: m\xE5 ende med "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Ugyldig streng: m\xE5 inneholde "${J.includes}"`;
                if (J.format === 'regex')
                    return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${J.pattern}`;
                return `Ugyldig ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${Y.divisor}`;
            case 'unrecognized_keys':
                return `${Y.keys.length > 1 ? 'Ukjente n\xF8kler' : 'Ukjent n\xF8kkel'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Ugyldig n\xF8kkel i ${Y.origin}`;
            case 'invalid_union':
                return 'Ugyldig input';
            case 'invalid_element':
                return `Ugyldig verdi i ${Y.origin}`;
            default:
                return 'Ugyldig input';
        }
    };
};
function t7() {
    return { localeError: iI() };
}
var nI = () => {
    let $ = {
        string: { unit: 'harf', verb: 'olmal\u0131d\u0131r' },
        file: { unit: 'bayt', verb: 'olmal\u0131d\u0131r' },
        array: { unit: 'unsur', verb: 'olmal\u0131d\u0131r' },
        set: { unit: 'unsur', verb: 'olmal\u0131d\u0131r' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'numara';
                case 'object': {
                    if (Array.isArray(Y)) return 'saf';
                    if (Y === null) return 'gayb';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'giren',
            email: 'epostag\xE2h',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO heng\xE2m\u0131',
            date: 'ISO tarihi',
            time: 'ISO zaman\u0131',
            duration: 'ISO m\xFCddeti',
            ipv4: 'IPv4 ni\u015F\xE2n\u0131',
            ipv6: 'IPv6 ni\u015F\xE2n\u0131',
            cidrv4: 'IPv4 menzili',
            cidrv6: 'IPv6 menzili',
            base64: 'base64-\u015Fifreli metin',
            base64url: 'base64url-\u015Fifreli metin',
            json_string: 'JSON metin',
            e164: 'E.164 say\u0131s\u0131',
            jwt: 'JWT',
            template_literal: 'giren',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `F\xE2sit giren: umulan ${Y.expected}, al\u0131nan ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `F\xE2sit giren: umulan ${h(Y.values[0])}`;
                return `F\xE2sit tercih: m\xFBteberler ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Fazla b\xFCy\xFCk: ${Y.origin ?? 'value'}, ${J}${Y.maximum.toString()} ${U.unit ?? 'elements'} sahip olmal\u0131yd\u0131.`;
                return `Fazla b\xFCy\xFCk: ${Y.origin ?? 'value'}, ${J}${Y.maximum.toString()} olmal\u0131yd\u0131.`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Fazla k\xFC\xE7\xFCk: ${Y.origin}, ${J}${Y.minimum.toString()} ${U.unit} sahip olmal\u0131yd\u0131.`;
                return `Fazla k\xFC\xE7\xFCk: ${Y.origin}, ${J}${Y.minimum.toString()} olmal\u0131yd\u0131.`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `F\xE2sit metin: "${J.prefix}" ile ba\u015Flamal\u0131.`;
                if (J.format === 'ends_with')
                    return `F\xE2sit metin: "${J.suffix}" ile bitmeli.`;
                if (J.format === 'includes')
                    return `F\xE2sit metin: "${J.includes}" ihtiv\xE2 etmeli.`;
                if (J.format === 'regex')
                    return `F\xE2sit metin: ${J.pattern} nak\u015F\u0131na uymal\u0131.`;
                return `F\xE2sit ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `F\xE2sit say\u0131: ${Y.divisor} kat\u0131 olmal\u0131yd\u0131.`;
            case 'unrecognized_keys':
                return `Tan\u0131nmayan anahtar ${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `${Y.origin} i\xE7in tan\u0131nmayan anahtar var.`;
            case 'invalid_union':
                return 'Giren tan\u0131namad\u0131.';
            case 'invalid_element':
                return `${Y.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
            default:
                return 'K\u0131ymet tan\u0131namad\u0131.';
        }
    };
};
function a7() {
    return { localeError: nI() };
}
var pI = () => {
    let $ = {
        string: {
            unit: '\u062A\u0648\u06A9\u064A',
            verb: '\u0648\u0644\u0631\u064A',
        },
        file: {
            unit: '\u0628\u0627\u06CC\u067C\u0633',
            verb: '\u0648\u0644\u0631\u064A',
        },
        array: {
            unit: '\u062A\u0648\u06A9\u064A',
            verb: '\u0648\u0644\u0631\u064A',
        },
        set: {
            unit: '\u062A\u0648\u06A9\u064A',
            verb: '\u0648\u0644\u0631\u064A',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u0639\u062F\u062F';
                case 'object': {
                    if (Array.isArray(Y)) return '\u0627\u0631\u06D0';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0648\u0631\u0648\u062F\u064A',
            email: '\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9',
            url: '\u06CC\u0648 \u0622\u0631 \u0627\u0644',
            emoji: '\u0627\u06CC\u0645\u0648\u062C\u064A',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A',
            date: '\u0646\u06D0\u067C\u0647',
            time: '\u0648\u062E\u062A',
            duration: '\u0645\u0648\u062F\u0647',
            ipv4: '\u062F IPv4 \u067E\u062A\u0647',
            ipv6: '\u062F IPv6 \u067E\u062A\u0647',
            cidrv4: '\u062F IPv4 \u0633\u0627\u062D\u0647',
            cidrv6: '\u062F IPv6 \u0633\u0627\u062D\u0647',
            base64: 'base64-encoded \u0645\u062A\u0646',
            base64url: 'base64url-encoded \u0645\u062A\u0646',
            json_string: 'JSON \u0645\u062A\u0646',
            e164: '\u062F E.164 \u0634\u0645\u06D0\u0631\u0647',
            jwt: 'JWT',
            template_literal: '\u0648\u0631\u0648\u062F\u064A',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${Y.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${W(Y.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${h(Y.values[0])} \u0648\u0627\u06CC`;
                return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${C(Y.values, '|')} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${Y.origin ?? '\u0627\u0631\u0632\u069A\u062A'} \u0628\u0627\u06CC\u062F ${J}${Y.maximum.toString()} ${U.unit ?? '\u0639\u0646\u0635\u0631\u0648\u0646\u0647'} \u0648\u0644\u0631\u064A`;
                return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${Y.origin ?? '\u0627\u0631\u0632\u069A\u062A'} \u0628\u0627\u06CC\u062F ${J}${Y.maximum.toString()} \u0648\u064A`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${Y.origin} \u0628\u0627\u06CC\u062F ${J}${Y.minimum.toString()} ${U.unit} \u0648\u0644\u0631\u064A`;
                return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${Y.origin} \u0628\u0627\u06CC\u062F ${J}${Y.minimum.toString()} \u0648\u064A`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${J.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
                if (J.format === 'ends_with')
                    return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${J.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
                if (J.format === 'includes')
                    return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${J.includes}" \u0648\u0644\u0631\u064A`;
                if (J.format === 'regex')
                    return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${J.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
                return `${Q[J.format] ?? Y.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
            }
            case 'not_multiple_of':
                return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${Y.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
            case 'unrecognized_keys':
                return `\u0646\u0627\u0633\u0645 ${Y.keys.length > 1 ? '\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647' : '\u06A9\u0644\u06CC\u0689'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${Y.origin} \u06A9\u06D0`;
            case 'invalid_union':
                return '\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A';
            case 'invalid_element':
                return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${Y.origin} \u06A9\u06D0`;
            default:
                return '\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A';
        }
    };
};
function s7() {
    return { localeError: pI() };
}
var lI = () => {
    let $ = {
        string: { unit: 'znak\xF3w', verb: 'mie\u0107' },
        file: { unit: 'bajt\xF3w', verb: 'mie\u0107' },
        array: { unit: 'element\xF3w', verb: 'mie\u0107' },
        set: { unit: 'element\xF3w', verb: 'mie\u0107' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'liczba';
                case 'object': {
                    if (Array.isArray(Y)) return 'tablica';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'wyra\u017Cenie',
            email: 'adres email',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'data i godzina w formacie ISO',
            date: 'data w formacie ISO',
            time: 'godzina w formacie ISO',
            duration: 'czas trwania ISO',
            ipv4: 'adres IPv4',
            ipv6: 'adres IPv6',
            cidrv4: 'zakres IPv4',
            cidrv6: 'zakres IPv6',
            base64: 'ci\u0105g znak\xF3w zakodowany w formacie base64',
            base64url: 'ci\u0105g znak\xF3w zakodowany w formacie base64url',
            json_string: 'ci\u0105g znak\xF3w w formacie JSON',
            e164: 'liczba E.164',
            jwt: 'JWT',
            template_literal: 'wej\u015Bcie',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${Y.expected}, otrzymano ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${h(Y.values[0])}`;
                return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${Y.origin ?? 'warto\u015B\u0107'} b\u0119dzie mie\u0107 ${J}${Y.maximum.toString()} ${U.unit ?? 'element\xF3w'}`;
                return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${Y.origin ?? 'warto\u015B\u0107'} b\u0119dzie wynosi\u0107 ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${Y.origin ?? 'warto\u015B\u0107'} b\u0119dzie mie\u0107 ${J}${Y.minimum.toString()} ${U.unit ?? 'element\xF3w'}`;
                return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${Y.origin ?? 'warto\u015B\u0107'} b\u0119dzie wynosi\u0107 ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${J.includes}"`;
                if (J.format === 'regex')
                    return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${J.pattern}`;
                return `Nieprawid\u0142ow(y/a/e) ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Nierozpoznane klucze${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Nieprawid\u0142owy klucz w ${Y.origin}`;
            case 'invalid_union':
                return 'Nieprawid\u0142owe dane wej\u015Bciowe';
            case 'invalid_element':
                return `Nieprawid\u0142owa warto\u015B\u0107 w ${Y.origin}`;
            default:
                return 'Nieprawid\u0142owe dane wej\u015Bciowe';
        }
    };
};
function e7() {
    return { localeError: lI() };
}
var oI = () => {
    let $ = {
        string: { unit: 'caracteres', verb: 'ter' },
        file: { unit: 'bytes', verb: 'ter' },
        array: { unit: 'itens', verb: 'ter' },
        set: { unit: 'itens', verb: 'ter' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'n\xFAmero';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'nulo';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'padr\xE3o',
            email: 'endere\xE7o de e-mail',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'data e hora ISO',
            date: 'data ISO',
            time: 'hora ISO',
            duration: 'dura\xE7\xE3o ISO',
            ipv4: 'endere\xE7o IPv4',
            ipv6: 'endere\xE7o IPv6',
            cidrv4: 'faixa de IPv4',
            cidrv6: 'faixa de IPv6',
            base64: 'texto codificado em base64',
            base64url: 'URL codificada em base64',
            json_string: 'texto JSON',
            e164: 'n\xFAmero E.164',
            jwt: 'JWT',
            template_literal: 'entrada',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Tipo inv\xE1lido: esperado ${Y.expected}, recebido ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Entrada inv\xE1lida: esperado ${h(Y.values[0])}`;
                return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Muito grande: esperado que ${Y.origin ?? 'valor'} tivesse ${J}${Y.maximum.toString()} ${U.unit ?? 'elementos'}`;
                return `Muito grande: esperado que ${Y.origin ?? 'valor'} fosse ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Muito pequeno: esperado que ${Y.origin} tivesse ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Muito pequeno: esperado que ${Y.origin} fosse ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Texto inv\xE1lido: deve come\xE7ar com "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Texto inv\xE1lido: deve terminar com "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Texto inv\xE1lido: deve incluir "${J.includes}"`;
                if (J.format === 'regex')
                    return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} inv\xE1lido`;
            }
            case 'not_multiple_of':
                return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Chave${Y.keys.length > 1 ? 's' : ''} desconhecida${Y.keys.length > 1 ? 's' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Chave inv\xE1lida em ${Y.origin}`;
            case 'invalid_union':
                return 'Entrada inv\xE1lida';
            case 'invalid_element':
                return `Valor inv\xE1lido em ${Y.origin}`;
            default:
                return 'Campo inv\xE1lido';
        }
    };
};
function $5() {
    return { localeError: oI() };
}
function Rw($, X, W, Q) {
    let Y = Math.abs($),
        J = Y % 10,
        U = Y % 100;
    if (U >= 11 && U <= 19) return Q;
    if (J === 1) return X;
    if (J >= 2 && J <= 4) return W;
    return Q;
}
var rI = () => {
    let $ = {
        string: {
            unit: {
                one: '\u0441\u0438\u043C\u0432\u043E\u043B',
                few: '\u0441\u0438\u043C\u0432\u043E\u043B\u0430',
                many: '\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432',
            },
            verb: '\u0438\u043C\u0435\u0442\u044C',
        },
        file: {
            unit: {
                one: '\u0431\u0430\u0439\u0442',
                few: '\u0431\u0430\u0439\u0442\u0430',
                many: '\u0431\u0430\u0439\u0442',
            },
            verb: '\u0438\u043C\u0435\u0442\u044C',
        },
        array: {
            unit: {
                one: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442',
                few: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430',
                many: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432',
            },
            verb: '\u0438\u043C\u0435\u0442\u044C',
        },
        set: {
            unit: {
                one: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442',
                few: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430',
                many: '\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432',
            },
            verb: '\u0438\u043C\u0435\u0442\u044C',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? 'NaN'
                        : '\u0447\u0438\u0441\u043B\u043E';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u043C\u0430\u0441\u0441\u0438\u0432';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0432\u0432\u043E\u0434',
            email: 'email \u0430\u0434\u0440\u0435\u0441',
            url: 'URL',
            emoji: '\u044D\u043C\u043E\u0434\u0437\u0438',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                'ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F',
            date: 'ISO \u0434\u0430\u0442\u0430',
            time: 'ISO \u0432\u0440\u0435\u043C\u044F',
            duration:
                'ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C',
            ipv4: 'IPv4 \u0430\u0434\u0440\u0435\u0441',
            ipv6: 'IPv6 \u0430\u0434\u0440\u0435\u0441',
            cidrv4: 'IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D',
            cidrv6: 'IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D',
            base64: '\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64',
            base64url:
                '\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url',
            json_string: 'JSON \u0441\u0442\u0440\u043E\u043A\u0430',
            e164: '\u043D\u043E\u043C\u0435\u0440 E.164',
            jwt: 'JWT',
            template_literal: '\u0432\u0432\u043E\u0434',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${Y.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${h(Y.values[0])}`;
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U) {
                    let N = Number(Y.maximum),
                        M = Rw(N, U.unit.one, U.unit.few, U.unit.many);
                    return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435'} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${J}${Y.maximum.toString()} ${M}`;
                }
                return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435'} \u0431\u0443\u0434\u0435\u0442 ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U) {
                    let N = Number(Y.minimum),
                        M = Rw(N, U.unit.one, U.unit.few, U.unit.many);
                    return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${Y.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${J}${Y.minimum.toString()} ${M}`;
                }
                return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${Y.origin} \u0431\u0443\u0434\u0435\u0442 ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${J.pattern}`;
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${Y.keys.length > 1 ? '\u044B\u0435' : '\u044B\u0439'} \u043A\u043B\u044E\u0447${Y.keys.length > 1 ? '\u0438' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${Y.origin}`;
            case 'invalid_union':
                return '\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435';
            case 'invalid_element':
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${Y.origin}`;
            default:
                return '\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435';
        }
    };
};
function X5() {
    return { localeError: rI() };
}
var tI = () => {
    let $ = {
        string: { unit: 'znakov', verb: 'imeti' },
        file: { unit: 'bajtov', verb: 'imeti' },
        array: { unit: 'elementov', verb: 'imeti' },
        set: { unit: 'elementov', verb: 'imeti' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u0161tevilo';
                case 'object': {
                    if (Array.isArray(Y)) return 'tabela';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'vnos',
            email: 'e-po\u0161tni naslov',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO datum in \u010Das',
            date: 'ISO datum',
            time: 'ISO \u010Das',
            duration: 'ISO trajanje',
            ipv4: 'IPv4 naslov',
            ipv6: 'IPv6 naslov',
            cidrv4: 'obseg IPv4',
            cidrv6: 'obseg IPv6',
            base64: 'base64 kodiran niz',
            base64url: 'base64url kodiran niz',
            json_string: 'JSON niz',
            e164: 'E.164 \u0161tevilka',
            jwt: 'JWT',
            template_literal: 'vnos',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Neveljaven vnos: pri\u010Dakovano ${Y.expected}, prejeto ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Neveljaven vnos: pri\u010Dakovano ${h(Y.values[0])}`;
                return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Preveliko: pri\u010Dakovano, da bo ${Y.origin ?? 'vrednost'} imelo ${J}${Y.maximum.toString()} ${U.unit ?? 'elementov'}`;
                return `Preveliko: pri\u010Dakovano, da bo ${Y.origin ?? 'vrednost'} ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Premajhno: pri\u010Dakovano, da bo ${Y.origin} imelo ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Premajhno: pri\u010Dakovano, da bo ${Y.origin} ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Neveljaven niz: mora se za\u010Deti z "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Neveljaven niz: mora se kon\u010Dati z "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Neveljaven niz: mora vsebovati "${J.includes}"`;
                if (J.format === 'regex')
                    return `Neveljaven niz: mora ustrezati vzorcu ${J.pattern}`;
                return `Neveljaven ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Neprepoznan${Y.keys.length > 1 ? 'i klju\u010Di' : ' klju\u010D'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Neveljaven klju\u010D v ${Y.origin}`;
            case 'invalid_union':
                return 'Neveljaven vnos';
            case 'invalid_element':
                return `Neveljavna vrednost v ${Y.origin}`;
            default:
                return 'Neveljaven vnos';
        }
    };
};
function W5() {
    return { localeError: tI() };
}
var aI = () => {
    let $ = {
        string: { unit: 'tecken', verb: 'att ha' },
        file: { unit: 'bytes', verb: 'att ha' },
        array: { unit: 'objekt', verb: 'att inneh\xE5lla' },
        set: { unit: 'objekt', verb: 'att inneh\xE5lla' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'antal';
                case 'object': {
                    if (Array.isArray(Y)) return 'lista';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: 'regulj\xE4rt uttryck',
            email: 'e-postadress',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO-datum och tid',
            date: 'ISO-datum',
            time: 'ISO-tid',
            duration: 'ISO-varaktighet',
            ipv4: 'IPv4-intervall',
            ipv6: 'IPv6-intervall',
            cidrv4: 'IPv4-spektrum',
            cidrv6: 'IPv6-spektrum',
            base64: 'base64-kodad str\xE4ng',
            base64url: 'base64url-kodad str\xE4ng',
            json_string: 'JSON-str\xE4ng',
            e164: 'E.164-nummer',
            jwt: 'JWT',
            template_literal: 'mall-literal',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `Ogiltig inmatning: f\xF6rv\xE4ntat ${Y.expected}, fick ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `Ogiltig inmatning: f\xF6rv\xE4ntat ${h(Y.values[0])}`;
                return `Ogiltigt val: f\xF6rv\xE4ntade en av ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `F\xF6r stor(t): f\xF6rv\xE4ntade ${Y.origin ?? 'v\xE4rdet'} att ha ${J}${Y.maximum.toString()} ${U.unit ?? 'element'}`;
                return `F\xF6r stor(t): f\xF6rv\xE4ntat ${Y.origin ?? 'v\xE4rdet'} att ha ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `F\xF6r lite(t): f\xF6rv\xE4ntade ${Y.origin ?? 'v\xE4rdet'} att ha ${J}${Y.minimum.toString()} ${U.unit}`;
                return `F\xF6r lite(t): f\xF6rv\xE4ntade ${Y.origin ?? 'v\xE4rdet'} att ha ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Ogiltig str\xE4ng: m\xE5ste sluta med "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${J.includes}"`;
                if (J.format === 'regex')
                    return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${J.pattern}"`;
                return `Ogiltig(t) ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `Ogiltigt tal: m\xE5ste vara en multipel av ${Y.divisor}`;
            case 'unrecognized_keys':
                return `${Y.keys.length > 1 ? 'Ok\xE4nda nycklar' : 'Ok\xE4nd nyckel'}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Ogiltig nyckel i ${Y.origin ?? 'v\xE4rdet'}`;
            case 'invalid_union':
                return 'Ogiltig input';
            case 'invalid_element':
                return `Ogiltigt v\xE4rde i ${Y.origin ?? 'v\xE4rdet'}`;
            default:
                return 'Ogiltig input';
        }
    };
};
function Y5() {
    return { localeError: aI() };
}
var sI = () => {
    let $ = {
        string: {
            unit: '\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD',
            verb: '\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD',
        },
        file: {
            unit: '\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD',
            verb: '\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD',
        },
        array: {
            unit: '\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD',
            verb: '\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD',
        },
        set: {
            unit: '\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD',
            verb: '\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? '\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1'
                        : '\u0B8E\u0BA3\u0BCD';
                case 'object': {
                    if (Array.isArray(Y)) return '\u0B85\u0BA3\u0BBF';
                    if (Y === null)
                        return '\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1',
            email: '\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                'ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD',
            date: 'ISO \u0BA4\u0BC7\u0BA4\u0BBF',
            time: 'ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD',
            duration: 'ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1',
            ipv4: 'IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF',
            ipv6: 'IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF',
            cidrv4: 'IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1',
            cidrv6: 'IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1',
            base64: 'base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD',
            base64url: 'base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD',
            json_string: 'JSON \u0B9A\u0BB0\u0BAE\u0BCD',
            e164: 'E.164 \u0B8E\u0BA3\u0BCD',
            jwt: 'JWT',
            template_literal: 'input',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${Y.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${h(Y.values[0])}`;
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${C(Y.values, '|')} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${Y.origin ?? '\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1'} ${J}${Y.maximum.toString()} ${U.unit ?? '\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD'} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${Y.origin ?? '\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1'} ${J}${Y.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${Y.origin} ${J}${Y.minimum.toString()} ${U.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${Y.origin} ${J}${Y.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${J.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                if (J.format === 'ends_with')
                    return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${J.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                if (J.format === 'includes')
                    return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${J.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                if (J.format === 'regex')
                    return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${J.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${Y.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            case 'unrecognized_keys':
                return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${Y.keys.length > 1 ? '\u0B95\u0BB3\u0BCD' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `${Y.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
            case 'invalid_union':
                return '\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1';
            case 'invalid_element':
                return `${Y.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
            default:
                return '\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1';
        }
    };
};
function Q5() {
    return { localeError: sI() };
}
var eI = () => {
    let $ = {
        string: {
            unit: '\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23',
            verb: '\u0E04\u0E27\u0E23\u0E21\u0E35',
        },
        file: {
            unit: '\u0E44\u0E1A\u0E15\u0E4C',
            verb: '\u0E04\u0E27\u0E23\u0E21\u0E35',
        },
        array: {
            unit: '\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23',
            verb: '\u0E04\u0E27\u0E23\u0E21\u0E35',
        },
        set: {
            unit: '\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23',
            verb: '\u0E04\u0E27\u0E23\u0E21\u0E35',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? '\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)'
                        : '\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)';
                    if (Y === null)
                        return '\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19',
            email: '\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25',
            url: 'URL',
            emoji: '\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO',
            date: '\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO',
            time: '\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO',
            duration:
                '\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO',
            ipv4: '\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4',
            ipv6: '\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6',
            cidrv4: '\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4',
            cidrv6: '\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6',
            base64: '\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64',
            base64url:
                '\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL',
            json_string:
                '\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON',
            e164: '\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)',
            jwt: '\u0E42\u0E17\u0E40\u0E04\u0E19 JWT',
            template_literal:
                '\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${Y.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${h(Y.values[0])}`;
                return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive
                        ? '\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19'
                        : '\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32',
                    U = X(Y.origin);
                if (U)
                    return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${Y.origin ?? '\u0E04\u0E48\u0E32'} \u0E04\u0E27\u0E23\u0E21\u0E35${J} ${Y.maximum.toString()} ${U.unit ?? '\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23'}`;
                return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${Y.origin ?? '\u0E04\u0E48\u0E32'} \u0E04\u0E27\u0E23\u0E21\u0E35${J} ${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive
                        ? '\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22'
                        : '\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32',
                    U = X(Y.origin);
                if (U)
                    return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${Y.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${J} ${Y.minimum.toString()} ${U.unit}`;
                return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${Y.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${J} ${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${J.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
                if (J.format === 'regex')
                    return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${J.pattern}`;
                return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${Y.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
            case 'unrecognized_keys':
                return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${Y.origin}`;
            case 'invalid_union':
                return '\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49';
            case 'invalid_element':
                return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${Y.origin}`;
            default:
                return '\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07';
        }
    };
};
function J5() {
    return { localeError: eI() };
}
var $C = ($) => {
        let X = typeof $;
        switch (X) {
            case 'number':
                return Number.isNaN($) ? 'NaN' : 'number';
            case 'object': {
                if (Array.isArray($)) return 'array';
                if ($ === null) return 'null';
                if (
                    Object.getPrototypeOf($) !== Object.prototype &&
                    $.constructor
                )
                    return $.constructor.name;
            }
        }
        return X;
    },
    XC = () => {
        let $ = {
            string: { unit: 'karakter', verb: 'olmal\u0131' },
            file: { unit: 'bayt', verb: 'olmal\u0131' },
            array: { unit: '\xF6\u011Fe', verb: 'olmal\u0131' },
            set: { unit: '\xF6\u011Fe', verb: 'olmal\u0131' },
        };
        function X(Q) {
            return $[Q] ?? null;
        }
        let W = {
            regex: 'girdi',
            email: 'e-posta adresi',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO tarih ve saat',
            date: 'ISO tarih',
            time: 'ISO saat',
            duration: 'ISO s\xFCre',
            ipv4: 'IPv4 adresi',
            ipv6: 'IPv6 adresi',
            cidrv4: 'IPv4 aral\u0131\u011F\u0131',
            cidrv6: 'IPv6 aral\u0131\u011F\u0131',
            base64: 'base64 ile \u015Fifrelenmi\u015F metin',
            base64url: 'base64url ile \u015Fifrelenmi\u015F metin',
            json_string: 'JSON dizesi',
            e164: 'E.164 say\u0131s\u0131',
            jwt: 'JWT',
            template_literal: '\u015Eablon dizesi',
        };
        return (Q) => {
            switch (Q.code) {
                case 'invalid_type':
                    return `Ge\xE7ersiz de\u011Fer: beklenen ${Q.expected}, al\u0131nan ${$C(Q.input)}`;
                case 'invalid_value':
                    if (Q.values.length === 1)
                        return `Ge\xE7ersiz de\u011Fer: beklenen ${h(Q.values[0])}`;
                    return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${C(Q.values, '|')}`;
                case 'too_big': {
                    let Y = Q.inclusive ? '<=' : '<',
                        J = X(Q.origin);
                    if (J)
                        return `\xC7ok b\xFCy\xFCk: beklenen ${Q.origin ?? 'de\u011Fer'} ${Y}${Q.maximum.toString()} ${J.unit ?? '\xF6\u011Fe'}`;
                    return `\xC7ok b\xFCy\xFCk: beklenen ${Q.origin ?? 'de\u011Fer'} ${Y}${Q.maximum.toString()}`;
                }
                case 'too_small': {
                    let Y = Q.inclusive ? '>=' : '>',
                        J = X(Q.origin);
                    if (J)
                        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${Q.origin} ${Y}${Q.minimum.toString()} ${J.unit}`;
                    return `\xC7ok k\xFC\xE7\xFCk: beklenen ${Q.origin} ${Y}${Q.minimum.toString()}`;
                }
                case 'invalid_format': {
                    let Y = Q;
                    if (Y.format === 'starts_with')
                        return `Ge\xE7ersiz metin: "${Y.prefix}" ile ba\u015Flamal\u0131`;
                    if (Y.format === 'ends_with')
                        return `Ge\xE7ersiz metin: "${Y.suffix}" ile bitmeli`;
                    if (Y.format === 'includes')
                        return `Ge\xE7ersiz metin: "${Y.includes}" i\xE7ermeli`;
                    if (Y.format === 'regex')
                        return `Ge\xE7ersiz metin: ${Y.pattern} desenine uymal\u0131`;
                    return `Ge\xE7ersiz ${W[Y.format] ?? Q.format}`;
                }
                case 'not_multiple_of':
                    return `Ge\xE7ersiz say\u0131: ${Q.divisor} ile tam b\xF6l\xFCnebilmeli`;
                case 'unrecognized_keys':
                    return `Tan\u0131nmayan anahtar${Q.keys.length > 1 ? 'lar' : ''}: ${C(Q.keys, ', ')}`;
                case 'invalid_key':
                    return `${Q.origin} i\xE7inde ge\xE7ersiz anahtar`;
                case 'invalid_union':
                    return 'Ge\xE7ersiz de\u011Fer';
                case 'invalid_element':
                    return `${Q.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
                default:
                    return 'Ge\xE7ersiz de\u011Fer';
            }
        };
    };
function U5() {
    return { localeError: XC() };
}
var WC = () => {
    let $ = {
        string: {
            unit: '\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432',
            verb: '\u043C\u0430\u0442\u0438\u043C\u0435',
        },
        file: {
            unit: '\u0431\u0430\u0439\u0442\u0456\u0432',
            verb: '\u043C\u0430\u0442\u0438\u043C\u0435',
        },
        array: {
            unit: '\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432',
            verb: '\u043C\u0430\u0442\u0438\u043C\u0435',
        },
        set: {
            unit: '\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432',
            verb: '\u043C\u0430\u0442\u0438\u043C\u0435',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? 'NaN'
                        : '\u0447\u0438\u0441\u043B\u043E';
                case 'object': {
                    if (Array.isArray(Y))
                        return '\u043C\u0430\u0441\u0438\u0432';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456',
            email: '\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438',
            url: 'URL',
            emoji: '\u0435\u043C\u043E\u0434\u0437\u0456',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime:
                '\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO',
            date: '\u0434\u0430\u0442\u0430 ISO',
            time: '\u0447\u0430\u0441 ISO',
            duration:
                '\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO',
            ipv4: '\u0430\u0434\u0440\u0435\u0441\u0430 IPv4',
            ipv6: '\u0430\u0434\u0440\u0435\u0441\u0430 IPv6',
            cidrv4: '\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4',
            cidrv6: '\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6',
            base64: '\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64',
            base64url:
                '\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url',
            json_string: '\u0440\u044F\u0434\u043E\u043A JSON',
            e164: '\u043D\u043E\u043C\u0435\u0440 E.164',
            jwt: 'JWT',
            template_literal:
                '\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${Y.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${h(Y.values[0])}`;
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F'} ${U.verb} ${J}${Y.maximum.toString()} ${U.unit ?? '\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432'}`;
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${Y.origin ?? '\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F'} \u0431\u0443\u0434\u0435 ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${Y.origin} ${U.verb} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${Y.origin} \u0431\u0443\u0434\u0435 ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${J.suffix}"`;
                if (J.format === 'includes')
                    return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${J.pattern}`;
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${Y.divisor}`;
            case 'unrecognized_keys':
                return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${Y.keys.length > 1 ? '\u0456' : ''}: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${Y.origin}`;
            case 'invalid_union':
                return '\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456';
            case 'invalid_element':
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${Y.origin}`;
            default:
                return '\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456';
        }
    };
};
function N5() {
    return { localeError: WC() };
}
var YC = () => {
    let $ = {
        string: {
            unit: '\u062D\u0631\u0648\u0641',
            verb: '\u06C1\u0648\u0646\u0627',
        },
        file: {
            unit: '\u0628\u0627\u0626\u0679\u0633',
            verb: '\u06C1\u0648\u0646\u0627',
        },
        array: {
            unit: '\u0622\u0626\u0679\u0645\u0632',
            verb: '\u06C1\u0648\u0646\u0627',
        },
        set: {
            unit: '\u0622\u0626\u0679\u0645\u0632',
            verb: '\u06C1\u0648\u0646\u0627',
        },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : '\u0646\u0645\u0628\u0631';
                case 'object': {
                    if (Array.isArray(Y)) return '\u0622\u0631\u06D2';
                    if (Y === null) return '\u0646\u0644';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0627\u0646 \u067E\u0679',
            email: '\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633',
            url: '\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644',
            emoji: '\u0627\u06CC\u0645\u0648\u062C\u06CC',
            uuid: '\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC',
            uuidv4: '\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4',
            uuidv6: '\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6',
            nanoid: '\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC',
            guid: '\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC',
            cuid: '\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC',
            cuid2: '\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2',
            ulid: '\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC',
            xid: '\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC',
            ksuid: '\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC',
            datetime:
                '\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645',
            date: '\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E',
            time: '\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A',
            duration:
                '\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A',
            ipv4: '\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633',
            ipv6: '\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633',
            cidrv4: '\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C',
            cidrv6: '\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C',
            base64: '\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF',
            base64url:
                '\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF',
            json_string:
                '\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF',
            e164: '\u0627\u06CC 164 \u0646\u0645\u0628\u0631',
            jwt: '\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC',
            template_literal: '\u0627\u0646 \u067E\u0679',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${Y.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${W(Y.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${h(Y.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
                return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${C(Y.values, '|')} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${Y.origin ?? '\u0648\u06CC\u0644\u06CC\u0648'} \u06A9\u06D2 ${J}${Y.maximum.toString()} ${U.unit ?? '\u0639\u0646\u0627\u0635\u0631'} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
                return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${Y.origin ?? '\u0648\u06CC\u0644\u06CC\u0648'} \u06A9\u0627 ${J}${Y.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${Y.origin} \u06A9\u06D2 ${J}${Y.minimum.toString()} ${U.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
                return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${Y.origin} \u06A9\u0627 ${J}${Y.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${J.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
                if (J.format === 'ends_with')
                    return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${J.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
                if (J.format === 'includes')
                    return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${J.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
                if (J.format === 'regex')
                    return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${J.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
                return `\u063A\u0644\u0637 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${Y.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            case 'unrecognized_keys':
                return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${Y.keys.length > 1 ? '\u0632' : ''}: ${C(Y.keys, '\u060C ')}`;
            case 'invalid_key':
                return `${Y.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
            case 'invalid_union':
                return '\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679';
            case 'invalid_element':
                return `${Y.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
            default:
                return '\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679';
        }
    };
};
function M5() {
    return { localeError: YC() };
}
var QC = () => {
    let $ = {
        string: { unit: 'k\xFD t\u1EF1', verb: 'c\xF3' },
        file: { unit: 'byte', verb: 'c\xF3' },
        array: { unit: 'ph\u1EA7n t\u1EED', verb: 'c\xF3' },
        set: { unit: 'ph\u1EA7n t\u1EED', verb: 'c\xF3' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 's\u1ED1';
                case 'object': {
                    if (Array.isArray(Y)) return 'm\u1EA3ng';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u0111\u1EA7u v\xE0o',
            email: '\u0111\u1ECBa ch\u1EC9 email',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ng\xE0y gi\u1EDD ISO',
            date: 'ng\xE0y ISO',
            time: 'gi\u1EDD ISO',
            duration: 'kho\u1EA3ng th\u1EDDi gian ISO',
            ipv4: '\u0111\u1ECBa ch\u1EC9 IPv4',
            ipv6: '\u0111\u1ECBa ch\u1EC9 IPv6',
            cidrv4: 'd\u1EA3i IPv4',
            cidrv6: 'd\u1EA3i IPv6',
            base64: 'chu\u1ED7i m\xE3 h\xF3a base64',
            base64url: 'chu\u1ED7i m\xE3 h\xF3a base64url',
            json_string: 'chu\u1ED7i JSON',
            e164: 's\u1ED1 E.164',
            jwt: 'JWT',
            template_literal: '\u0111\u1EA7u v\xE0o',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${Y.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${h(Y.values[0])}`;
                return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${Y.origin ?? 'gi\xE1 tr\u1ECB'} ${U.verb} ${J}${Y.maximum.toString()} ${U.unit ?? 'ph\u1EA7n t\u1EED'}`;
                return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${Y.origin ?? 'gi\xE1 tr\u1ECB'} ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${Y.origin} ${U.verb} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${Y.origin} ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${J.prefix}"`;
                if (J.format === 'ends_with')
                    return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${J.suffix}"`;
                if (J.format === 'includes')
                    return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${J.includes}"`;
                if (J.format === 'regex')
                    return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${J.pattern}`;
                return `${Q[J.format] ?? Y.format} kh\xF4ng h\u1EE3p l\u1EC7`;
            }
            case 'not_multiple_of':
                return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${Y.divisor}`;
            case 'unrecognized_keys':
                return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${Y.origin}`;
            case 'invalid_union':
                return '\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7';
            case 'invalid_element':
                return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${Y.origin}`;
            default:
                return '\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7';
        }
    };
};
function G5() {
    return { localeError: QC() };
}
var JC = () => {
    let $ = {
        string: { unit: '\u5B57\u7B26', verb: '\u5305\u542B' },
        file: { unit: '\u5B57\u8282', verb: '\u5305\u542B' },
        array: { unit: '\u9879', verb: '\u5305\u542B' },
        set: { unit: '\u9879', verb: '\u5305\u542B' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y)
                        ? '\u975E\u6570\u5B57(NaN)'
                        : '\u6570\u5B57';
                case 'object': {
                    if (Array.isArray(Y)) return '\u6570\u7EC4';
                    if (Y === null) return '\u7A7A\u503C(null)';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u8F93\u5165',
            email: '\u7535\u5B50\u90AE\u4EF6',
            url: 'URL',
            emoji: '\u8868\u60C5\u7B26\u53F7',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO\u65E5\u671F\u65F6\u95F4',
            date: 'ISO\u65E5\u671F',
            time: 'ISO\u65F6\u95F4',
            duration: 'ISO\u65F6\u957F',
            ipv4: 'IPv4\u5730\u5740',
            ipv6: 'IPv6\u5730\u5740',
            cidrv4: 'IPv4\u7F51\u6BB5',
            cidrv6: 'IPv6\u7F51\u6BB5',
            base64: 'base64\u7F16\u7801\u5B57\u7B26\u4E32',
            base64url: 'base64url\u7F16\u7801\u5B57\u7B26\u4E32',
            json_string: 'JSON\u5B57\u7B26\u4E32',
            e164: 'E.164\u53F7\u7801',
            jwt: 'JWT',
            template_literal: '\u8F93\u5165',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${Y.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${h(Y.values[0])}`;
                return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${Y.origin ?? '\u503C'} ${J}${Y.maximum.toString()} ${U.unit ?? '\u4E2A\u5143\u7D20'}`;
                return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${Y.origin ?? '\u503C'} ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${Y.origin} ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${Y.origin} ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${J.prefix}" \u5F00\u5934`;
                if (J.format === 'ends_with')
                    return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${J.suffix}" \u7ED3\u5C3E`;
                if (J.format === 'includes')
                    return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${J.pattern}`;
                return `\u65E0\u6548${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${Y.divisor} \u7684\u500D\u6570`;
            case 'unrecognized_keys':
                return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${C(Y.keys, ', ')}`;
            case 'invalid_key':
                return `${Y.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
            case 'invalid_union':
                return '\u65E0\u6548\u8F93\u5165';
            case 'invalid_element':
                return `${Y.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
            default:
                return '\u65E0\u6548\u8F93\u5165';
        }
    };
};
function z5() {
    return { localeError: JC() };
}
var UC = () => {
    let $ = {
        string: { unit: '\u5B57\u5143', verb: '\u64C1\u6709' },
        file: { unit: '\u4F4D\u5143\u7D44', verb: '\u64C1\u6709' },
        array: { unit: '\u9805\u76EE', verb: '\u64C1\u6709' },
        set: { unit: '\u9805\u76EE', verb: '\u64C1\u6709' },
    };
    function X(Y) {
        return $[Y] ?? null;
    }
    let W = (Y) => {
            let J = typeof Y;
            switch (J) {
                case 'number':
                    return Number.isNaN(Y) ? 'NaN' : 'number';
                case 'object': {
                    if (Array.isArray(Y)) return 'array';
                    if (Y === null) return 'null';
                    if (
                        Object.getPrototypeOf(Y) !== Object.prototype &&
                        Y.constructor
                    )
                        return Y.constructor.name;
                }
            }
            return J;
        },
        Q = {
            regex: '\u8F38\u5165',
            email: '\u90F5\u4EF6\u5730\u5740',
            url: 'URL',
            emoji: 'emoji',
            uuid: 'UUID',
            uuidv4: 'UUIDv4',
            uuidv6: 'UUIDv6',
            nanoid: 'nanoid',
            guid: 'GUID',
            cuid: 'cuid',
            cuid2: 'cuid2',
            ulid: 'ULID',
            xid: 'XID',
            ksuid: 'KSUID',
            datetime: 'ISO \u65E5\u671F\u6642\u9593',
            date: 'ISO \u65E5\u671F',
            time: 'ISO \u6642\u9593',
            duration: 'ISO \u671F\u9593',
            ipv4: 'IPv4 \u4F4D\u5740',
            ipv6: 'IPv6 \u4F4D\u5740',
            cidrv4: 'IPv4 \u7BC4\u570D',
            cidrv6: 'IPv6 \u7BC4\u570D',
            base64: 'base64 \u7DE8\u78BC\u5B57\u4E32',
            base64url: 'base64url \u7DE8\u78BC\u5B57\u4E32',
            json_string: 'JSON \u5B57\u4E32',
            e164: 'E.164 \u6578\u503C',
            jwt: 'JWT',
            template_literal: '\u8F38\u5165',
        };
    return (Y) => {
        switch (Y.code) {
            case 'invalid_type':
                return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${Y.expected}\uFF0C\u4F46\u6536\u5230 ${W(Y.input)}`;
            case 'invalid_value':
                if (Y.values.length === 1)
                    return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${h(Y.values[0])}`;
                return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${C(Y.values, '|')}`;
            case 'too_big': {
                let J = Y.inclusive ? '<=' : '<',
                    U = X(Y.origin);
                if (U)
                    return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${Y.origin ?? '\u503C'} \u61C9\u70BA ${J}${Y.maximum.toString()} ${U.unit ?? '\u500B\u5143\u7D20'}`;
                return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${Y.origin ?? '\u503C'} \u61C9\u70BA ${J}${Y.maximum.toString()}`;
            }
            case 'too_small': {
                let J = Y.inclusive ? '>=' : '>',
                    U = X(Y.origin);
                if (U)
                    return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${Y.origin} \u61C9\u70BA ${J}${Y.minimum.toString()} ${U.unit}`;
                return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${Y.origin} \u61C9\u70BA ${J}${Y.minimum.toString()}`;
            }
            case 'invalid_format': {
                let J = Y;
                if (J.format === 'starts_with')
                    return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${J.prefix}" \u958B\u982D`;
                if (J.format === 'ends_with')
                    return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${J.suffix}" \u7D50\u5C3E`;
                if (J.format === 'includes')
                    return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${J.includes}"`;
                if (J.format === 'regex')
                    return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${J.pattern}`;
                return `\u7121\u6548\u7684 ${Q[J.format] ?? Y.format}`;
            }
            case 'not_multiple_of':
                return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${Y.divisor} \u7684\u500D\u6578`;
            case 'unrecognized_keys':
                return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${Y.keys.length > 1 ? '\u5011' : ''}\uFF1A${C(Y.keys, '\u3001')}`;
            case 'invalid_key':
                return `${Y.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
            case 'invalid_union':
                return '\u7121\u6548\u7684\u8F38\u5165\u503C';
            case 'invalid_element':
                return `${Y.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
            default:
                return '\u7121\u6548\u7684\u8F38\u5165\u503C';
        }
    };
};
function Z5() {
    return { localeError: UC() };
}
var w5 = Symbol('ZodOutput'),
    D5 = Symbol('ZodInput');
class pW {
    constructor() {
        (this._map = new Map()), (this._idmap = new Map());
    }
    add($, ...X) {
        let W = X[0];
        if ((this._map.set($, W), W && typeof W === 'object' && 'id' in W)) {
            if (this._idmap.has(W.id))
                throw new Error(`ID ${W.id} already exists in the registry`);
            this._idmap.set(W.id, $);
        }
        return this;
    }
    clear() {
        return (this._map = new Map()), (this._idmap = new Map()), this;
    }
    remove($) {
        let X = this._map.get($);
        if (X && typeof X === 'object' && 'id' in X) this._idmap.delete(X.id);
        return this._map.delete($), this;
    }
    get($) {
        let X = $._zod.parent;
        if (X) {
            let W = { ...(this.get(X) ?? {}) };
            return delete W.id, { ...W, ...this._map.get($) };
        }
        return this._map.get($);
    }
    has($) {
        return this._map.has($);
    }
}
function o8() {
    return new pW();
}
var z1 = o8();
function B5($, X) {
    return new $({ type: 'string', ...v(X) });
}
function O5($, X) {
    return new $({ type: 'string', coerce: !0, ...v(X) });
}
function r8($, X) {
    return new $({
        type: 'string',
        format: 'email',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function lW($, X) {
    return new $({
        type: 'string',
        format: 'guid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function t8($, X) {
    return new $({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function a8($, X) {
    return new $({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v4',
        ...v(X),
    });
}
function s8($, X) {
    return new $({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v6',
        ...v(X),
    });
}
function e8($, X) {
    return new $({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v7',
        ...v(X),
    });
}
function $Q($, X) {
    return new $({
        type: 'string',
        format: 'url',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function XQ($, X) {
    return new $({
        type: 'string',
        format: 'emoji',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function WQ($, X) {
    return new $({
        type: 'string',
        format: 'nanoid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function YQ($, X) {
    return new $({
        type: 'string',
        format: 'cuid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function QQ($, X) {
    return new $({
        type: 'string',
        format: 'cuid2',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function JQ($, X) {
    return new $({
        type: 'string',
        format: 'ulid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function UQ($, X) {
    return new $({
        type: 'string',
        format: 'xid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function NQ($, X) {
    return new $({
        type: 'string',
        format: 'ksuid',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function MQ($, X) {
    return new $({
        type: 'string',
        format: 'ipv4',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function GQ($, X) {
    return new $({
        type: 'string',
        format: 'ipv6',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function zQ($, X) {
    return new $({
        type: 'string',
        format: 'cidrv4',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function ZQ($, X) {
    return new $({
        type: 'string',
        format: 'cidrv6',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function wQ($, X) {
    return new $({
        type: 'string',
        format: 'base64',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function DQ($, X) {
    return new $({
        type: 'string',
        format: 'base64url',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function BQ($, X) {
    return new $({
        type: 'string',
        format: 'e164',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
function OQ($, X) {
    return new $({
        type: 'string',
        format: 'jwt',
        check: 'string_format',
        abort: !1,
        ...v(X),
    });
}
var H5 = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function q5($, X) {
    return new $({
        type: 'string',
        format: 'datetime',
        check: 'string_format',
        offset: !1,
        local: !1,
        precision: null,
        ...v(X),
    });
}
function A5($, X) {
    return new $({
        type: 'string',
        format: 'date',
        check: 'string_format',
        ...v(X),
    });
}
function P5($, X) {
    return new $({
        type: 'string',
        format: 'time',
        check: 'string_format',
        precision: null,
        ...v(X),
    });
}
function S5($, X) {
    return new $({
        type: 'string',
        format: 'duration',
        check: 'string_format',
        ...v(X),
    });
}
function j5($, X) {
    return new $({ type: 'number', checks: [], ...v(X) });
}
function L5($, X) {
    return new $({ type: 'number', coerce: !0, checks: [], ...v(X) });
}
function K5($, X) {
    return new $({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'safeint',
        ...v(X),
    });
}
function _5($, X) {
    return new $({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float32',
        ...v(X),
    });
}
function F5($, X) {
    return new $({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float64',
        ...v(X),
    });
}
function I5($, X) {
    return new $({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'int32',
        ...v(X),
    });
}
function C5($, X) {
    return new $({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'uint32',
        ...v(X),
    });
}
function R5($, X) {
    return new $({ type: 'boolean', ...v(X) });
}
function V5($, X) {
    return new $({ type: 'boolean', coerce: !0, ...v(X) });
}
function E5($, X) {
    return new $({ type: 'bigint', ...v(X) });
}
function x5($, X) {
    return new $({ type: 'bigint', coerce: !0, ...v(X) });
}
function b5($, X) {
    return new $({
        type: 'bigint',
        check: 'bigint_format',
        abort: !1,
        format: 'int64',
        ...v(X),
    });
}
function g5($, X) {
    return new $({
        type: 'bigint',
        check: 'bigint_format',
        abort: !1,
        format: 'uint64',
        ...v(X),
    });
}
function T5($, X) {
    return new $({ type: 'symbol', ...v(X) });
}
function k5($, X) {
    return new $({ type: 'undefined', ...v(X) });
}
function v5($, X) {
    return new $({ type: 'null', ...v(X) });
}
function f5($) {
    return new $({ type: 'any' });
}
function kX($) {
    return new $({ type: 'unknown' });
}
function y5($, X) {
    return new $({ type: 'never', ...v(X) });
}
function h5($, X) {
    return new $({ type: 'void', ...v(X) });
}
function m5($, X) {
    return new $({ type: 'date', ...v(X) });
}
function c5($, X) {
    return new $({ type: 'date', coerce: !0, ...v(X) });
}
function u5($, X) {
    return new $({ type: 'nan', ...v(X) });
}
function m1($, X) {
    return new m8({ check: 'less_than', ...v(X), value: $, inclusive: !1 });
}
function E4($, X) {
    return new m8({ check: 'less_than', ...v(X), value: $, inclusive: !0 });
}
function c1($, X) {
    return new c8({ check: 'greater_than', ...v(X), value: $, inclusive: !1 });
}
function X4($, X) {
    return new c8({ check: 'greater_than', ...v(X), value: $, inclusive: !0 });
}
function d5($) {
    return c1(0, $);
}
function i5($) {
    return m1(0, $);
}
function n5($) {
    return E4(0, $);
}
function p5($) {
    return X4(0, $);
}
function d0($, X) {
    return new UN({ check: 'multiple_of', ...v(X), value: $ });
}
function vX($, X) {
    return new GN({ check: 'max_size', ...v(X), maximum: $ });
}
function i0($, X) {
    return new zN({ check: 'min_size', ...v(X), minimum: $ });
}
function oW($, X) {
    return new ZN({ check: 'size_equals', ...v(X), size: $ });
}
function fX($, X) {
    return new wN({ check: 'max_length', ...v(X), maximum: $ });
}
function O0($, X) {
    return new DN({ check: 'min_length', ...v(X), minimum: $ });
}
function yX($, X) {
    return new BN({ check: 'length_equals', ...v(X), length: $ });
}
function rW($, X) {
    return new ON({
        check: 'string_format',
        format: 'regex',
        ...v(X),
        pattern: $,
    });
}
function tW($) {
    return new HN({ check: 'string_format', format: 'lowercase', ...v($) });
}
function aW($) {
    return new qN({ check: 'string_format', format: 'uppercase', ...v($) });
}
function sW($, X) {
    return new AN({
        check: 'string_format',
        format: 'includes',
        ...v(X),
        includes: $,
    });
}
function eW($, X) {
    return new PN({
        check: 'string_format',
        format: 'starts_with',
        ...v(X),
        prefix: $,
    });
}
function $Y($, X) {
    return new SN({
        check: 'string_format',
        format: 'ends_with',
        ...v(X),
        suffix: $,
    });
}
function l5($, X, W) {
    return new jN({ check: 'property', property: $, schema: X, ...v(W) });
}
function XY($, X) {
    return new LN({ check: 'mime_type', mime: $, ...v(X) });
}
function u1($) {
    return new KN({ check: 'overwrite', tx: $ });
}
function WY($) {
    return u1((X) => X.normalize($));
}
function YY() {
    return u1(($) => $.trim());
}
function QY() {
    return u1(($) => $.toLowerCase());
}
function JY() {
    return u1(($) => $.toUpperCase());
}
function UY($, X, W) {
    return new $({ type: 'array', element: X, ...v(W) });
}
function NC($, X, W) {
    return new $({ type: 'union', options: X, ...v(W) });
}
function MC($, X, W, Q) {
    return new $({ type: 'union', options: W, discriminator: X, ...v(Q) });
}
function GC($, X, W) {
    return new $({ type: 'intersection', left: X, right: W });
}
function o5($, X, W, Q) {
    let Y = W instanceof s;
    return new $({
        type: 'tuple',
        items: X,
        rest: Y ? W : null,
        ...v(Y ? Q : W),
    });
}
function zC($, X, W, Q) {
    return new $({ type: 'record', keyType: X, valueType: W, ...v(Q) });
}
function ZC($, X, W, Q) {
    return new $({ type: 'map', keyType: X, valueType: W, ...v(Q) });
}
function wC($, X, W) {
    return new $({ type: 'set', valueType: X, ...v(W) });
}
function DC($, X, W) {
    let Q = Array.isArray(X) ? Object.fromEntries(X.map((Y) => [Y, Y])) : X;
    return new $({ type: 'enum', entries: Q, ...v(W) });
}
function BC($, X, W) {
    return new $({ type: 'enum', entries: X, ...v(W) });
}
function OC($, X, W) {
    return new $({
        type: 'literal',
        values: Array.isArray(X) ? X : [X],
        ...v(W),
    });
}
function r5($, X) {
    return new $({ type: 'file', ...v(X) });
}
function HC($, X) {
    return new $({ type: 'transform', transform: X });
}
function qC($, X) {
    return new $({ type: 'optional', innerType: X });
}
function AC($, X) {
    return new $({ type: 'nullable', innerType: X });
}
function PC($, X, W) {
    return new $({
        type: 'default',
        innerType: X,
        get defaultValue() {
            return typeof W === 'function' ? W() : W;
        },
    });
}
function SC($, X, W) {
    return new $({ type: 'nonoptional', innerType: X, ...v(W) });
}
function jC($, X) {
    return new $({ type: 'success', innerType: X });
}
function LC($, X, W) {
    return new $({
        type: 'catch',
        innerType: X,
        catchValue: typeof W === 'function' ? W : () => W,
    });
}
function KC($, X, W) {
    return new $({ type: 'pipe', in: X, out: W });
}
function _C($, X) {
    return new $({ type: 'readonly', innerType: X });
}
function FC($, X, W) {
    return new $({ type: 'template_literal', parts: X, ...v(W) });
}
function IC($, X) {
    return new $({ type: 'lazy', getter: X });
}
function CC($, X) {
    return new $({ type: 'promise', innerType: X });
}
function t5($, X, W) {
    let Q = v(W);
    return (
        Q.abort ?? (Q.abort = !0),
        new $({ type: 'custom', check: 'custom', fn: X, ...Q })
    );
}
function a5($, X, W) {
    return new $({ type: 'custom', check: 'custom', fn: X, ...v(W) });
}
function s5($, X) {
    let W = v(X),
        Q = W.truthy ?? ['true', '1', 'yes', 'on', 'y', 'enabled'],
        Y = W.falsy ?? ['false', '0', 'no', 'off', 'n', 'disabled'];
    if (W.case !== 'sensitive')
        (Q = Q.map((z) => (typeof z === 'string' ? z.toLowerCase() : z))),
            (Y = Y.map((z) => (typeof z === 'string' ? z.toLowerCase() : z)));
    let J = new Set(Q),
        U = new Set(Y),
        N = $.Pipe ?? dW,
        M = $.Boolean ?? mW,
        G = $.String ?? c0,
        B = new ($.Transform ?? uW)({
            type: 'transform',
            transform: (z, H) => {
                let P = z;
                if (W.case !== 'sensitive') P = P.toLowerCase();
                if (J.has(P)) return !0;
                else if (U.has(P)) return !1;
                else
                    return (
                        H.issues.push({
                            code: 'invalid_value',
                            expected: 'stringbool',
                            values: [...J, ...U],
                            input: H.value,
                            inst: B,
                        }),
                        {}
                    );
            },
            error: W.error,
        }),
        O = new N({
            type: 'pipe',
            in: new G({ type: 'string', error: W.error }),
            out: B,
            error: W.error,
        });
    return new N({
        type: 'pipe',
        in: O,
        out: new M({ type: 'boolean', error: W.error }),
        error: W.error,
    });
}
function e5($, X, W, Q = {}) {
    let Y = v(Q),
        J = {
            ...v(Q),
            check: 'string_format',
            type: 'string',
            format: X,
            fn: typeof W === 'function' ? W : (N) => W.test(N),
            ...Y,
        };
    if (W instanceof RegExp) J.pattern = W;
    return new $(J);
}
class $9 {
    constructor($) {
        (this._def = $), (this.def = $);
    }
    implement($) {
        if (typeof $ !== 'function')
            throw new Error('implement() must be called with a function');
        let X = (...W) => {
            let Q = this._def.input
                ? T8(this._def.input, W, void 0, { callee: X })
                : W;
            if (!Array.isArray(Q))
                throw new Error(
                    'Invalid arguments schema: not an array or tuple schema.',
                );
            let Y = $(...Q);
            return this._def.output
                ? T8(this._def.output, Y, void 0, { callee: X })
                : Y;
        };
        return X;
    }
    implementAsync($) {
        if (typeof $ !== 'function')
            throw new Error('implement() must be called with a function');
        let X = async (...W) => {
            let Q = this._def.input
                ? await v8(this._def.input, W, void 0, { callee: X })
                : W;
            if (!Array.isArray(Q))
                throw new Error(
                    'Invalid arguments schema: not an array or tuple schema.',
                );
            let Y = await $(...Q);
            return this._def.output
                ? v8(this._def.output, Y, void 0, { callee: X })
                : Y;
        };
        return X;
    }
    input(...$) {
        let X = this.constructor;
        if (Array.isArray($[0]))
            return new X({
                type: 'function',
                input: new u0({ type: 'tuple', items: $[0], rest: $[1] }),
                output: this._def.output,
            });
        return new X({
            type: 'function',
            input: $[0],
            output: this._def.output,
        });
    }
    output($) {
        return new this.constructor({
            type: 'function',
            input: this._def.input,
            output: $,
        });
    }
}
function X9($) {
    return new $9({
        type: 'function',
        input: Array.isArray($?.input)
            ? o5(u0, $?.input)
            : ($?.input ?? UY(cW, kX(TX))),
        output: $?.output ?? kX(TX),
    });
}
class HQ {
    constructor($) {
        (this.counter = 0),
            (this.metadataRegistry = $?.metadata ?? z1),
            (this.target = $?.target ?? 'draft-2020-12'),
            (this.unrepresentable = $?.unrepresentable ?? 'throw'),
            (this.override = $?.override ?? (() => {})),
            (this.io = $?.io ?? 'output'),
            (this.seen = new Map());
    }
    process($, X = { path: [], schemaPath: [] }) {
        var W;
        let Q = $._zod.def,
            Y = {
                guid: 'uuid',
                url: 'uri',
                datetime: 'date-time',
                json_string: 'json-string',
                regex: '',
            },
            J = this.seen.get($);
        if (J) {
            if ((J.count++, X.schemaPath.includes($))) J.cycle = X.path;
            return J.schema;
        }
        let U = { schema: {}, count: 1, cycle: void 0, path: X.path };
        this.seen.set($, U);
        let N = $._zod.toJSONSchema?.();
        if (N) U.schema = N;
        else {
            let Z = { ...X, schemaPath: [...X.schemaPath, $], path: X.path },
                B = $._zod.parent;
            if (B)
                (U.ref = B),
                    this.process(B, Z),
                    (this.seen.get(B).isParent = !0);
            else {
                let O = U.schema;
                switch (Q.type) {
                    case 'string': {
                        let w = O;
                        w.type = 'string';
                        let {
                            minimum: z,
                            maximum: H,
                            format: P,
                            patterns: E,
                            contentEncoding: j,
                        } = $._zod.bag;
                        if (typeof z === 'number') w.minLength = z;
                        if (typeof H === 'number') w.maxLength = H;
                        if (P) {
                            if (((w.format = Y[P] ?? P), w.format === ''))
                                delete w.format;
                        }
                        if (j) w.contentEncoding = j;
                        if (E && E.size > 0) {
                            let V = [...E];
                            if (V.length === 1) w.pattern = V[0].source;
                            else if (V.length > 1)
                                U.schema.allOf = [
                                    ...V.map((i) => ({
                                        ...(this.target === 'draft-7'
                                            ? { type: 'string' }
                                            : {}),
                                        pattern: i.source,
                                    })),
                                ];
                        }
                        break;
                    }
                    case 'number': {
                        let w = O,
                            {
                                minimum: z,
                                maximum: H,
                                format: P,
                                multipleOf: E,
                                exclusiveMaximum: j,
                                exclusiveMinimum: V,
                            } = $._zod.bag;
                        if (typeof P === 'string' && P.includes('int'))
                            w.type = 'integer';
                        else w.type = 'number';
                        if (typeof V === 'number') w.exclusiveMinimum = V;
                        if (typeof z === 'number') {
                            if (((w.minimum = z), typeof V === 'number'))
                                if (V >= z) delete w.minimum;
                                else delete w.exclusiveMinimum;
                        }
                        if (typeof j === 'number') w.exclusiveMaximum = j;
                        if (typeof H === 'number') {
                            if (((w.maximum = H), typeof j === 'number'))
                                if (j <= H) delete w.maximum;
                                else delete w.exclusiveMaximum;
                        }
                        if (typeof E === 'number') w.multipleOf = E;
                        break;
                    }
                    case 'boolean': {
                        let w = O;
                        w.type = 'boolean';
                        break;
                    }
                    case 'bigint': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'BigInt cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'symbol': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Symbols cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'null': {
                        O.type = 'null';
                        break;
                    }
                    case 'any':
                        break;
                    case 'unknown':
                        break;
                    case 'undefined': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Undefined cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'void': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Void cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'never': {
                        O.not = {};
                        break;
                    }
                    case 'date': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Date cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'array': {
                        let w = O,
                            { minimum: z, maximum: H } = $._zod.bag;
                        if (typeof z === 'number') w.minItems = z;
                        if (typeof H === 'number') w.maxItems = H;
                        (w.type = 'array'),
                            (w.items = this.process(Q.element, {
                                ...Z,
                                path: [...Z.path, 'items'],
                            }));
                        break;
                    }
                    case 'object': {
                        let w = O;
                        (w.type = 'object'), (w.properties = {});
                        let z = Q.shape;
                        for (let E in z)
                            w.properties[E] = this.process(z[E], {
                                ...Z,
                                path: [...Z.path, 'properties', E],
                            });
                        let H = new Set(Object.keys(z)),
                            P = new Set(
                                [...H].filter((E) => {
                                    let j = Q.shape[E]._zod;
                                    if (this.io === 'input')
                                        return j.optin === void 0;
                                    else return j.optout === void 0;
                                }),
                            );
                        if (P.size > 0) w.required = Array.from(P);
                        if (Q.catchall?._zod.def.type === 'never')
                            w.additionalProperties = !1;
                        else if (!Q.catchall) {
                            if (this.io === 'output')
                                w.additionalProperties = !1;
                        } else if (Q.catchall)
                            w.additionalProperties = this.process(Q.catchall, {
                                ...Z,
                                path: [...Z.path, 'additionalProperties'],
                            });
                        break;
                    }
                    case 'union': {
                        let w = O;
                        w.anyOf = Q.options.map((z, H) =>
                            this.process(z, {
                                ...Z,
                                path: [...Z.path, 'anyOf', H],
                            }),
                        );
                        break;
                    }
                    case 'intersection': {
                        let w = O,
                            z = this.process(Q.left, {
                                ...Z,
                                path: [...Z.path, 'allOf', 0],
                            }),
                            H = this.process(Q.right, {
                                ...Z,
                                path: [...Z.path, 'allOf', 1],
                            }),
                            P = (j) =>
                                'allOf' in j && Object.keys(j).length === 1,
                            E = [
                                ...(P(z) ? z.allOf : [z]),
                                ...(P(H) ? H.allOf : [H]),
                            ];
                        w.allOf = E;
                        break;
                    }
                    case 'tuple': {
                        let w = O;
                        w.type = 'array';
                        let z = Q.items.map((E, j) =>
                            this.process(E, {
                                ...Z,
                                path: [...Z.path, 'prefixItems', j],
                            }),
                        );
                        if (this.target === 'draft-2020-12') w.prefixItems = z;
                        else w.items = z;
                        if (Q.rest) {
                            let E = this.process(Q.rest, {
                                ...Z,
                                path: [...Z.path, 'items'],
                            });
                            if (this.target === 'draft-2020-12') w.items = E;
                            else w.additionalItems = E;
                        }
                        if (Q.rest)
                            w.items = this.process(Q.rest, {
                                ...Z,
                                path: [...Z.path, 'items'],
                            });
                        let { minimum: H, maximum: P } = $._zod.bag;
                        if (typeof H === 'number') w.minItems = H;
                        if (typeof P === 'number') w.maxItems = P;
                        break;
                    }
                    case 'record': {
                        let w = O;
                        (w.type = 'object'),
                            (w.propertyNames = this.process(Q.keyType, {
                                ...Z,
                                path: [...Z.path, 'propertyNames'],
                            })),
                            (w.additionalProperties = this.process(
                                Q.valueType,
                                {
                                    ...Z,
                                    path: [...Z.path, 'additionalProperties'],
                                },
                            ));
                        break;
                    }
                    case 'map': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Map cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'set': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Set cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'enum': {
                        let w = O,
                            z = xW(Q.entries);
                        if (z.every((H) => typeof H === 'number'))
                            w.type = 'number';
                        if (z.every((H) => typeof H === 'string'))
                            w.type = 'string';
                        w.enum = z;
                        break;
                    }
                    case 'literal': {
                        let w = O,
                            z = [];
                        for (let H of Q.values)
                            if (H === void 0) {
                                if (this.unrepresentable === 'throw')
                                    throw new Error(
                                        'Literal `undefined` cannot be represented in JSON Schema',
                                    );
                            } else if (typeof H === 'bigint')
                                if (this.unrepresentable === 'throw')
                                    throw new Error(
                                        'BigInt literals cannot be represented in JSON Schema',
                                    );
                                else z.push(Number(H));
                            else z.push(H);
                        if (z.length === 0);
                        else if (z.length === 1) {
                            let H = z[0];
                            (w.type = H === null ? 'null' : typeof H),
                                (w.const = H);
                        } else {
                            if (z.every((H) => typeof H === 'number'))
                                w.type = 'number';
                            if (z.every((H) => typeof H === 'string'))
                                w.type = 'string';
                            if (z.every((H) => typeof H === 'boolean'))
                                w.type = 'string';
                            if (z.every((H) => H === null)) w.type = 'null';
                            w.enum = z;
                        }
                        break;
                    }
                    case 'file': {
                        let w = O,
                            z = {
                                type: 'string',
                                format: 'binary',
                                contentEncoding: 'binary',
                            },
                            { minimum: H, maximum: P, mime: E } = $._zod.bag;
                        if (H !== void 0) z.minLength = H;
                        if (P !== void 0) z.maxLength = P;
                        if (E)
                            if (E.length === 1)
                                (z.contentMediaType = E[0]),
                                    Object.assign(w, z);
                            else
                                w.anyOf = E.map((j) => {
                                    return { ...z, contentMediaType: j };
                                });
                        else Object.assign(w, z);
                        break;
                    }
                    case 'transform': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Transforms cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'nullable': {
                        let w = this.process(Q.innerType, Z);
                        O.anyOf = [w, { type: 'null' }];
                        break;
                    }
                    case 'nonoptional': {
                        this.process(Q.innerType, Z), (U.ref = Q.innerType);
                        break;
                    }
                    case 'success': {
                        let w = O;
                        w.type = 'boolean';
                        break;
                    }
                    case 'default': {
                        this.process(Q.innerType, Z),
                            (U.ref = Q.innerType),
                            (O.default = JSON.parse(
                                JSON.stringify(Q.defaultValue),
                            ));
                        break;
                    }
                    case 'prefault': {
                        if (
                            (this.process(Q.innerType, Z),
                            (U.ref = Q.innerType),
                            this.io === 'input')
                        )
                            O._prefault = JSON.parse(
                                JSON.stringify(Q.defaultValue),
                            );
                        break;
                    }
                    case 'catch': {
                        this.process(Q.innerType, Z), (U.ref = Q.innerType);
                        let w;
                        try {
                            w = Q.catchValue(void 0);
                        } catch {
                            throw new Error(
                                'Dynamic catch values are not supported in JSON Schema',
                            );
                        }
                        O.default = w;
                        break;
                    }
                    case 'nan': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'NaN cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    case 'template_literal': {
                        let w = O,
                            z = $._zod.pattern;
                        if (!z)
                            throw new Error(
                                'Pattern not found in template literal',
                            );
                        (w.type = 'string'), (w.pattern = z.source);
                        break;
                    }
                    case 'pipe': {
                        let w =
                            this.io === 'input'
                                ? Q.in._zod.def.type === 'transform'
                                    ? Q.out
                                    : Q.in
                                : Q.out;
                        this.process(w, Z), (U.ref = w);
                        break;
                    }
                    case 'readonly': {
                        this.process(Q.innerType, Z),
                            (U.ref = Q.innerType),
                            (O.readOnly = !0);
                        break;
                    }
                    case 'promise': {
                        this.process(Q.innerType, Z), (U.ref = Q.innerType);
                        break;
                    }
                    case 'optional': {
                        this.process(Q.innerType, Z), (U.ref = Q.innerType);
                        break;
                    }
                    case 'lazy': {
                        let w = $._zod.innerType;
                        this.process(w, Z), (U.ref = w);
                        break;
                    }
                    case 'custom': {
                        if (this.unrepresentable === 'throw')
                            throw new Error(
                                'Custom types cannot be represented in JSON Schema',
                            );
                        break;
                    }
                    default:
                }
            }
        }
        let M = this.metadataRegistry.get($);
        if (M) Object.assign(U.schema, M);
        if (this.io === 'input' && B6($))
            delete U.schema.examples, delete U.schema.default;
        if (this.io === 'input' && U.schema._prefault)
            (W = U.schema).default ?? (W.default = U.schema._prefault);
        return delete U.schema._prefault, this.seen.get($).schema;
    }
    emit($, X) {
        let W = {
                cycles: X?.cycles ?? 'ref',
                reused: X?.reused ?? 'inline',
                external: X?.external ?? void 0,
            },
            Q = this.seen.get($);
        if (!Q) throw new Error('Unprocessed schema. This is a bug in Zod.');
        let Y = (G) => {
                let Z =
                    this.target === 'draft-2020-12' ? '$defs' : 'definitions';
                if (W.external) {
                    let z = W.external.registry.get(G[0])?.id,
                        H = W.external.uri ?? ((E) => E);
                    if (z) return { ref: H(z) };
                    let P =
                        G[1].defId ??
                        G[1].schema.id ??
                        `schema${this.counter++}`;
                    return (
                        (G[1].defId = P),
                        { defId: P, ref: `${H('__shared')}#/${Z}/${P}` }
                    );
                }
                if (G[1] === Q) return { ref: '#' };
                let O = `${'#'}/${Z}/`,
                    w = G[1].schema.id ?? `__schema${this.counter++}`;
                return { defId: w, ref: O + w };
            },
            J = (G) => {
                if (G[1].schema.$ref) return;
                let Z = G[1],
                    { ref: B, defId: O } = Y(G);
                if (((Z.def = { ...Z.schema }), O)) Z.defId = O;
                let w = Z.schema;
                for (let z in w) delete w[z];
                w.$ref = B;
            };
        if (W.cycles === 'throw')
            for (let G of this.seen.entries()) {
                let Z = G[1];
                if (Z.cycle)
                    throw new Error(`Cycle detected: #/${Z.cycle?.join('/')}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
        for (let G of this.seen.entries()) {
            let Z = G[1];
            if ($ === G[0]) {
                J(G);
                continue;
            }
            if (W.external) {
                let O = W.external.registry.get(G[0])?.id;
                if ($ !== G[0] && O) {
                    J(G);
                    continue;
                }
            }
            if (this.metadataRegistry.get(G[0])?.id) {
                J(G);
                continue;
            }
            if (Z.cycle) {
                J(G);
                continue;
            }
            if (Z.count > 1) {
                if (W.reused === 'ref') {
                    J(G);
                    continue;
                }
            }
        }
        let U = (G, Z) => {
            let B = this.seen.get(G),
                O = B.def ?? B.schema,
                w = { ...O };
            if (B.ref === null) return;
            let z = B.ref;
            if (((B.ref = null), z)) {
                U(z, Z);
                let H = this.seen.get(z).schema;
                if (H.$ref && Z.target === 'draft-7')
                    (O.allOf = O.allOf ?? []), O.allOf.push(H);
                else Object.assign(O, H), Object.assign(O, w);
            }
            if (!B.isParent)
                this.override({
                    zodSchema: G,
                    jsonSchema: O,
                    path: B.path ?? [],
                });
        };
        for (let G of [...this.seen.entries()].reverse())
            U(G[0], { target: this.target });
        let N = {};
        if (this.target === 'draft-2020-12')
            N.$schema = 'https://json-schema.org/draft/2020-12/schema';
        else if (this.target === 'draft-7')
            N.$schema = 'http://json-schema.org/draft-07/schema#';
        else console.warn(`Invalid target: ${this.target}`);
        if (W.external?.uri) {
            let G = W.external.registry.get($)?.id;
            if (!G) throw new Error('Schema is missing an `id` property');
            N.$id = W.external.uri(G);
        }
        Object.assign(N, Q.def);
        let M = W.external?.defs ?? {};
        for (let G of this.seen.entries()) {
            let Z = G[1];
            if (Z.def && Z.defId) M[Z.defId] = Z.def;
        }
        if (W.external);
        else if (Object.keys(M).length > 0)
            if (this.target === 'draft-2020-12') N.$defs = M;
            else N.definitions = M;
        try {
            return JSON.parse(JSON.stringify(N));
        } catch (G) {
            throw new Error('Error converting schema to JSON.');
        }
    }
}
function W9($, X) {
    if ($ instanceof pW) {
        let Q = new HQ(X),
            Y = {};
        for (let N of $._idmap.entries()) {
            let [M, G] = N;
            Q.process(G);
        }
        let J = {},
            U = { registry: $, uri: X?.uri, defs: Y };
        for (let N of $._idmap.entries()) {
            let [M, G] = N;
            J[M] = Q.emit(G, { ...X, external: U });
        }
        if (Object.keys(Y).length > 0) {
            let N = Q.target === 'draft-2020-12' ? '$defs' : 'definitions';
            J.__shared = { [N]: Y };
        }
        return { schemas: J };
    }
    let W = new HQ(X);
    return W.process($), W.emit($, X);
}
function B6($, X) {
    let W = X ?? { seen: new Set() };
    if (W.seen.has($)) return !1;
    W.seen.add($);
    let Y = $._zod.def;
    switch (Y.type) {
        case 'string':
        case 'number':
        case 'bigint':
        case 'boolean':
        case 'date':
        case 'symbol':
        case 'undefined':
        case 'null':
        case 'any':
        case 'unknown':
        case 'never':
        case 'void':
        case 'literal':
        case 'enum':
        case 'nan':
        case 'file':
        case 'template_literal':
            return !1;
        case 'array':
            return B6(Y.element, W);
        case 'object': {
            for (let J in Y.shape) if (B6(Y.shape[J], W)) return !0;
            return !1;
        }
        case 'union': {
            for (let J of Y.options) if (B6(J, W)) return !0;
            return !1;
        }
        case 'intersection':
            return B6(Y.left, W) || B6(Y.right, W);
        case 'tuple': {
            for (let J of Y.items) if (B6(J, W)) return !0;
            if (Y.rest && B6(Y.rest, W)) return !0;
            return !1;
        }
        case 'record':
            return B6(Y.keyType, W) || B6(Y.valueType, W);
        case 'map':
            return B6(Y.keyType, W) || B6(Y.valueType, W);
        case 'set':
            return B6(Y.valueType, W);
        case 'promise':
        case 'optional':
        case 'nonoptional':
        case 'nullable':
        case 'readonly':
            return B6(Y.innerType, W);
        case 'lazy':
            return B6(Y.getter(), W);
        case 'default':
            return B6(Y.innerType, W);
        case 'prefault':
            return B6(Y.innerType, W);
        case 'custom':
            return !1;
        case 'transform':
            return !0;
        case 'pipe':
            return B6(Y.in, W) || B6(Y.out, W);
        case 'success':
            return !1;
        case 'catch':
            return !1;
        default:
    }
    throw new Error(`Unknown schema type: ${Y.type}`);
}
var Vw = {};
var jQ = {};
k6(jQ, {
    time: () => J9,
    duration: () => U9,
    datetime: () => Y9,
    date: () => Q9,
    ZodISOTime: () => PQ,
    ZodISODuration: () => SQ,
    ZodISODateTime: () => qQ,
    ZodISODate: () => AQ,
});
var qQ = L('ZodISODateTime', ($, X) => {
    fN.init($, X), y$.init($, X);
});
function Y9($) {
    return q5(qQ, $);
}
var AQ = L('ZodISODate', ($, X) => {
    yN.init($, X), y$.init($, X);
});
function Q9($) {
    return A5(AQ, $);
}
var PQ = L('ZodISOTime', ($, X) => {
    hN.init($, X), y$.init($, X);
});
function J9($) {
    return P5(PQ, $);
}
var SQ = L('ZodISODuration', ($, X) => {
    mN.init($, X), y$.init($, X);
});
function U9($) {
    return S5(SQ, $);
}
var xw = ($, X) => {
        fW.init($, X),
            ($.name = 'ZodError'),
            Object.defineProperties($, {
                format: { value: (W) => hW($, W) },
                flatten: { value: (W) => yW($, W) },
                addIssue: { value: (W) => $.issues.push(W) },
                addIssues: { value: (W) => $.issues.push(...W) },
                isEmpty: {
                    get() {
                        return $.issues.length === 0;
                    },
                },
            });
    },
    VC = L('ZodError', xw),
    hX = L('ZodError', xw, { Parent: Error });
var N9 = g8(hX),
    M9 = k8(hX),
    G9 = f8(hX),
    z9 = y8(hX);
var J$ = L('ZodType', ($, X) => {
        return (
            s.init($, X),
            ($.def = X),
            Object.defineProperty($, '_def', { value: X }),
            ($.check = (...W) => {
                return $.clone({
                    ...X,
                    checks: [
                        ...(X.checks ?? []),
                        ...W.map((Q) =>
                            typeof Q === 'function'
                                ? {
                                      _zod: {
                                          check: Q,
                                          def: { check: 'custom' },
                                          onattach: [],
                                      },
                                  }
                                : Q,
                        ),
                    ],
                });
            }),
            ($.clone = (W, Q) => O4($, W, Q)),
            ($.brand = () => $),
            ($.register = (W, Q) => {
                return W.add($, Q), $;
            }),
            ($.parse = (W, Q) => N9($, W, Q, { callee: $.parse })),
            ($.safeParse = (W, Q) => G9($, W, Q)),
            ($.parseAsync = async (W, Q) =>
                M9($, W, Q, { callee: $.parseAsync })),
            ($.safeParseAsync = async (W, Q) => z9($, W, Q)),
            ($.spa = $.safeParseAsync),
            ($.refine = (W, Q) => $.check(AD(W, Q))),
            ($.superRefine = (W) => $.check(PD(W))),
            ($.overwrite = (W) => $.check(u1(W))),
            ($.optional = () => _Q($)),
            ($.nullable = () => FQ($)),
            ($.nullish = () => _Q(FQ($))),
            ($.nonoptional = (W) => UD($, W)),
            ($.array = () => b9($)),
            ($.or = (W) => EQ([$, W])),
            ($.and = (W) => pw($, W)),
            ($.transform = (W) => IQ($, v9(W))),
            ($.default = (W) => YD($, W)),
            ($.prefault = (W) => JD($, W)),
            ($.catch = (W) => GD($, W)),
            ($.pipe = (W) => IQ($, W)),
            ($.readonly = () => wD($)),
            ($.describe = (W) => {
                let Q = $.clone();
                return z1.add(Q, { description: W }), Q;
            }),
            Object.defineProperty($, 'description', {
                get() {
                    return z1.get($)?.description;
                },
                configurable: !0,
            }),
            ($.meta = (...W) => {
                if (W.length === 0) return z1.get($);
                let Q = $.clone();
                return z1.add(Q, W[0]), Q;
            }),
            ($.isOptional = () => $.safeParse(void 0).success),
            ($.isNullable = () => $.safeParse(null).success),
            $
        );
    }),
    D9 = L('_ZodString', ($, X) => {
        c0.init($, X), J$.init($, X);
        let W = $._zod.bag;
        ($.format = W.format ?? null),
            ($.minLength = W.minimum ?? null),
            ($.maxLength = W.maximum ?? null),
            ($.regex = (...Q) => $.check(rW(...Q))),
            ($.includes = (...Q) => $.check(sW(...Q))),
            ($.startsWith = (...Q) => $.check(eW(...Q))),
            ($.endsWith = (...Q) => $.check($Y(...Q))),
            ($.min = (...Q) => $.check(O0(...Q))),
            ($.max = (...Q) => $.check(fX(...Q))),
            ($.length = (...Q) => $.check(yX(...Q))),
            ($.nonempty = (...Q) => $.check(O0(1, ...Q))),
            ($.lowercase = (Q) => $.check(tW(Q))),
            ($.uppercase = (Q) => $.check(aW(Q))),
            ($.trim = () => $.check(YY())),
            ($.normalize = (...Q) => $.check(WY(...Q))),
            ($.toLowerCase = () => $.check(QY())),
            ($.toUpperCase = () => $.check(JY()));
    }),
    MY = L('ZodString', ($, X) => {
        c0.init($, X),
            D9.init($, X),
            ($.email = (W) => $.check(r8(B9, W))),
            ($.url = (W) => $.check($Q(O9, W))),
            ($.jwt = (W) => $.check(OQ(E9, W))),
            ($.emoji = (W) => $.check(XQ(H9, W))),
            ($.guid = (W) => $.check(lW(LQ, W))),
            ($.uuid = (W) => $.check(t8(i1, W))),
            ($.uuidv4 = (W) => $.check(a8(i1, W))),
            ($.uuidv6 = (W) => $.check(s8(i1, W))),
            ($.uuidv7 = (W) => $.check(e8(i1, W))),
            ($.nanoid = (W) => $.check(WQ(q9, W))),
            ($.guid = (W) => $.check(lW(LQ, W))),
            ($.cuid = (W) => $.check(YQ(A9, W))),
            ($.cuid2 = (W) => $.check(QQ(P9, W))),
            ($.ulid = (W) => $.check(JQ(S9, W))),
            ($.base64 = (W) => $.check(wQ(C9, W))),
            ($.base64url = (W) => $.check(DQ(R9, W))),
            ($.xid = (W) => $.check(UQ(j9, W))),
            ($.ksuid = (W) => $.check(NQ(L9, W))),
            ($.ipv4 = (W) => $.check(MQ(K9, W))),
            ($.ipv6 = (W) => $.check(GQ(_9, W))),
            ($.cidrv4 = (W) => $.check(zQ(F9, W))),
            ($.cidrv6 = (W) => $.check(ZQ(I9, W))),
            ($.e164 = (W) => $.check(BQ(V9, W))),
            ($.datetime = (W) => $.check(Y9(W))),
            ($.date = (W) => $.check(Q9(W))),
            ($.time = (W) => $.check(J9(W))),
            ($.duration = (W) => $.check(U9(W)));
    });
function Z9($) {
    return B5(MY, $);
}
var y$ = L('ZodStringFormat', ($, X) => {
        T$.init($, X), D9.init($, X);
    }),
    B9 = L('ZodEmail', ($, X) => {
        RN.init($, X), y$.init($, X);
    });
function xC($) {
    return r8(B9, $);
}
var LQ = L('ZodGUID', ($, X) => {
    IN.init($, X), y$.init($, X);
});
function bC($) {
    return lW(LQ, $);
}
var i1 = L('ZodUUID', ($, X) => {
    CN.init($, X), y$.init($, X);
});
function gC($) {
    return t8(i1, $);
}
function TC($) {
    return a8(i1, $);
}
function kC($) {
    return s8(i1, $);
}
function vC($) {
    return e8(i1, $);
}
var O9 = L('ZodURL', ($, X) => {
    VN.init($, X), y$.init($, X);
});
function fC($) {
    return $Q(O9, $);
}
var H9 = L('ZodEmoji', ($, X) => {
    EN.init($, X), y$.init($, X);
});
function yC($) {
    return XQ(H9, $);
}
var q9 = L('ZodNanoID', ($, X) => {
    xN.init($, X), y$.init($, X);
});
function hC($) {
    return WQ(q9, $);
}
var A9 = L('ZodCUID', ($, X) => {
    bN.init($, X), y$.init($, X);
});
function mC($) {
    return YQ(A9, $);
}
var P9 = L('ZodCUID2', ($, X) => {
    gN.init($, X), y$.init($, X);
});
function cC($) {
    return QQ(P9, $);
}
var S9 = L('ZodULID', ($, X) => {
    TN.init($, X), y$.init($, X);
});
function uC($) {
    return JQ(S9, $);
}
var j9 = L('ZodXID', ($, X) => {
    kN.init($, X), y$.init($, X);
});
function dC($) {
    return UQ(j9, $);
}
var L9 = L('ZodKSUID', ($, X) => {
    vN.init($, X), y$.init($, X);
});
function iC($) {
    return NQ(L9, $);
}
var K9 = L('ZodIPv4', ($, X) => {
    cN.init($, X), y$.init($, X);
});
function nC($) {
    return MQ(K9, $);
}
var _9 = L('ZodIPv6', ($, X) => {
    uN.init($, X), y$.init($, X);
});
function pC($) {
    return GQ(_9, $);
}
var F9 = L('ZodCIDRv4', ($, X) => {
    dN.init($, X), y$.init($, X);
});
function lC($) {
    return zQ(F9, $);
}
var I9 = L('ZodCIDRv6', ($, X) => {
    iN.init($, X), y$.init($, X);
});
function oC($) {
    return ZQ(I9, $);
}
var C9 = L('ZodBase64', ($, X) => {
    pN.init($, X), y$.init($, X);
});
function rC($) {
    return wQ(C9, $);
}
var R9 = L('ZodBase64URL', ($, X) => {
    lN.init($, X), y$.init($, X);
});
function tC($) {
    return DQ(R9, $);
}
var V9 = L('ZodE164', ($, X) => {
    oN.init($, X), y$.init($, X);
});
function aC($) {
    return BQ(V9, $);
}
var E9 = L('ZodJWT', ($, X) => {
    rN.init($, X), y$.init($, X);
});
function sC($) {
    return OQ(E9, $);
}
var bw = L('ZodCustomStringFormat', ($, X) => {
    tN.init($, X), y$.init($, X);
});
function eC($, X, W = {}) {
    return e5(bw, $, X, W);
}
var GY = L('ZodNumber', ($, X) => {
    n8.init($, X),
        J$.init($, X),
        ($.gt = (Q, Y) => $.check(c1(Q, Y))),
        ($.gte = (Q, Y) => $.check(X4(Q, Y))),
        ($.min = (Q, Y) => $.check(X4(Q, Y))),
        ($.lt = (Q, Y) => $.check(m1(Q, Y))),
        ($.lte = (Q, Y) => $.check(E4(Q, Y))),
        ($.max = (Q, Y) => $.check(E4(Q, Y))),
        ($.int = (Q) => $.check(w9(Q))),
        ($.safe = (Q) => $.check(w9(Q))),
        ($.positive = (Q) => $.check(c1(0, Q))),
        ($.nonnegative = (Q) => $.check(X4(0, Q))),
        ($.negative = (Q) => $.check(m1(0, Q))),
        ($.nonpositive = (Q) => $.check(E4(0, Q))),
        ($.multipleOf = (Q, Y) => $.check(d0(Q, Y))),
        ($.step = (Q, Y) => $.check(d0(Q, Y))),
        ($.finite = () => $);
    let W = $._zod.bag;
    ($.minValue =
        Math.max(
            W.minimum ?? Number.NEGATIVE_INFINITY,
            W.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
        ) ?? null),
        ($.maxValue =
            Math.min(
                W.maximum ?? Number.POSITIVE_INFINITY,
                W.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
            ) ?? null),
        ($.isInt =
            (W.format ?? '').includes('int') ||
            Number.isSafeInteger(W.multipleOf ?? 0.5)),
        ($.isFinite = !0),
        ($.format = W.format ?? null);
});
function gw($) {
    return j5(GY, $);
}
var mX = L('ZodNumberFormat', ($, X) => {
    aN.init($, X), GY.init($, X);
});
function w9($) {
    return K5(mX, $);
}
function $R($) {
    return _5(mX, $);
}
function XR($) {
    return F5(mX, $);
}
function WR($) {
    return I5(mX, $);
}
function YR($) {
    return C5(mX, $);
}
var zY = L('ZodBoolean', ($, X) => {
    mW.init($, X), J$.init($, X);
});
function Tw($) {
    return R5(zY, $);
}
var ZY = L('ZodBigInt', ($, X) => {
    p8.init($, X),
        J$.init($, X),
        ($.gte = (Q, Y) => $.check(X4(Q, Y))),
        ($.min = (Q, Y) => $.check(X4(Q, Y))),
        ($.gt = (Q, Y) => $.check(c1(Q, Y))),
        ($.gte = (Q, Y) => $.check(X4(Q, Y))),
        ($.min = (Q, Y) => $.check(X4(Q, Y))),
        ($.lt = (Q, Y) => $.check(m1(Q, Y))),
        ($.lte = (Q, Y) => $.check(E4(Q, Y))),
        ($.max = (Q, Y) => $.check(E4(Q, Y))),
        ($.positive = (Q) => $.check(c1(BigInt(0), Q))),
        ($.negative = (Q) => $.check(m1(BigInt(0), Q))),
        ($.nonpositive = (Q) => $.check(E4(BigInt(0), Q))),
        ($.nonnegative = (Q) => $.check(X4(BigInt(0), Q))),
        ($.multipleOf = (Q, Y) => $.check(d0(Q, Y)));
    let W = $._zod.bag;
    ($.minValue = W.minimum ?? null),
        ($.maxValue = W.maximum ?? null),
        ($.format = W.format ?? null);
});
function QR($) {
    return E5(ZY, $);
}
var x9 = L('ZodBigIntFormat', ($, X) => {
    sN.init($, X), ZY.init($, X);
});
function JR($) {
    return b5(x9, $);
}
function UR($) {
    return g5(x9, $);
}
var kw = L('ZodSymbol', ($, X) => {
    eN.init($, X), J$.init($, X);
});
function NR($) {
    return T5(kw, $);
}
var vw = L('ZodUndefined', ($, X) => {
    $7.init($, X), J$.init($, X);
});
function MR($) {
    return k5(vw, $);
}
var fw = L('ZodNull', ($, X) => {
    X7.init($, X), J$.init($, X);
});
function yw($) {
    return v5(fw, $);
}
var hw = L('ZodAny', ($, X) => {
    W7.init($, X), J$.init($, X);
});
function GR() {
    return f5(hw);
}
var mw = L('ZodUnknown', ($, X) => {
    TX.init($, X), J$.init($, X);
});
function KQ() {
    return kX(mw);
}
var cw = L('ZodNever', ($, X) => {
    Y7.init($, X), J$.init($, X);
});
function CQ($) {
    return y5(cw, $);
}
var uw = L('ZodVoid', ($, X) => {
    Q7.init($, X), J$.init($, X);
});
function zR($) {
    return h5(uw, $);
}
var RQ = L('ZodDate', ($, X) => {
    J7.init($, X),
        J$.init($, X),
        ($.min = (Q, Y) => $.check(X4(Q, Y))),
        ($.max = (Q, Y) => $.check(E4(Q, Y)));
    let W = $._zod.bag;
    ($.minDate = W.minimum ? new Date(W.minimum) : null),
        ($.maxDate = W.maximum ? new Date(W.maximum) : null);
});
function ZR($) {
    return m5(RQ, $);
}
var dw = L('ZodArray', ($, X) => {
    cW.init($, X),
        J$.init($, X),
        ($.element = X.element),
        ($.min = (W, Q) => $.check(O0(W, Q))),
        ($.nonempty = (W) => $.check(O0(1, W))),
        ($.max = (W, Q) => $.check(fX(W, Q))),
        ($.length = (W, Q) => $.check(yX(W, Q))),
        ($.unwrap = () => $.element);
});
function b9($, X) {
    return UY(dw, $, X);
}
function wR($) {
    let X = $._zod.def.shape;
    return ew(Object.keys(X));
}
var VQ = L('ZodObject', ($, X) => {
    U7.init($, X),
        J$.init($, X),
        m.defineLazy($, 'shape', () => X.shape),
        ($.keyof = () => aw(Object.keys($._zod.def.shape))),
        ($.catchall = (W) => $.clone({ ...$._zod.def, catchall: W })),
        ($.passthrough = () => $.clone({ ...$._zod.def, catchall: KQ() })),
        ($.loose = () => $.clone({ ...$._zod.def, catchall: KQ() })),
        ($.strict = () => $.clone({ ...$._zod.def, catchall: CQ() })),
        ($.strip = () => $.clone({ ...$._zod.def, catchall: void 0 })),
        ($.extend = (W) => {
            return m.extend($, W);
        }),
        ($.merge = (W) => m.merge($, W)),
        ($.pick = (W) => m.pick($, W)),
        ($.omit = (W) => m.omit($, W)),
        ($.partial = (...W) => m.partial(f9, $, W[0])),
        ($.required = (...W) => m.required(y9, $, W[0]));
});
function DR($, X) {
    let W = {
        type: 'object',
        get shape() {
            return m.assignProp(this, 'shape', { ...$ }), this.shape;
        },
        ...m.normalizeParams(X),
    };
    return new VQ(W);
}
function BR($, X) {
    return new VQ({
        type: 'object',
        get shape() {
            return m.assignProp(this, 'shape', { ...$ }), this.shape;
        },
        catchall: CQ(),
        ...m.normalizeParams(X),
    });
}
function OR($, X) {
    return new VQ({
        type: 'object',
        get shape() {
            return m.assignProp(this, 'shape', { ...$ }), this.shape;
        },
        catchall: KQ(),
        ...m.normalizeParams(X),
    });
}
var g9 = L('ZodUnion', ($, X) => {
    l8.init($, X), J$.init($, X), ($.options = X.options);
});
function EQ($, X) {
    return new g9({ type: 'union', options: $, ...m.normalizeParams(X) });
}
var iw = L('ZodDiscriminatedUnion', ($, X) => {
    g9.init($, X), N7.init($, X);
});
function HR($, X, W) {
    return new iw({
        type: 'union',
        options: X,
        discriminator: $,
        ...m.normalizeParams(W),
    });
}
var nw = L('ZodIntersection', ($, X) => {
    M7.init($, X), J$.init($, X);
});
function pw($, X) {
    return new nw({ type: 'intersection', left: $, right: X });
}
var lw = L('ZodTuple', ($, X) => {
    u0.init($, X),
        J$.init($, X),
        ($.rest = (W) => $.clone({ ...$._zod.def, rest: W }));
});
function qR($, X, W) {
    let Q = X instanceof s,
        Y = Q ? W : X;
    return new lw({
        type: 'tuple',
        items: $,
        rest: Q ? X : null,
        ...m.normalizeParams(Y),
    });
}
var T9 = L('ZodRecord', ($, X) => {
    G7.init($, X),
        J$.init($, X),
        ($.keyType = X.keyType),
        ($.valueType = X.valueType);
});
function ow($, X, W) {
    return new T9({
        type: 'record',
        keyType: $,
        valueType: X,
        ...m.normalizeParams(W),
    });
}
function AR($, X, W) {
    return new T9({
        type: 'record',
        keyType: EQ([$, CQ()]),
        valueType: X,
        ...m.normalizeParams(W),
    });
}
var rw = L('ZodMap', ($, X) => {
    z7.init($, X),
        J$.init($, X),
        ($.keyType = X.keyType),
        ($.valueType = X.valueType);
});
function PR($, X, W) {
    return new rw({
        type: 'map',
        keyType: $,
        valueType: X,
        ...m.normalizeParams(W),
    });
}
var tw = L('ZodSet', ($, X) => {
    Z7.init($, X),
        J$.init($, X),
        ($.min = (...W) => $.check(i0(...W))),
        ($.nonempty = (W) => $.check(i0(1, W))),
        ($.max = (...W) => $.check(vX(...W))),
        ($.size = (...W) => $.check(oW(...W)));
});
function SR($, X) {
    return new tw({ type: 'set', valueType: $, ...m.normalizeParams(X) });
}
var NY = L('ZodEnum', ($, X) => {
    w7.init($, X),
        J$.init($, X),
        ($.enum = X.entries),
        ($.options = Object.values(X.entries));
    let W = new Set(Object.keys(X.entries));
    ($.extract = (Q, Y) => {
        let J = {};
        for (let U of Q)
            if (W.has(U)) J[U] = X.entries[U];
            else throw new Error(`Key ${U} not found in enum`);
        return new NY({
            ...X,
            checks: [],
            ...m.normalizeParams(Y),
            entries: J,
        });
    }),
        ($.exclude = (Q, Y) => {
            let J = { ...X.entries };
            for (let U of Q)
                if (W.has(U)) delete J[U];
                else throw new Error(`Key ${U} not found in enum`);
            return new NY({
                ...X,
                checks: [],
                ...m.normalizeParams(Y),
                entries: J,
            });
        });
});
function aw($, X) {
    let W = Array.isArray($) ? Object.fromEntries($.map((Q) => [Q, Q])) : $;
    return new NY({ type: 'enum', entries: W, ...m.normalizeParams(X) });
}
function jR($, X) {
    return new NY({ type: 'enum', entries: $, ...m.normalizeParams(X) });
}
var sw = L('ZodLiteral', ($, X) => {
    D7.init($, X),
        J$.init($, X),
        ($.values = new Set(X.values)),
        Object.defineProperty($, 'value', {
            get() {
                if (X.values.length > 1)
                    throw new Error(
                        'This schema contains multiple valid literal values. Use `.values` instead.',
                    );
                return X.values[0];
            },
        });
});
function ew($, X) {
    return new sw({
        type: 'literal',
        values: Array.isArray($) ? $ : [$],
        ...m.normalizeParams(X),
    });
}
var $D = L('ZodFile', ($, X) => {
    B7.init($, X),
        J$.init($, X),
        ($.min = (W, Q) => $.check(i0(W, Q))),
        ($.max = (W, Q) => $.check(vX(W, Q))),
        ($.mime = (W, Q) => $.check(XY(Array.isArray(W) ? W : [W], Q)));
});
function LR($) {
    return r5($D, $);
}
var k9 = L('ZodTransform', ($, X) => {
    uW.init($, X),
        J$.init($, X),
        ($._zod.parse = (W, Q) => {
            W.addIssue = (J) => {
                if (typeof J === 'string')
                    W.issues.push(m.issue(J, W.value, X));
                else {
                    let U = J;
                    if (U.fatal) U.continue = !1;
                    U.code ?? (U.code = 'custom'),
                        U.input ?? (U.input = W.value),
                        U.inst ?? (U.inst = $),
                        U.continue ?? (U.continue = !0),
                        W.issues.push(m.issue(U));
                }
            };
            let Y = X.transform(W.value, W);
            if (Y instanceof Promise)
                return Y.then((J) => {
                    return (W.value = J), W;
                });
            return (W.value = Y), W;
        });
});
function v9($) {
    return new k9({ type: 'transform', transform: $ });
}
var f9 = L('ZodOptional', ($, X) => {
    O7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function _Q($) {
    return new f9({ type: 'optional', innerType: $ });
}
var XD = L('ZodNullable', ($, X) => {
    H7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function FQ($) {
    return new XD({ type: 'nullable', innerType: $ });
}
function KR($) {
    return _Q(FQ($));
}
var WD = L('ZodDefault', ($, X) => {
    q7.init($, X),
        J$.init($, X),
        ($.unwrap = () => $._zod.def.innerType),
        ($.removeDefault = $.unwrap);
});
function YD($, X) {
    return new WD({
        type: 'default',
        innerType: $,
        get defaultValue() {
            return typeof X === 'function' ? X() : X;
        },
    });
}
var QD = L('ZodPrefault', ($, X) => {
    A7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function JD($, X) {
    return new QD({
        type: 'prefault',
        innerType: $,
        get defaultValue() {
            return typeof X === 'function' ? X() : X;
        },
    });
}
var y9 = L('ZodNonOptional', ($, X) => {
    P7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function UD($, X) {
    return new y9({
        type: 'nonoptional',
        innerType: $,
        ...m.normalizeParams(X),
    });
}
var ND = L('ZodSuccess', ($, X) => {
    S7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function _R($) {
    return new ND({ type: 'success', innerType: $ });
}
var MD = L('ZodCatch', ($, X) => {
    j7.init($, X),
        J$.init($, X),
        ($.unwrap = () => $._zod.def.innerType),
        ($.removeCatch = $.unwrap);
});
function GD($, X) {
    return new MD({
        type: 'catch',
        innerType: $,
        catchValue: typeof X === 'function' ? X : () => X,
    });
}
var zD = L('ZodNaN', ($, X) => {
    L7.init($, X), J$.init($, X);
});
function FR($) {
    return u5(zD, $);
}
var h9 = L('ZodPipe', ($, X) => {
    dW.init($, X), J$.init($, X), ($.in = X.in), ($.out = X.out);
});
function IQ($, X) {
    return new h9({ type: 'pipe', in: $, out: X });
}
var ZD = L('ZodReadonly', ($, X) => {
    K7.init($, X), J$.init($, X);
});
function wD($) {
    return new ZD({ type: 'readonly', innerType: $ });
}
var DD = L('ZodTemplateLiteral', ($, X) => {
    _7.init($, X), J$.init($, X);
});
function IR($, X) {
    return new DD({
        type: 'template_literal',
        parts: $,
        ...m.normalizeParams(X),
    });
}
var BD = L('ZodLazy', ($, X) => {
    I7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.getter());
});
function OD($) {
    return new BD({ type: 'lazy', getter: $ });
}
var HD = L('ZodPromise', ($, X) => {
    F7.init($, X), J$.init($, X), ($.unwrap = () => $._zod.def.innerType);
});
function CR($) {
    return new HD({ type: 'promise', innerType: $ });
}
var xQ = L('ZodCustom', ($, X) => {
    C7.init($, X), J$.init($, X);
});
function qD($) {
    let X = new a$({ check: 'custom' });
    return (X._zod.check = $), X;
}
function RR($, X) {
    return t5(xQ, $ ?? (() => !0), X);
}
function AD($, X = {}) {
    return a5(xQ, $, X);
}
function PD($) {
    let X = qD((W) => {
        return (
            (W.addIssue = (Q) => {
                if (typeof Q === 'string')
                    W.issues.push(m.issue(Q, W.value, X._zod.def));
                else {
                    let Y = Q;
                    if (Y.fatal) Y.continue = !1;
                    Y.code ?? (Y.code = 'custom'),
                        Y.input ?? (Y.input = W.value),
                        Y.inst ?? (Y.inst = X),
                        Y.continue ?? (Y.continue = !X._zod.def.abort),
                        W.issues.push(m.issue(Y));
                }
            }),
            $(W.value, W)
        );
    });
    return X;
}
function VR($, X = { error: `Input not instance of ${$.name}` }) {
    let W = new xQ({
        type: 'custom',
        check: 'custom',
        fn: (Q) => Q instanceof $,
        abort: !0,
        ...m.normalizeParams(X),
    });
    return (W._zod.bag.Class = $), W;
}
var ER = (...$) =>
    s5({ Pipe: h9, Boolean: zY, String: MY, Transform: k9 }, ...$);
function xR($) {
    let X = OD(() => {
        return EQ([Z9($), gw(), Tw(), yw(), b9(X), ow(Z9(), X)]);
    });
    return X;
}
function bR($, X) {
    return IQ(v9($), X);
}
var gR = {
    invalid_type: 'invalid_type',
    too_big: 'too_big',
    too_small: 'too_small',
    invalid_format: 'invalid_format',
    not_multiple_of: 'not_multiple_of',
    unrecognized_keys: 'unrecognized_keys',
    invalid_union: 'invalid_union',
    invalid_key: 'invalid_key',
    invalid_element: 'invalid_element',
    invalid_value: 'invalid_value',
    custom: 'custom',
};
function TR($) {
    z6({ customError: $ });
}
function kR() {
    return z6().customError;
}
var m9;
(function ($) {})(m9 || (m9 = {}));
var c9 = {};
k6(c9, {
    string: () => vR,
    number: () => fR,
    date: () => mR,
    boolean: () => yR,
    bigint: () => hR,
});
function vR($) {
    return O5(MY, $);
}
function fR($) {
    return L5(GY, $);
}
function yR($) {
    return V5(zY, $);
}
function hR($) {
    return x5(ZY, $);
}
function mR($) {
    return c5(RQ, $);
}
z6(iW());
var bQ = S6.object({
    APP_NAME: S6.string(),
    APP_HOST: S6.url(),
    APP_IP: S6.ipv4(),
    MODE: S6.literal(['DEVELOPMENT', 'PRODUCTION', 'BUILDING', 'PREVIEW']),
    PORT_BOT_APP: S6.coerce.number(),
    PORT_MINIAPP_APP: S6.coerce.number(),
    PORT_API_APP: S6.coerce.number(),
    PORT_ADMIN_APP: S6.coerce.number(),
    SUB_BOT_APP: S6.string(),
    SUB_MINIAPP_APP: S6.string(),
    SUB_API_APP: S6.string(),
    SUB_ADMIN_APP: S6.string(),
    TELEGRAM_BOT_TOKEN: S6.string().min(10),
    TELEGRAM_BOT_TESTING_TOKEN: S6.string().min(10),
});
var cR = bQ.pick({ PORT_API_APP: !0 }),
    SD = ($) => cR.parse($);
var uR = bQ.pick({ MODE: !0 }),
    jD = ($) => uR.parse($).MODE;
var LD = SD(Bun.env),
    gQ = jD(Bun.env),
    Lp = gQ === 'DEVELOPMENT' || gQ == 'PREVIEW';
var u9 = new V4().get('/', 'Hello, world!').listen(LD.PORT_API_APP),
    Ip = u9.fetch;
console.log(
    `\uD83E\uDD8A Elysia is running at ${u9.server?.hostname}:${u9.server?.port} in ${gQ} mode`,
);
export { Ip as default };

//# debugId=0C6592D4F9196C3564756E2164756E21
